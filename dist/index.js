import{createRequire as rQ} from"node:module";var nQ=Object.create;var{defineProperty:I4,getPrototypeOf:sQ,getOwnPropertyNames:aQ}=Object;var oQ=Object.prototype.hasOwnProperty;var P4=(X,Z,J)=>{J=X!=null?nQ(sQ(X)):{};const K=Z||!X||!X.__esModule?I4(J,"default",{value:X,enumerable:!0}):J;for(let W of aQ(X))if(!oQ.call(K,W))I4(K,W,{get:()=>X[W],enumerable:!0});return K};var g0=(X,Z)=>()=>(Z||X((Z={exports:{}}).exports,Z),Z.exports);var tQ=(X,Z)=>{for(var J in Z)I4(X,J,{get:Z[J],enumerable:!0,configurable:!0,set:(K)=>Z[J]=()=>K})};var f1=(X,Z)=>()=>(X&&(Z=X(X=0)),Z);var y0=rQ(import.meta.url);var O5=g0((C$,z5)=>{(function(X,Z){typeof C$==="object"&&typeof z5!=="undefined"?Z(C$):typeof define==="function"&&define.amd?define(["exports"],Z):(X=typeof globalThis!=="undefined"?globalThis:X||self,Z(X.WebStreamsPolyfill={}))})(C$,function(X){function Z(){return}function J($){return typeof $==="object"&&$!==null||typeof $==="function"}const K=Z;function W($,Q){try{Object.defineProperty($,"name",{value:Q,configurable:!0})}catch(G){}}const w=Promise,O=Promise.prototype.then,H=Promise.reject.bind(w);function I($){return new w($)}function U($){return I((Q)=>Q($))}function B($){return H($)}function L($,Q,G){return O.call($,Q,G)}function T($,Q,G){L(L($,Q,G),void 0,K)}function E($,Q){T($,Q)}function D($,Q){T($,void 0,Q)}function S($,Q,G){return L($,Q,G)}function _($){L($,void 0,K)}let F=($)=>{if(typeof queueMicrotask==="function")F=queueMicrotask;else{const Q=U(void 0);F=(G)=>L(Q,G)}return F($)};function P($,Q,G){if(typeof $!=="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call($,Q,G)}function y($,Q,G){try{return U(P($,Q,G))}catch(Y){return B(Y)}}const f=16384;class j{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push($){const Q=this._back;let G=Q;if(Q._elements.length===f-1)G={_elements:[],_next:void 0};if(Q._elements.push($),G!==Q)this._back=G,Q._next=G;++this._size}shift(){const $=this._front;let Q=$;const G=this._cursor;let Y=G+1;const V=$._elements,z=V[G];if(Y===f)Q=$._next,Y=0;if(--this._size,this._cursor=Y,$!==Q)this._front=Q;return V[G]=void 0,z}forEach($){let Q=this._cursor,G=this._front,Y=G._elements;while(Q!==Y.length||G._next!==void 0){if(Q===Y.length){if(G=G._next,Y=G._elements,Q=0,Y.length===0)break}$(Y[Q]),++Q}}peek(){const $=this._front,Q=this._cursor;return $._elements[Q]}}const p=Symbol("[[AbortSteps]]"),D1=Symbol("[[ErrorSteps]]"),A1=Symbol("[[CancelSteps]]"),k$=Symbol("[[PullSteps]]"),_$=Symbol("[[ReleaseSteps]]");function h4($,Q){if($._ownerReadableStream=Q,Q._reader=$,Q._state==="readable")S$($);else if(Q._state==="closed")Z8($);else g4($,Q._storedError)}function L$($,Q){const G=$._ownerReadableStream;return W0(G,Q)}function I0($){const Q=$._ownerReadableStream;if(Q._state==="readable")v$($,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));else G8($,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));Q._readableStreamController[_$](),Q._reader=void 0,$._ownerReadableStream=void 0}function d1($){return new TypeError("Cannot "+$+" a stream using a released reader")}function S$($){$._closedPromise=I((Q,G)=>{$._closedPromise_resolve=Q,$._closedPromise_reject=G})}function g4($,Q){S$($),v$($,Q)}function Z8($){S$($),y4($)}function v$($,Q){if($._closedPromise_reject===void 0)return;_($._closedPromise),$._closedPromise_reject(Q),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0}function G8($,Q){g4($,Q)}function y4($){if($._closedPromise_resolve===void 0)return;$._closedPromise_resolve(void 0),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0}const b4=Number.isFinite||function($){return typeof $==="number"&&isFinite($)},J8=Math.trunc||function($){return $<0?Math.ceil($):Math.floor($)};function K8($){return typeof $==="object"||typeof $==="function"}function z0($,Q){if($!==void 0&&!K8($))throw new TypeError(`${Q} is not an object.`)}function Q0($,Q){if(typeof $!=="function")throw new TypeError(`${Q} is not a function.`)}function W8($){return typeof $==="object"&&$!==null||typeof $==="function"}function m4($,Q){if(!W8($))throw new TypeError(`${Q} is not an object.`)}function P0($,Q,G){if($===void 0)throw new TypeError(`Parameter ${Q} is required in '${G}'.`)}function f$($,Q,G){if($===void 0)throw new TypeError(`${Q} is required in '${G}'.`)}function h$($){return Number($)}function u4($){return $===0?0:$}function Y8($){return u4(J8($))}function g$($,Q){const Y=Number.MAX_SAFE_INTEGER;let V=Number($);if(V=u4(V),!b4(V))throw new TypeError(`${Q} is not a finite number`);if(V=Y8(V),V<0||V>Y)throw new TypeError(`${Q} is outside the accepted range of 0 to ${Y}, inclusive`);if(!b4(V)||V===0)return 0;return V}function y$($,Q){if(!v0($))throw new TypeError(`${Q} is not a ReadableStream.`)}function Q1($){return new C0($)}function p4($,Q){$._reader._readRequests.push(Q)}function b$($,Q,G){const V=$._reader._readRequests.shift();if(G)V._closeSteps();else V._chunkSteps(Q)}function i1($){return $._reader._readRequests.length}function c4($){const Q=$._reader;if(Q===void 0)return!1;if(!k0(Q))return!1;return!0}class C0{constructor($){if(P0($,1,"ReadableStreamDefaultReader"),y$($,"First parameter"),f0($))throw new TypeError("This stream has already been locked for exclusive reading by another reader");h4(this,$),this._readRequests=new j}get closed(){if(!k0(this))return B(l1("closed"));return this._closedPromise}cancel($=void 0){if(!k0(this))return B(l1("cancel"));if(this._ownerReadableStream===void 0)return B(d1("cancel"));return L$(this,$)}read(){if(!k0(this))return B(l1("read"));if(this._ownerReadableStream===void 0)return B(d1("read from"));let $,Q;const G=I((V,z)=>{$=V,Q=z});return x1(this,{_chunkSteps:(V)=>$({value:V,done:!1}),_closeSteps:()=>$({value:void 0,done:!0}),_errorSteps:(V)=>Q(V)}),G}releaseLock(){if(!k0(this))throw l1("releaseLock");if(this._ownerReadableStream===void 0)return;w8(this)}}if(Object.defineProperties(C0.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),W(C0.prototype.cancel,"cancel"),W(C0.prototype.read,"read"),W(C0.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(C0.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});function k0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readRequests"))return!1;return $ instanceof C0}function x1($,Q){const G=$._ownerReadableStream;if(G._disturbed=!0,G._state==="closed")Q._closeSteps();else if(G._state==="errored")Q._errorSteps(G._storedError);else G._readableStreamController[k$](Q)}function w8($){I0($);const Q=new TypeError("Reader was released");d4($,Q)}function d4($,Q){const G=$._readRequests;$._readRequests=new j,G.forEach((Y)=>{Y._errorSteps(Q)})}function l1($){return new TypeError(`ReadableStreamDefaultReader.prototype.${$} can only be used on a ReadableStreamDefaultReader`)}const V8=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);class m${constructor($,Q){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=$,this._preventCancel=Q}next(){const $=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?S(this._ongoingPromise,$,$):$(),this._ongoingPromise}return($){const Q=()=>this._returnSteps($);return this._ongoingPromise?S(this._ongoingPromise,Q,Q):Q()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const $=this._reader;let Q,G;const Y=I((z,M)=>{Q=z,G=M});return x1($,{_chunkSteps:(z)=>{this._ongoingPromise=void 0,F(()=>Q({value:z,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,I0($),Q({value:void 0,done:!0})},_errorSteps:(z)=>{this._ongoingPromise=void 0,this._isFinished=!0,I0($),G(z)}}),Y}_returnSteps($){if(this._isFinished)return Promise.resolve({value:$,done:!0});this._isFinished=!0;const Q=this._reader;if(!this._preventCancel){const G=L$(Q,$);return I0(Q),S(G,()=>({value:$,done:!0}))}return I0(Q),U({value:$,done:!0})}}const i4={next(){if(!l4(this))return B(n4("next"));return this._asyncIteratorImpl.next()},return($){if(!l4(this))return B(n4("return"));return this._asyncIteratorImpl.return($)}};Object.setPrototypeOf(i4,V8);function z8($,Q){const G=Q1($),Y=new m$(G,Q),V=Object.create(i4);return V._asyncIteratorImpl=Y,V}function l4($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_asyncIteratorImpl"))return!1;try{return $._asyncIteratorImpl instanceof m$}catch(Q){return!1}}function n4($){return new TypeError(`ReadableStreamAsyncIterator.${$} can only be used on a ReadableSteamAsyncIterator`)}const s4=Number.isNaN||function($){return $!==$};var u$,p$,c$;function E1($){return $.slice()}function a4($,Q,G,Y,V){new Uint8Array($).set(new Uint8Array(G,Y,V),Q)}let D0=($)=>{if(typeof $.transfer==="function")D0=(Q)=>Q.transfer();else if(typeof structuredClone==="function")D0=(Q)=>structuredClone(Q,{transfer:[Q]});else D0=(Q)=>Q;return D0($)},_0=($)=>{if(typeof $.detached==="boolean")_0=(Q)=>Q.detached;else _0=(Q)=>Q.byteLength===0;return _0($)};function o4($,Q,G){if($.slice)return $.slice(Q,G);const Y=G-Q,V=new ArrayBuffer(Y);return a4(V,0,$,Q,Y),V}function n1($,Q){const G=$[Q];if(G===void 0||G===null)return;if(typeof G!=="function")throw new TypeError(`${String(Q)} is not a function`);return G}function O8($){const Q={[Symbol.iterator]:()=>$.iterator},G=async function*(){return yield*Q}(),Y=G.next;return{iterator:G,nextMethod:Y,done:!1}}const d$=(c$=(u$=Symbol.asyncIterator)!==null&&u$!==void 0?u$:(p$=Symbol.for)===null||p$===void 0?void 0:p$.call(Symbol,"Symbol.asyncIterator"))!==null&&c$!==void 0?c$:"@@asyncIterator";function t4($,Q="sync",G){if(G===void 0)if(Q==="async"){if(G=n1($,d$),G===void 0){const z=n1($,Symbol.iterator),M=t4($,"sync",z);return O8(M)}}else G=n1($,Symbol.iterator);if(G===void 0)throw new TypeError("The object is not iterable");const Y=P(G,$,[]);if(!J(Y))throw new TypeError("The iterator method must return an object");const V=Y.next;return{iterator:Y,nextMethod:V,done:!1}}function H8($){const Q=P($.nextMethod,$.iterator,[]);if(!J(Q))throw new TypeError("The iterator.next() method must return an object");return Q}function M8($){return Boolean($.done)}function U8($){return $.value}function B8($){if(typeof $!=="number")return!1;if(s4($))return!1;if($<0)return!1;return!0}function r4($){const Q=o4($.buffer,$.byteOffset,$.byteOffset+$.byteLength);return new Uint8Array(Q)}function i$($){const Q=$._queue.shift();if($._queueTotalSize-=Q.size,$._queueTotalSize<0)$._queueTotalSize=0;return Q.value}function l$($,Q,G){if(!B8(G)||G===Infinity)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");$._queue.push({value:Q,size:G}),$._queueTotalSize+=G}function I8($){return $._queue.peek().value}function L0($){$._queue=new j,$._queueTotalSize=0}function e4($){return $===DataView}function P8($){return e4($.constructor)}function C8($){if(e4($))return 1;return $.BYTES_PER_ELEMENT}class S0{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!n$(this))throw r$("view");return this._view}respond($){if(!n$(this))throw r$("respond");if(P0($,1,"respond"),$=g$($,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_0(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");t1(this._associatedReadableByteStreamController,$)}respondWithNewView($){if(!n$(this))throw r$("respondWithNewView");if(P0($,1,"respondWithNewView"),!ArrayBuffer.isView($))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_0($.buffer))throw new TypeError("The given view\'s buffer has been detached and so cannot be used as a response");r1(this._associatedReadableByteStreamController,$)}}if(Object.defineProperties(S0.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),W(S0.prototype.respond,"respond"),W(S0.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(S0.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class O0{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!c0(this))throw N1("byobRequest");return t$(this)}get desiredSize(){if(!c0(this))throw N1("desiredSize");return w6(this)}close(){if(!c0(this))throw N1("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const $=this._controlledReadableByteStream._state;if($!=="readable")throw new TypeError(`The stream (in ${$} state) is not in the readable state and cannot be closed`);F1(this)}enqueue($){if(!c0(this))throw N1("enqueue");if(P0($,1,"enqueue"),!ArrayBuffer.isView($))throw new TypeError("chunk must be an array buffer view");if($.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if($.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const Q=this._controlledReadableByteStream._state;if(Q!=="readable")throw new TypeError(`The stream (in ${Q} state) is not in the readable state and cannot be enqueued to`);o1(this,$)}error($=void 0){if(!c0(this))throw N1("error");X0(this,$)}[A1]($){$6(this),L0(this);const Q=this._cancelAlgorithm($);return a1(this),Q}[k$]($){const Q=this._controlledReadableByteStream;if(this._queueTotalSize>0){Y6(this,$);return}const G=this._autoAllocateChunkSize;if(G!==void 0){let Y;try{Y=new ArrayBuffer(G)}catch(z){$._errorSteps(z);return}const V={buffer:Y,bufferByteLength:G,byteOffset:0,byteLength:G,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(V)}p4(Q,$),d0(this)}[_$](){if(this._pendingPullIntos.length>0){const $=this._pendingPullIntos.peek();$.readerType="none",this._pendingPullIntos=new j,this._pendingPullIntos.push($)}}}if(Object.defineProperties(O0.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),W(O0.prototype.close,"close"),W(O0.prototype.enqueue,"enqueue"),W(O0.prototype.error,"error"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(O0.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});function c0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledReadableByteStream"))return!1;return $ instanceof O0}function n$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_associatedReadableByteStreamController"))return!1;return $ instanceof S0}function d0($){if(!F8($))return;if($._pulling){$._pullAgain=!0;return}$._pulling=!0;const G=$._pullAlgorithm();T(G,()=>{if($._pulling=!1,$._pullAgain)$._pullAgain=!1,d0($);return null},(Y)=>{return X0($,Y),null})}function $6($){a$($),$._pendingPullIntos=new j}function s$($,Q){let G=!1;if($._state==="closed")G=!0;const Y=Q6(Q);if(Q.readerType==="default")b$($,Y,G);else k8($,Y,G)}function Q6($){const{bytesFilled:Q,elementSize:G}=$;return new $.viewConstructor($.buffer,$.byteOffset,Q/G)}function s1($,Q,G,Y){$._queue.push({buffer:Q,byteOffset:G,byteLength:Y}),$._queueTotalSize+=Y}function X6($,Q,G,Y){let V;try{V=o4(Q,G,G+Y)}catch(z){throw X0($,z),z}s1($,V,0,Y)}function Z6($,Q){if(Q.bytesFilled>0)X6($,Q.buffer,Q.byteOffset,Q.bytesFilled);X1($)}function G6($,Q){const G=Math.min($._queueTotalSize,Q.byteLength-Q.bytesFilled),Y=Q.bytesFilled+G;let V=G,z=!1;const M=Y%Q.elementSize,C=Y-M;if(C>=Q.minimumFill)V=C-Q.bytesFilled,z=!0;const A=$._queue;while(V>0){const N=A.peek(),q=Math.min(V,N.byteLength),R=Q.byteOffset+Q.bytesFilled;if(a4(Q.buffer,R,N.buffer,N.byteOffset,q),N.byteLength===q)A.shift();else N.byteOffset+=q,N.byteLength-=q;$._queueTotalSize-=q,J6($,q,Q),V-=q}return z}function J6($,Q,G){G.bytesFilled+=Q}function K6($){if($._queueTotalSize===0&&$._closeRequested)a1($),_1($._controlledReadableByteStream);else d0($)}function a$($){if($._byobRequest===null)return;$._byobRequest._associatedReadableByteStreamController=void 0,$._byobRequest._view=null,$._byobRequest=null}function o$($){while($._pendingPullIntos.length>0){if($._queueTotalSize===0)return;const Q=$._pendingPullIntos.peek();if(G6($,Q))X1($),s$($._controlledReadableByteStream,Q)}}function D8($){const Q=$._controlledReadableByteStream._reader;while(Q._readRequests.length>0){if($._queueTotalSize===0)return;const G=Q._readRequests.shift();Y6($,G)}}function A8($,Q,G,Y){const V=$._controlledReadableByteStream,z=Q.constructor,M=C8(z),{byteOffset:C,byteLength:A}=Q,N=G*M;let q;try{q=D0(Q.buffer)}catch(v){Y._errorSteps(v);return}const R={buffer:q,bufferByteLength:q.byteLength,byteOffset:C,byteLength:A,bytesFilled:0,minimumFill:N,elementSize:M,viewConstructor:z,readerType:"byob"};if($._pendingPullIntos.length>0){$._pendingPullIntos.push(R),O6(V,Y);return}if(V._state==="closed"){const v=new z(R.buffer,R.byteOffset,0);Y._closeSteps(v);return}if($._queueTotalSize>0){if(G6($,R)){const v=Q6(R);K6($),Y._chunkSteps(v);return}if($._closeRequested){const v=new TypeError("Insufficient bytes to fill elements in the given buffer");X0($,v),Y._errorSteps(v);return}}$._pendingPullIntos.push(R),O6(V,Y),d0($)}function x8($,Q){if(Q.readerType==="none")X1($);const G=$._controlledReadableByteStream;if(e$(G))while(H6(G)>0){const Y=X1($);s$(G,Y)}}function E8($,Q,G){if(J6($,Q,G),G.readerType==="none"){Z6($,G),o$($);return}if(G.bytesFilled<G.minimumFill)return;X1($);const Y=G.bytesFilled%G.elementSize;if(Y>0){const V=G.byteOffset+G.bytesFilled;X6($,G.buffer,V-Y,Y)}G.bytesFilled-=Y,s$($._controlledReadableByteStream,G),o$($)}function W6($,Q){const G=$._pendingPullIntos.peek();if(a$($),$._controlledReadableByteStream._state==="closed")x8($,G);else E8($,Q,G);d0($)}function X1($){return $._pendingPullIntos.shift()}function F8($){const Q=$._controlledReadableByteStream;if(Q._state!=="readable")return!1;if($._closeRequested)return!1;if(!$._started)return!1;if(c4(Q)&&i1(Q)>0)return!0;if(e$(Q)&&H6(Q)>0)return!0;if(w6($)>0)return!0;return!1}function a1($){$._pullAlgorithm=void 0,$._cancelAlgorithm=void 0}function F1($){const Q=$._controlledReadableByteStream;if($._closeRequested||Q._state!=="readable")return;if($._queueTotalSize>0){$._closeRequested=!0;return}if($._pendingPullIntos.length>0){const G=$._pendingPullIntos.peek();if(G.bytesFilled%G.elementSize!==0){const Y=new TypeError("Insufficient bytes to fill elements in the given buffer");throw X0($,Y),Y}}a1($),_1(Q)}function o1($,Q){const G=$._controlledReadableByteStream;if($._closeRequested||G._state!=="readable")return;const{buffer:Y,byteOffset:V,byteLength:z}=Q;if(_0(Y))throw new TypeError("chunk\'s buffer is detached and so cannot be enqueued");const M=D0(Y);if($._pendingPullIntos.length>0){const C=$._pendingPullIntos.peek();if(_0(C.buffer))throw new TypeError("The BYOB request\'s buffer has been detached and so cannot be filled with an enqueued chunk");if(a$($),C.buffer=D0(C.buffer),C.readerType==="none")Z6($,C)}if(c4(G))if(D8($),i1(G)===0)s1($,M,V,z);else{if($._pendingPullIntos.length>0)X1($);const C=new Uint8Array(M,V,z);b$(G,C,!1)}else if(e$(G))s1($,M,V,z),o$($);else s1($,M,V,z);d0($)}function X0($,Q){const G=$._controlledReadableByteStream;if(G._state!=="readable")return;$6($),L0($),a1($),g6(G,Q)}function Y6($,Q){const G=$._queue.shift();$._queueTotalSize-=G.byteLength,K6($);const Y=new Uint8Array(G.buffer,G.byteOffset,G.byteLength);Q._chunkSteps(Y)}function t$($){if($._byobRequest===null&&$._pendingPullIntos.length>0){const Q=$._pendingPullIntos.peek(),G=new Uint8Array(Q.buffer,Q.byteOffset+Q.bytesFilled,Q.byteLength-Q.bytesFilled),Y=Object.create(S0.prototype);q8(Y,$,G),$._byobRequest=Y}return $._byobRequest}function w6($){const Q=$._controlledReadableByteStream._state;if(Q==="errored")return null;if(Q==="closed")return 0;return $._strategyHWM-$._queueTotalSize}function t1($,Q){const G=$._pendingPullIntos.peek();if($._controlledReadableByteStream._state==="closed"){if(Q!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(Q===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(G.bytesFilled+Q>G.byteLength)throw new RangeError("bytesWritten out of range")}G.buffer=D0(G.buffer),W6($,Q)}function r1($,Q){const G=$._pendingPullIntos.peek();if($._controlledReadableByteStream._state==="closed"){if(Q.byteLength!==0)throw new TypeError("The view\'s length must be 0 when calling respondWithNewView() on a closed stream")}else if(Q.byteLength===0)throw new TypeError("The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream");if(G.byteOffset+G.bytesFilled!==Q.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(G.bufferByteLength!==Q.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(G.bytesFilled+Q.byteLength>G.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const V=Q.byteLength;G.buffer=D0(Q.buffer),W6($,V)}function V6($,Q,G,Y,V,z,M){Q._controlledReadableByteStream=$,Q._pullAgain=!1,Q._pulling=!1,Q._byobRequest=null,Q._queue=Q._queueTotalSize=void 0,L0(Q),Q._closeRequested=!1,Q._started=!1,Q._strategyHWM=z,Q._pullAlgorithm=Y,Q._cancelAlgorithm=V,Q._autoAllocateChunkSize=M,Q._pendingPullIntos=new j,$._readableStreamController=Q;const C=G();T(U(C),()=>{return Q._started=!0,d0(Q),null},(A)=>{return X0(Q,A),null})}function N8($,Q,G){const Y=Object.create(O0.prototype);let V,z,M;if(Q.start!==void 0)V=()=>Q.start(Y);else V=()=>{return};if(Q.pull!==void 0)z=()=>Q.pull(Y);else z=()=>U(void 0);if(Q.cancel!==void 0)M=(A)=>Q.cancel(A);else M=()=>U(void 0);const C=Q.autoAllocateChunkSize;if(C===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");V6($,Y,V,z,M,G,C)}function q8($,Q,G){$._associatedReadableByteStreamController=Q,$._view=G}function r$($){return new TypeError(`ReadableStreamBYOBRequest.prototype.${$} can only be used on a ReadableStreamBYOBRequest`)}function N1($){return new TypeError(`ReadableByteStreamController.prototype.${$} can only be used on a ReadableByteStreamController`)}function j8($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.mode;return{mode:G===void 0?void 0:T8(G,`${Q} has member 'mode' that`)}}function T8($,Q){if($=`${$}`,$!=="byob")throw new TypeError(`${Q} '${$}' is not a valid enumeration value for ReadableStreamReaderMode`);return $}function R8($,Q){var G;z0($,Q);const Y=(G=$===null||$===void 0?void 0:$.min)!==null&&G!==void 0?G:1;return{min:g$(Y,`${Q} has member 'min' that`)}}function z6($){return new A0($)}function O6($,Q){$._reader._readIntoRequests.push(Q)}function k8($,Q,G){const V=$._reader._readIntoRequests.shift();if(G)V._closeSteps(Q);else V._chunkSteps(Q)}function H6($){return $._reader._readIntoRequests.length}function e$($){const Q=$._reader;if(Q===void 0)return!1;if(!i0(Q))return!1;return!0}class A0{constructor($){if(P0($,1,"ReadableStreamBYOBReader"),y$($,"First parameter"),f0($))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!c0($._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");h4(this,$),this._readIntoRequests=new j}get closed(){if(!i0(this))return B(e1("closed"));return this._closedPromise}cancel($=void 0){if(!i0(this))return B(e1("cancel"));if(this._ownerReadableStream===void 0)return B(d1("cancel"));return L$(this,$)}read($,Q={}){if(!i0(this))return B(e1("read"));if(!ArrayBuffer.isView($))return B(new TypeError("view must be an array buffer view"));if($.byteLength===0)return B(new TypeError("view must have non-zero byteLength"));if($.buffer.byteLength===0)return B(new TypeError("view's buffer must have non-zero byteLength"));if(_0($.buffer))return B(new TypeError("view\'s buffer has been detached"));let G;try{G=R8(Q,"options")}catch(A){return B(A)}const Y=G.min;if(Y===0)return B(new TypeError("options.min must be greater than 0"));if(!P8($)){if(Y>$.length)return B(new RangeError("options.min must be less than or equal to view\'s length"))}else if(Y>$.byteLength)return B(new RangeError("options.min must be less than or equal to view\'s byteLength"));if(this._ownerReadableStream===void 0)return B(d1("read from"));let V,z;const M=I((A,N)=>{V=A,z=N});return M6(this,$,Y,{_chunkSteps:(A)=>V({value:A,done:!1}),_closeSteps:(A)=>V({value:A,done:!0}),_errorSteps:(A)=>z(A)}),M}releaseLock(){if(!i0(this))throw e1("releaseLock");if(this._ownerReadableStream===void 0)return;_8(this)}}if(Object.defineProperties(A0.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),W(A0.prototype.cancel,"cancel"),W(A0.prototype.read,"read"),W(A0.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(A0.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});function i0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readIntoRequests"))return!1;return $ instanceof A0}function M6($,Q,G,Y){const V=$._ownerReadableStream;if(V._disturbed=!0,V._state==="errored")Y._errorSteps(V._storedError);else A8(V._readableStreamController,Q,G,Y)}function _8($){I0($);const Q=new TypeError("Reader was released");U6($,Q)}function U6($,Q){const G=$._readIntoRequests;$._readIntoRequests=new j,G.forEach((Y)=>{Y._errorSteps(Q)})}function e1($){return new TypeError(`ReadableStreamBYOBReader.prototype.${$} can only be used on a ReadableStreamBYOBReader`)}function q1($,Q){const{highWaterMark:G}=$;if(G===void 0)return Q;if(s4(G)||G<0)throw new RangeError("Invalid highWaterMark");return G}function $$($){const{size:Q}=$;if(!Q)return()=>1;return Q}function Q$($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.highWaterMark,Y=$===null||$===void 0?void 0:$.size;return{highWaterMark:G===void 0?void 0:h$(G),size:Y===void 0?void 0:L8(Y,`${Q} has member 'size' that`)}}function L8($,Q){return Q0($,Q),(G)=>h$($(G))}function S8($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.abort,Y=$===null||$===void 0?void 0:$.close,V=$===null||$===void 0?void 0:$.start,z=$===null||$===void 0?void 0:$.type,M=$===null||$===void 0?void 0:$.write;return{abort:G===void 0?void 0:v8(G,$,`${Q} has member 'abort' that`),close:Y===void 0?void 0:f8(Y,$,`${Q} has member 'close' that`),start:V===void 0?void 0:h8(V,$,`${Q} has member 'start' that`),write:M===void 0?void 0:g8(M,$,`${Q} has member 'write' that`),type:z}}function v8($,Q,G){return Q0($,G),(Y)=>y($,Q,[Y])}function f8($,Q,G){return Q0($,G),()=>y($,Q,[])}function h8($,Q,G){return Q0($,G),(Y)=>P($,Q,[Y])}function g8($,Q,G){return Q0($,G),(Y,V)=>y($,Q,[Y,V])}function B6($,Q){if(!Z1($))throw new TypeError(`${Q} is not a WritableStream.`)}function y8($){if(typeof $!=="object"||$===null)return!1;try{return typeof $.aborted==="boolean"}catch(Q){return!1}}const b8=typeof AbortController==="function";function m8(){if(b8)return new AbortController;return}class x0{constructor($={},Q={}){if($===void 0)$=null;else m4($,"First parameter");const G=Q$(Q,"Second parameter"),Y=S8($,"First parameter");if(P6(this),Y.type!==void 0)throw new RangeError("Invalid type is specified");const z=$$(G),M=q1(G,1);$Q(this,Y,M,z)}get locked(){if(!Z1(this))throw K$("locked");return G1(this)}abort($=void 0){if(!Z1(this))return B(K$("abort"));if(G1(this))return B(new TypeError("Cannot abort a stream that already has a writer"));return X$(this,$)}close(){if(!Z1(this))return B(K$("close"));if(G1(this))return B(new TypeError("Cannot close a stream that already has a writer"));if(H0(this))return B(new TypeError("Cannot close an already-closing stream"));return C6(this)}getWriter(){if(!Z1(this))throw K$("getWriter");return I6(this)}}if(Object.defineProperties(x0.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),W(x0.prototype.abort,"abort"),W(x0.prototype.close,"close"),W(x0.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(x0.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});function I6($){return new M0($)}function u8($,Q,G,Y,V=1,z=()=>1){const M=Object.create(x0.prototype);P6(M);const C=Object.create(n0.prototype);return N6(M,C,$,Q,G,Y,V,z),M}function P6($){$._state="writable",$._storedError=void 0,$._writer=void 0,$._writableStreamController=void 0,$._writeRequests=new j,$._inFlightWriteRequest=void 0,$._closeRequest=void 0,$._inFlightCloseRequest=void 0,$._pendingAbortRequest=void 0,$._backpressure=!1}function Z1($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_writableStreamController"))return!1;return $ instanceof x0}function G1($){if($._writer===void 0)return!1;return!0}function X$($,Q){var G;if($._state==="closed"||$._state==="errored")return U(void 0);$._writableStreamController._abortReason=Q,(G=$._writableStreamController._abortController)===null||G===void 0||G.abort(Q);const Y=$._state;if(Y==="closed"||Y==="errored")return U(void 0);if($._pendingAbortRequest!==void 0)return $._pendingAbortRequest._promise;let V=!1;if(Y==="erroring")V=!0,Q=void 0;const z=I((M,C)=>{$._pendingAbortRequest={_promise:void 0,_resolve:M,_reject:C,_reason:Q,_wasAlreadyErroring:V}});if($._pendingAbortRequest._promise=z,!V)Q4($,Q);return z}function C6($){const Q=$._state;if(Q==="closed"||Q==="errored")return B(new TypeError(`The stream (in ${Q} state) is not in the writable state and cannot be closed`));const G=I((V,z)=>{const M={_resolve:V,_reject:z};$._closeRequest=M}),Y=$._writer;if(Y!==void 0&&$._backpressure&&Q==="writable")w4(Y);return QQ($._writableStreamController),G}function p8($){return I((G,Y)=>{const V={_resolve:G,_reject:Y};$._writeRequests.push(V)})}function $4($,Q){if($._state==="writable"){Q4($,Q);return}X4($)}function Q4($,Q){const G=$._writableStreamController;$._state="erroring",$._storedError=Q;const Y=$._writer;if(Y!==void 0)A6(Y,Q);if(!n8($)&&G._started)X4($)}function X4($){$._state="errored",$._writableStreamController[D1]();const Q=$._storedError;if($._writeRequests.forEach((V)=>{V._reject(Q)}),$._writeRequests=new j,$._pendingAbortRequest===void 0){Z$($);return}const G=$._pendingAbortRequest;if($._pendingAbortRequest=void 0,G._wasAlreadyErroring){G._reject(Q),Z$($);return}const Y=$._writableStreamController[p](G._reason);T(Y,()=>{return G._resolve(),Z$($),null},(V)=>{return G._reject(V),Z$($),null})}function c8($){$._inFlightWriteRequest._resolve(void 0),$._inFlightWriteRequest=void 0}function d8($,Q){$._inFlightWriteRequest._reject(Q),$._inFlightWriteRequest=void 0,$4($,Q)}function i8($){if($._inFlightCloseRequest._resolve(void 0),$._inFlightCloseRequest=void 0,$._state==="erroring"){if($._storedError=void 0,$._pendingAbortRequest!==void 0)$._pendingAbortRequest._resolve(),$._pendingAbortRequest=void 0}$._state="closed";const G=$._writer;if(G!==void 0)R6(G)}function l8($,Q){if($._inFlightCloseRequest._reject(Q),$._inFlightCloseRequest=void 0,$._pendingAbortRequest!==void 0)$._pendingAbortRequest._reject(Q),$._pendingAbortRequest=void 0;$4($,Q)}function H0($){if($._closeRequest===void 0&&$._inFlightCloseRequest===void 0)return!1;return!0}function n8($){if($._inFlightWriteRequest===void 0&&$._inFlightCloseRequest===void 0)return!1;return!0}function s8($){$._inFlightCloseRequest=$._closeRequest,$._closeRequest=void 0}function a8($){$._inFlightWriteRequest=$._writeRequests.shift()}function Z$($){if($._closeRequest!==void 0)$._closeRequest._reject($._storedError),$._closeRequest=void 0;const Q=$._writer;if(Q!==void 0)W4(Q,$._storedError)}function Z4($,Q){const G=$._writer;if(G!==void 0&&Q!==$._backpressure)if(Q)YQ(G);else w4(G);$._backpressure=Q}class M0{constructor($){if(P0($,1,"WritableStreamDefaultWriter"),B6($,"First parameter"),G1($))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=$,$._writer=this;const Q=$._state;if(Q==="writable"){if(!H0($)&&$._backpressure)Y$(this);else k6(this);W$(this)}else if(Q==="erroring")Y4(this,$._storedError),W$(this);else if(Q==="closed")k6(this),KQ(this);else{const G=$._storedError;Y4(this,G),T6(this,G)}}get closed(){if(!l0(this))return B(s0("closed"));return this._closedPromise}get desiredSize(){if(!l0(this))throw s0("desiredSize");if(this._ownerWritableStream===void 0)throw T1("desiredSize");return e8(this)}get ready(){if(!l0(this))return B(s0("ready"));return this._readyPromise}abort($=void 0){if(!l0(this))return B(s0("abort"));if(this._ownerWritableStream===void 0)return B(T1("abort"));return o8(this,$)}close(){if(!l0(this))return B(s0("close"));const $=this._ownerWritableStream;if($===void 0)return B(T1("close"));if(H0($))return B(new TypeError("Cannot close an already-closing stream"));return D6(this)}releaseLock(){if(!l0(this))throw s0("releaseLock");if(this._ownerWritableStream===void 0)return;x6(this)}write($=void 0){if(!l0(this))return B(s0("write"));if(this._ownerWritableStream===void 0)return B(T1("write to"));return E6(this,$)}}if(Object.defineProperties(M0.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),W(M0.prototype.abort,"abort"),W(M0.prototype.close,"close"),W(M0.prototype.releaseLock,"releaseLock"),W(M0.prototype.write,"write"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(M0.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});function l0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_ownerWritableStream"))return!1;return $ instanceof M0}function o8($,Q){const G=$._ownerWritableStream;return X$(G,Q)}function D6($){const Q=$._ownerWritableStream;return C6(Q)}function t8($){const Q=$._ownerWritableStream,G=Q._state;if(H0(Q)||G==="closed")return U(void 0);if(G==="errored")return B(Q._storedError);return D6($)}function r8($,Q){if($._closedPromiseState==="pending")W4($,Q);else WQ($,Q)}function A6($,Q){if($._readyPromiseState==="pending")_6($,Q);else wQ($,Q)}function e8($){const Q=$._ownerWritableStream,G=Q._state;if(G==="errored"||G==="erroring")return null;if(G==="closed")return 0;return q6(Q._writableStreamController)}function x6($){const Q=$._ownerWritableStream,G=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");A6($,G),r8($,G),Q._writer=void 0,$._ownerWritableStream=void 0}function E6($,Q){const G=$._ownerWritableStream,Y=G._writableStreamController,V=XQ(Y,Q);if(G!==$._ownerWritableStream)return B(T1("write to"));const z=G._state;if(z==="errored")return B(G._storedError);if(H0(G)||z==="closed")return B(new TypeError("The stream is closing or closed and cannot be written to"));if(z==="erroring")return B(G._storedError);const M=p8(G);return ZQ(Y,Q,V),M}const F6={};class n0{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!G4(this))throw K4("abortReason");return this._abortReason}get signal(){if(!G4(this))throw K4("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error($=void 0){if(!G4(this))throw K4("error");if(this._controlledWritableStream._state!=="writable")return;j6(this,$)}[p]($){const Q=this._abortAlgorithm($);return G$(this),Q}[D1](){L0(this)}}if(Object.defineProperties(n0.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(n0.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});function G4($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledWritableStream"))return!1;return $ instanceof n0}function N6($,Q,G,Y,V,z,M,C){Q._controlledWritableStream=$,$._writableStreamController=Q,Q._queue=void 0,Q._queueTotalSize=void 0,L0(Q),Q._abortReason=void 0,Q._abortController=m8(),Q._started=!1,Q._strategySizeAlgorithm=C,Q._strategyHWM=M,Q._writeAlgorithm=Y,Q._closeAlgorithm=V,Q._abortAlgorithm=z;const A=J4(Q);Z4($,A);const N=G(),q=U(N);T(q,()=>{return Q._started=!0,J$(Q),null},(R)=>{return Q._started=!0,$4($,R),null})}function $Q($,Q,G,Y){const V=Object.create(n0.prototype);let z,M,C,A;if(Q.start!==void 0)z=()=>Q.start(V);else z=()=>{return};if(Q.write!==void 0)M=(N)=>Q.write(N,V);else M=()=>U(void 0);if(Q.close!==void 0)C=()=>Q.close();else C=()=>U(void 0);if(Q.abort!==void 0)A=(N)=>Q.abort(N);else A=()=>U(void 0);N6($,V,z,M,C,A,G,Y)}function G$($){$._writeAlgorithm=void 0,$._closeAlgorithm=void 0,$._abortAlgorithm=void 0,$._strategySizeAlgorithm=void 0}function QQ($){l$($,F6,0),J$($)}function XQ($,Q){try{return $._strategySizeAlgorithm(Q)}catch(G){return j1($,G),1}}function q6($){return $._strategyHWM-$._queueTotalSize}function ZQ($,Q,G){try{l$($,Q,G)}catch(V){j1($,V);return}const Y=$._controlledWritableStream;if(!H0(Y)&&Y._state==="writable"){const V=J4($);Z4(Y,V)}J$($)}function J$($){const Q=$._controlledWritableStream;if(!$._started)return;if(Q._inFlightWriteRequest!==void 0)return;if(Q._state==="erroring"){X4(Q);return}if($._queue.length===0)return;const Y=I8($);if(Y===F6)GQ($);else JQ($,Y)}function j1($,Q){if($._controlledWritableStream._state==="writable")j6($,Q)}function GQ($){const Q=$._controlledWritableStream;s8(Q),i$($);const G=$._closeAlgorithm();G$($),T(G,()=>{return i8(Q),null},(Y)=>{return l8(Q,Y),null})}function JQ($,Q){const G=$._controlledWritableStream;a8(G);const Y=$._writeAlgorithm(Q);T(Y,()=>{c8(G);const V=G._state;if(i$($),!H0(G)&&V==="writable"){const z=J4($);Z4(G,z)}return J$($),null},(V)=>{if(G._state==="writable")G$($);return d8(G,V),null})}function J4($){return q6($)<=0}function j6($,Q){const G=$._controlledWritableStream;G$($),Q4(G,Q)}function K$($){return new TypeError(`WritableStream.prototype.${$} can only be used on a WritableStream`)}function K4($){return new TypeError(`WritableStreamDefaultController.prototype.${$} can only be used on a WritableStreamDefaultController`)}function s0($){return new TypeError(`WritableStreamDefaultWriter.prototype.${$} can only be used on a WritableStreamDefaultWriter`)}function T1($){return new TypeError("Cannot "+$+" a stream using a released writer")}function W$($){$._closedPromise=I((Q,G)=>{$._closedPromise_resolve=Q,$._closedPromise_reject=G,$._closedPromiseState="pending"})}function T6($,Q){W$($),W4($,Q)}function KQ($){W$($),R6($)}function W4($,Q){if($._closedPromise_reject===void 0)return;_($._closedPromise),$._closedPromise_reject(Q),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0,$._closedPromiseState="rejected"}function WQ($,Q){T6($,Q)}function R6($){if($._closedPromise_resolve===void 0)return;$._closedPromise_resolve(void 0),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0,$._closedPromiseState="resolved"}function Y$($){$._readyPromise=I((Q,G)=>{$._readyPromise_resolve=Q,$._readyPromise_reject=G}),$._readyPromiseState="pending"}function Y4($,Q){Y$($),_6($,Q)}function k6($){Y$($),w4($)}function _6($,Q){if($._readyPromise_reject===void 0)return;_($._readyPromise),$._readyPromise_reject(Q),$._readyPromise_resolve=void 0,$._readyPromise_reject=void 0,$._readyPromiseState="rejected"}function YQ($){Y$($)}function wQ($,Q){Y4($,Q)}function w4($){if($._readyPromise_resolve===void 0)return;$._readyPromise_resolve(void 0),$._readyPromise_resolve=void 0,$._readyPromise_reject=void 0,$._readyPromiseState="fulfilled"}function VQ(){if(typeof globalThis!=="undefined")return globalThis;else if(typeof self!=="undefined")return self;else if(typeof global!=="undefined")return global;return}const V4=VQ();function zQ($){if(!(typeof $==="function"||typeof $==="object"))return!1;if($.name!=="DOMException")return!1;try{return new $,!0}catch(Q){return!1}}function OQ(){const $=V4===null||V4===void 0?void 0:V4.DOMException;return zQ($)?$:void 0}function HQ(){const $=function Q(G,Y){if(this.message=G||"",this.name=Y||"Error",Error.captureStackTrace)Error.captureStackTrace(this,this.constructor)};return W($,"DOMException"),$.prototype=Object.create(Error.prototype),Object.defineProperty($.prototype,"constructor",{value:$,writable:!0,configurable:!0}),$}const MQ=OQ()||HQ();function L6($,Q,G,Y,V,z){const M=Q1($),C=I6(Q);$._disturbed=!0;let A=!1,N=U(void 0);return I((q,R)=>{let v;if(z!==void 0){if(v=()=>{const x=z.reason!==void 0?z.reason:new MQ("Aborted","AbortError"),k=[];if(!Y)k.push(()=>{if(Q._state==="writable")return X$(Q,x);return U(void 0)});if(!V)k.push(()=>{if($._state==="readable")return W0($,x);return U(void 0)});n(()=>Promise.all(k.map((h)=>h())),!0,x)},z.aborted){v();return}z.addEventListener("abort",v)}function F0(){return I((x,k)=>{function h(t){if(t)x();else L(Y1(),h,k)}h(!1)})}function Y1(){if(A)return U(!0);return L(C._readyPromise,()=>{return I((x,k)=>{x1(M,{_chunkSteps:(h)=>{N=L(E6(C,h),void 0,Z),x(!1)},_closeSteps:()=>x(!0),_errorSteps:k})})})}if(N0($,M._closedPromise,(x)=>{if(!Y)n(()=>X$(Q,x),!0,x);else Z0(!0,x);return null}),N0(Q,C._closedPromise,(x)=>{if(!V)n(()=>W0($,x),!0,x);else Z0(!0,x);return null}),i($,M._closedPromise,()=>{if(!G)n(()=>t8(C));else Z0();return null}),H0(Q)||Q._state==="closed"){const x=new TypeError("the destination writable stream closed before all data could be piped to it");if(!V)n(()=>W0($,x),!0,x);else Z0(!0,x)}_(F0());function h0(){const x=N;return L(N,()=>x!==N?h0():void 0)}function N0(x,k,h){if(x._state==="errored")h(x._storedError);else D(k,h)}function i(x,k,h){if(x._state==="closed")h();else E(k,h)}function n(x,k,h){if(A)return;if(A=!0,Q._state==="writable"&&!H0(Q))E(h0(),t);else t();function t(){return T(x(),()=>q0(k,h),(w1)=>q0(!0,w1)),null}}function Z0(x,k){if(A)return;if(A=!0,Q._state==="writable"&&!H0(Q))E(h0(),()=>q0(x,k));else q0(x,k)}function q0(x,k){if(x6(C),I0(M),z!==void 0)z.removeEventListener("abort",v);if(x)R(k);else q(void 0);return null}})}class U0{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!w$(this))throw z$("desiredSize");return z4(this)}close(){if(!w$(this))throw z$("close");if(!K1(this))throw new TypeError("The stream is not in a state that permits close");a0(this)}enqueue($=void 0){if(!w$(this))throw z$("enqueue");if(!K1(this))throw new TypeError("The stream is not in a state that permits enqueue");return J1(this,$)}error($=void 0){if(!w$(this))throw z$("error");K0(this,$)}[A1]($){L0(this);const Q=this._cancelAlgorithm($);return V$(this),Q}[k$]($){const Q=this._controlledReadableStream;if(this._queue.length>0){const G=i$(this);if(this._closeRequested&&this._queue.length===0)V$(this),_1(Q);else R1(this);$._chunkSteps(G)}else p4(Q,$),R1(this)}[_$](){}}if(Object.defineProperties(U0.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),W(U0.prototype.close,"close"),W(U0.prototype.enqueue,"enqueue"),W(U0.prototype.error,"error"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(U0.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});function w$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledReadableStream"))return!1;return $ instanceof U0}function R1($){if(!S6($))return;if($._pulling){$._pullAgain=!0;return}$._pulling=!0;const G=$._pullAlgorithm();T(G,()=>{if($._pulling=!1,$._pullAgain)$._pullAgain=!1,R1($);return null},(Y)=>{return K0($,Y),null})}function S6($){const Q=$._controlledReadableStream;if(!K1($))return!1;if(!$._started)return!1;if(f0(Q)&&i1(Q)>0)return!0;if(z4($)>0)return!0;return!1}function V$($){$._pullAlgorithm=void 0,$._cancelAlgorithm=void 0,$._strategySizeAlgorithm=void 0}function a0($){if(!K1($))return;const Q=$._controlledReadableStream;if($._closeRequested=!0,$._queue.length===0)V$($),_1(Q)}function J1($,Q){if(!K1($))return;const G=$._controlledReadableStream;if(f0(G)&&i1(G)>0)b$(G,Q,!1);else{let Y;try{Y=$._strategySizeAlgorithm(Q)}catch(V){throw K0($,V),V}try{l$($,Q,Y)}catch(V){throw K0($,V),V}}R1($)}function K0($,Q){const G=$._controlledReadableStream;if(G._state!=="readable")return;L0($),V$($),g6(G,Q)}function z4($){const Q=$._controlledReadableStream._state;if(Q==="errored")return null;if(Q==="closed")return 0;return $._strategyHWM-$._queueTotalSize}function UQ($){if(S6($))return!1;return!0}function K1($){const Q=$._controlledReadableStream._state;if(!$._closeRequested&&Q==="readable")return!0;return!1}function v6($,Q,G,Y,V,z,M){Q._controlledReadableStream=$,Q._queue=void 0,Q._queueTotalSize=void 0,L0(Q),Q._started=!1,Q._closeRequested=!1,Q._pullAgain=!1,Q._pulling=!1,Q._strategySizeAlgorithm=M,Q._strategyHWM=z,Q._pullAlgorithm=Y,Q._cancelAlgorithm=V,$._readableStreamController=Q;const C=G();T(U(C),()=>{return Q._started=!0,R1(Q),null},(A)=>{return K0(Q,A),null})}function BQ($,Q,G,Y){const V=Object.create(U0.prototype);let z,M,C;if(Q.start!==void 0)z=()=>Q.start(V);else z=()=>{return};if(Q.pull!==void 0)M=()=>Q.pull(V);else M=()=>U(void 0);if(Q.cancel!==void 0)C=(A)=>Q.cancel(A);else C=()=>U(void 0);v6($,V,z,M,C,G,Y)}function z$($){return new TypeError(`ReadableStreamDefaultController.prototype.${$} can only be used on a ReadableStreamDefaultController`)}function IQ($,Q){if(c0($._readableStreamController))return CQ($);return PQ($)}function PQ($,Q){const G=Q1($);let Y=!1,V=!1,z=!1,M=!1,C,A,N,q,R;const v=I((i)=>{R=i});function F0(){if(Y)return V=!0,U(void 0);return Y=!0,x1(G,{_chunkSteps:(n)=>{F(()=>{V=!1;const Z0=n,q0=n;if(!z)J1(N._readableStreamController,Z0);if(!M)J1(q._readableStreamController,q0);if(Y=!1,V)F0()})},_closeSteps:()=>{if(Y=!1,!z)a0(N._readableStreamController);if(!M)a0(q._readableStreamController);if(!z||!M)R(void 0)},_errorSteps:()=>{Y=!1}}),U(void 0)}function Y1(i){if(z=!0,C=i,M){const n=E1([C,A]),Z0=W0($,n);R(Z0)}return v}function h0(i){if(M=!0,A=i,z){const n=E1([C,A]),Z0=W0($,n);R(Z0)}return v}function N0(){}return N=k1(N0,F0,Y1),q=k1(N0,F0,h0),D(G._closedPromise,(i)=>{if(K0(N._readableStreamController,i),K0(q._readableStreamController,i),!z||!M)R(void 0);return null}),[N,q]}function CQ($){let Q=Q1($),G=!1,Y=!1,V=!1,z=!1,M=!1,C,A,N,q,R;const v=I((x)=>{R=x});function F0(x){D(x._closedPromise,(k)=>{if(x!==Q)return null;if(X0(N._readableStreamController,k),X0(q._readableStreamController,k),!z||!M)R(void 0);return null})}function Y1(){if(i0(Q))I0(Q),Q=Q1($),F0(Q);x1(Q,{_chunkSteps:(k)=>{F(()=>{Y=!1,V=!1;const h=k;let t=k;if(!z&&!M)try{t=r4(k)}catch(w1){X0(N._readableStreamController,w1),X0(q._readableStreamController,w1),R(W0($,w1));return}if(!z)o1(N._readableStreamController,h);if(!M)o1(q._readableStreamController,t);if(G=!1,Y)N0();else if(V)i()})},_closeSteps:()=>{if(G=!1,!z)F1(N._readableStreamController);if(!M)F1(q._readableStreamController);if(N._readableStreamController._pendingPullIntos.length>0)t1(N._readableStreamController,0);if(q._readableStreamController._pendingPullIntos.length>0)t1(q._readableStreamController,0);if(!z||!M)R(void 0)},_errorSteps:()=>{G=!1}})}function h0(x,k){if(k0(Q))I0(Q),Q=z6($),F0(Q);const h=k?q:N,t=k?N:q;M6(Q,x,1,{_chunkSteps:(V1)=>{F(()=>{Y=!1,V=!1;const z1=k?M:z;if(!(k?z:M)){let o6;try{o6=r4(V1)}catch(B4){X0(h._readableStreamController,B4),X0(t._readableStreamController,B4),R(W0($,B4));return}if(!z1)r1(h._readableStreamController,V1);o1(t._readableStreamController,o6)}else if(!z1)r1(h._readableStreamController,V1);if(G=!1,Y)N0();else if(V)i()})},_closeSteps:(V1)=>{G=!1;const z1=k?M:z,B$=k?z:M;if(!z1)F1(h._readableStreamController);if(!B$)F1(t._readableStreamController);if(V1!==void 0){if(!z1)r1(h._readableStreamController,V1);if(!B$&&t._readableStreamController._pendingPullIntos.length>0)t1(t._readableStreamController,0)}if(!z1||!B$)R(void 0)},_errorSteps:()=>{G=!1}})}function N0(){if(G)return Y=!0,U(void 0);G=!0;const x=t$(N._readableStreamController);if(x===null)Y1();else h0(x._view,!1);return U(void 0)}function i(){if(G)return V=!0,U(void 0);G=!0;const x=t$(q._readableStreamController);if(x===null)Y1();else h0(x._view,!0);return U(void 0)}function n(x){if(z=!0,C=x,M){const k=E1([C,A]),h=W0($,k);R(h)}return v}function Z0(x){if(M=!0,A=x,z){const k=E1([C,A]),h=W0($,k);R(h)}return v}function q0(){return}return N=h6(q0,N0,n),q=h6(q0,i,Z0),F0(Q),[N,q]}function DQ($){return J($)&&typeof $.getReader!=="undefined"}function AQ($){if(DQ($))return EQ($.getReader());return xQ($)}function xQ($){let Q;const G=t4($,"async"),Y=Z;function V(){let M;try{M=H8(G)}catch(A){return B(A)}const C=U(M);return S(C,(A)=>{if(!J(A))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(M8(A))a0(Q._readableStreamController);else{const q=U8(A);J1(Q._readableStreamController,q)}})}function z(M){const C=G.iterator;let A;try{A=n1(C,"return")}catch(R){return B(R)}if(A===void 0)return U(void 0);let N;try{N=P(A,C,[M])}catch(R){return B(R)}const q=U(N);return S(q,(R)=>{if(!J(R))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");return})}return Q=k1(Y,V,z,0),Q}function EQ($){let Q;const G=Z;function Y(){let z;try{z=$.read()}catch(M){return B(M)}return S(z,(M)=>{if(!J(M))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(M.done)a0(Q._readableStreamController);else{const C=M.value;J1(Q._readableStreamController,C)}})}function V(z){try{return U($.cancel(z))}catch(M){return B(M)}}return Q=k1(G,Y,V,0),Q}function FQ($,Q){z0($,Q);const G=$,Y=G===null||G===void 0?void 0:G.autoAllocateChunkSize,V=G===null||G===void 0?void 0:G.cancel,z=G===null||G===void 0?void 0:G.pull,M=G===null||G===void 0?void 0:G.start,C=G===null||G===void 0?void 0:G.type;return{autoAllocateChunkSize:Y===void 0?void 0:g$(Y,`${Q} has member 'autoAllocateChunkSize' that`),cancel:V===void 0?void 0:NQ(V,G,`${Q} has member 'cancel' that`),pull:z===void 0?void 0:qQ(z,G,`${Q} has member 'pull' that`),start:M===void 0?void 0:jQ(M,G,`${Q} has member 'start' that`),type:C===void 0?void 0:TQ(C,`${Q} has member 'type' that`)}}function NQ($,Q,G){return Q0($,G),(Y)=>y($,Q,[Y])}function qQ($,Q,G){return Q0($,G),(Y)=>y($,Q,[Y])}function jQ($,Q,G){return Q0($,G),(Y)=>P($,Q,[Y])}function TQ($,Q){if($=`${$}`,$!=="bytes")throw new TypeError(`${Q} '${$}' is not a valid enumeration value for ReadableStreamType`);return $}function RQ($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.preventCancel;return{preventCancel:Boolean(G)}}function f6($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.preventAbort,Y=$===null||$===void 0?void 0:$.preventCancel,V=$===null||$===void 0?void 0:$.preventClose,z=$===null||$===void 0?void 0:$.signal;if(z!==void 0)kQ(z,`${Q} has member 'signal' that`);return{preventAbort:Boolean(G),preventCancel:Boolean(Y),preventClose:Boolean(V),signal:z}}function kQ($,Q){if(!y8($))throw new TypeError(`${Q} is not an AbortSignal.`)}function _Q($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.readable;f$(G,"readable","ReadableWritablePair"),y$(G,`${Q} has member 'readable' that`);const Y=$===null||$===void 0?void 0:$.writable;return f$(Y,"writable","ReadableWritablePair"),B6(Y,`${Q} has member 'writable' that`),{readable:G,writable:Y}}class d{constructor($={},Q={}){if($===void 0)$=null;else m4($,"First parameter");const G=Q$(Q,"Second parameter"),Y=FQ($,"First parameter");if(O4(this),Y.type==="bytes"){if(G.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");const V=q1(G,0);N8(this,Y,V)}else{const V=$$(G),z=q1(G,1);BQ(this,Y,z,V)}}get locked(){if(!v0(this))throw o0("locked");return f0(this)}cancel($=void 0){if(!v0(this))return B(o0("cancel"));if(f0(this))return B(new TypeError("Cannot cancel a stream that already has a reader"));return W0(this,$)}getReader($=void 0){if(!v0(this))throw o0("getReader");if(j8($,"First parameter").mode===void 0)return Q1(this);return z6(this)}pipeThrough($,Q={}){if(!v0(this))throw o0("pipeThrough");P0($,1,"pipeThrough");const G=_Q($,"First parameter"),Y=f6(Q,"Second parameter");if(f0(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(G1(G.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");const V=L6(this,G.writable,Y.preventClose,Y.preventAbort,Y.preventCancel,Y.signal);return _(V),G.readable}pipeTo($,Q={}){if(!v0(this))return B(o0("pipeTo"));if($===void 0)return B("Parameter 1 is required in 'pipeTo'.");if(!Z1($))return B(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let G;try{G=f6(Q,"Second parameter")}catch(Y){return B(Y)}if(f0(this))return B(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(G1($))return B(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));return L6(this,$,G.preventClose,G.preventAbort,G.preventCancel,G.signal)}tee(){if(!v0(this))throw o0("tee");const $=IQ(this);return E1($)}values($=void 0){if(!v0(this))throw o0("values");const Q=RQ($,"First parameter");return z8(this,Q.preventCancel)}[d$]($){return this.values($)}static from($){return AQ($)}}if(Object.defineProperties(d,{from:{enumerable:!0}}),Object.defineProperties(d.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),W(d.from,"from"),W(d.prototype.cancel,"cancel"),W(d.prototype.getReader,"getReader"),W(d.prototype.pipeThrough,"pipeThrough"),W(d.prototype.pipeTo,"pipeTo"),W(d.prototype.tee,"tee"),W(d.prototype.values,"values"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(d.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0});Object.defineProperty(d.prototype,d$,{value:d.prototype.values,writable:!0,configurable:!0});function k1($,Q,G,Y=1,V=()=>1){const z=Object.create(d.prototype);O4(z);const M=Object.create(U0.prototype);return v6(z,M,$,Q,G,Y,V),z}function h6($,Q,G){const Y=Object.create(d.prototype);O4(Y);const V=Object.create(O0.prototype);return V6(Y,V,$,Q,G,0,void 0),Y}function O4($){$._state="readable",$._reader=void 0,$._storedError=void 0,$._disturbed=!1}function v0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readableStreamController"))return!1;return $ instanceof d}function f0($){if($._reader===void 0)return!1;return!0}function W0($,Q){if($._disturbed=!0,$._state==="closed")return U(void 0);if($._state==="errored")return B($._storedError);_1($);const G=$._reader;if(G!==void 0&&i0(G)){const V=G._readIntoRequests;G._readIntoRequests=new j,V.forEach((z)=>{z._closeSteps(void 0)})}const Y=$._readableStreamController[A1](Q);return S(Y,Z)}function _1($){$._state="closed";const Q=$._reader;if(Q===void 0)return;if(y4(Q),k0(Q)){const G=Q._readRequests;Q._readRequests=new j,G.forEach((Y)=>{Y._closeSteps()})}}function g6($,Q){$._state="errored",$._storedError=Q;const G=$._reader;if(G===void 0)return;if(v$(G,Q),k0(G))d4(G,Q);else U6(G,Q)}function o0($){return new TypeError(`ReadableStream.prototype.${$} can only be used on a ReadableStream`)}function y6($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.highWaterMark;return f$(G,"highWaterMark","QueuingStrategyInit"),{highWaterMark:h$(G)}}const b6=($)=>{return $.byteLength};W(b6,"size");class L1{constructor($){P0($,1,"ByteLengthQueuingStrategy"),$=y6($,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=$.highWaterMark}get highWaterMark(){if(!u6(this))throw m6("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!u6(this))throw m6("size");return b6}}if(Object.defineProperties(L1.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(L1.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});function m6($){return new TypeError(`ByteLengthQueuingStrategy.prototype.${$} can only be used on a ByteLengthQueuingStrategy`)}function u6($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_byteLengthQueuingStrategyHighWaterMark"))return!1;return $ instanceof L1}const p6=()=>{return 1};W(p6,"size");class S1{constructor($){P0($,1,"CountQueuingStrategy"),$=y6($,"First parameter"),this._countQueuingStrategyHighWaterMark=$.highWaterMark}get highWaterMark(){if(!d6(this))throw c6("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!d6(this))throw c6("size");return p6}}if(Object.defineProperties(S1.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(S1.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:!0});function c6($){return new TypeError(`CountQueuingStrategy.prototype.${$} can only be used on a CountQueuingStrategy`)}function d6($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_countQueuingStrategyHighWaterMark"))return!1;return $ instanceof S1}function LQ($,Q){z0($,Q);const G=$===null||$===void 0?void 0:$.cancel,Y=$===null||$===void 0?void 0:$.flush,V=$===null||$===void 0?void 0:$.readableType,z=$===null||$===void 0?void 0:$.start,M=$===null||$===void 0?void 0:$.transform,C=$===null||$===void 0?void 0:$.writableType;return{cancel:G===void 0?void 0:hQ(G,$,`${Q} has member 'cancel' that`),flush:Y===void 0?void 0:SQ(Y,$,`${Q} has member 'flush' that`),readableType:V,start:z===void 0?void 0:vQ(z,$,`${Q} has member 'start' that`),transform:M===void 0?void 0:fQ(M,$,`${Q} has member 'transform' that`),writableType:C}}function SQ($,Q,G){return Q0($,G),(Y)=>y($,Q,[Y])}function vQ($,Q,G){return Q0($,G),(Y)=>P($,Q,[Y])}function fQ($,Q,G){return Q0($,G),(Y,V)=>y($,Q,[Y,V])}function hQ($,Q,G){return Q0($,G),(Y)=>y($,Q,[Y])}class v1{constructor($={},Q={},G={}){if($===void 0)$=null;const Y=Q$(Q,"Second parameter"),V=Q$(G,"Third parameter"),z=LQ($,"First parameter");if(z.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(z.writableType!==void 0)throw new RangeError("Invalid writableType specified");const M=q1(V,0),C=$$(V),A=q1(Y,1),N=$$(Y);let q;const R=I((v)=>{q=v});if(gQ(this,R,A,N,M,C),bQ(this,z),z.start!==void 0)q(z.start(this._transformStreamController));else q(void 0)}get readable(){if(!i6(this))throw a6("readable");return this._readable}get writable(){if(!i6(this))throw a6("writable");return this._writable}}if(Object.defineProperties(v1.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(v1.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:!0});function gQ($,Q,G,Y,V,z){function M(){return Q}function C(v){return pQ($,v)}function A(v){return cQ($,v)}function N(){return dQ($)}$._writable=u8(M,C,N,A,G,Y);function q(){return iQ($)}function R(v){return lQ($,v)}$._readable=k1(M,q,R,V,z),$._backpressure=void 0,$._backpressureChangePromise=void 0,$._backpressureChangePromise_resolve=void 0,O$($,!0),$._transformStreamController=void 0}function i6($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_transformStreamController"))return!1;return $ instanceof v1}function l6($,Q){K0($._readable._readableStreamController,Q),H4($,Q)}function H4($,Q){M$($._transformStreamController),j1($._writable._writableStreamController,Q),M4($)}function M4($){if($._backpressure)O$($,!1)}function O$($,Q){if($._backpressureChangePromise!==void 0)$._backpressureChangePromise_resolve();$._backpressureChangePromise=I((G)=>{$._backpressureChangePromise_resolve=G}),$._backpressure=Q}class E0{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!H$(this))throw U$("desiredSize");const $=this._controlledTransformStream._readable._readableStreamController;return z4($)}enqueue($=void 0){if(!H$(this))throw U$("enqueue");n6(this,$)}error($=void 0){if(!H$(this))throw U$("error");mQ(this,$)}terminate(){if(!H$(this))throw U$("terminate");uQ(this)}}if(Object.defineProperties(E0.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),W(E0.prototype.enqueue,"enqueue"),W(E0.prototype.error,"error"),W(E0.prototype.terminate,"terminate"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(E0.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});function H$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledTransformStream"))return!1;return $ instanceof E0}function yQ($,Q,G,Y,V){Q._controlledTransformStream=$,$._transformStreamController=Q,Q._transformAlgorithm=G,Q._flushAlgorithm=Y,Q._cancelAlgorithm=V,Q._finishPromise=void 0,Q._finishPromise_resolve=void 0,Q._finishPromise_reject=void 0}function bQ($,Q){const G=Object.create(E0.prototype);let Y,V,z;if(Q.transform!==void 0)Y=(M)=>Q.transform(M,G);else Y=(M)=>{try{return n6(G,M),U(void 0)}catch(C){return B(C)}};if(Q.flush!==void 0)V=()=>Q.flush(G);else V=()=>U(void 0);if(Q.cancel!==void 0)z=(M)=>Q.cancel(M);else z=()=>U(void 0);yQ($,G,Y,V,z)}function M$($){$._transformAlgorithm=void 0,$._flushAlgorithm=void 0,$._cancelAlgorithm=void 0}function n6($,Q){const G=$._controlledTransformStream,Y=G._readable._readableStreamController;if(!K1(Y))throw new TypeError("Readable side is not in a state that permits enqueue");try{J1(Y,Q)}catch(z){throw H4(G,z),G._readable._storedError}if(UQ(Y)!==G._backpressure)O$(G,!0)}function mQ($,Q){l6($._controlledTransformStream,Q)}function s6($,Q){const G=$._transformAlgorithm(Q);return S(G,void 0,(Y)=>{throw l6($._controlledTransformStream,Y),Y})}function uQ($){const Q=$._controlledTransformStream,G=Q._readable._readableStreamController;a0(G);const Y=new TypeError("TransformStream terminated");H4(Q,Y)}function pQ($,Q){const G=$._transformStreamController;if($._backpressure){const Y=$._backpressureChangePromise;return S(Y,()=>{const V=$._writable;if(V._state==="erroring")throw V._storedError;return s6(G,Q)})}return s6(G,Q)}function cQ($,Q){const G=$._transformStreamController;if(G._finishPromise!==void 0)return G._finishPromise;const Y=$._readable;G._finishPromise=I((z,M)=>{G._finishPromise_resolve=z,G._finishPromise_reject=M});const V=G._cancelAlgorithm(Q);return M$(G),T(V,()=>{if(Y._state==="errored")W1(G,Y._storedError);else K0(Y._readableStreamController,Q),U4(G);return null},(z)=>{return K0(Y._readableStreamController,z),W1(G,z),null}),G._finishPromise}function dQ($){const Q=$._transformStreamController;if(Q._finishPromise!==void 0)return Q._finishPromise;const G=$._readable;Q._finishPromise=I((V,z)=>{Q._finishPromise_resolve=V,Q._finishPromise_reject=z});const Y=Q._flushAlgorithm();return M$(Q),T(Y,()=>{if(G._state==="errored")W1(Q,G._storedError);else a0(G._readableStreamController),U4(Q);return null},(V)=>{return K0(G._readableStreamController,V),W1(Q,V),null}),Q._finishPromise}function iQ($){return O$($,!1),$._backpressureChangePromise}function lQ($,Q){const G=$._transformStreamController;if(G._finishPromise!==void 0)return G._finishPromise;const Y=$._writable;G._finishPromise=I((z,M)=>{G._finishPromise_resolve=z,G._finishPromise_reject=M});const V=G._cancelAlgorithm(Q);return M$(G),T(V,()=>{if(Y._state==="errored")W1(G,Y._storedError);else j1(Y._writableStreamController,Q),M4($),U4(G);return null},(z)=>{return j1(Y._writableStreamController,z),M4($),W1(G,z),null}),G._finishPromise}function U$($){return new TypeError(`TransformStreamDefaultController.prototype.${$} can only be used on a TransformStreamDefaultController`)}function U4($){if($._finishPromise_resolve===void 0)return;$._finishPromise_resolve(),$._finishPromise_resolve=void 0,$._finishPromise_reject=void 0}function W1($,Q){if($._finishPromise_reject===void 0)return;_($._finishPromise),$._finishPromise_reject(Q),$._finishPromise_resolve=void 0,$._finishPromise_reject=void 0}function a6($){return new TypeError(`TransformStream.prototype.${$} can only be used on a TransformStream`)}X.ByteLengthQueuingStrategy=L1,X.CountQueuingStrategy=S1,X.ReadableByteStreamController=O0,X.ReadableStream=d,X.ReadableStreamBYOBReader=A0,X.ReadableStreamBYOBRequest=S0,X.ReadableStreamDefaultController=U0,X.ReadableStreamDefaultReader=C0,X.TransformStream=v1,X.TransformStreamDefaultController=E0,X.WritableStream=x0,X.WritableStreamDefaultController=n0,X.WritableStreamDefaultWriter=M0})});var H5=g0(()=>{if(!globalThis.ReadableStream)try{const X=y0("node:process"),{emitWarning:Z}=X;try{X.emitWarning=()=>{},Object.assign(globalThis,y0("node:stream/web")),X.emitWarning=Z}catch(J){throw X.emitWarning=Z,J}}catch(X){Object.assign(globalThis,O5())}try{const{Blob:X}=y0("buffer");if(X&&!X.prototype.stream)X.prototype.stream=function Z(J){let K=0;const W=this;return new ReadableStream({type:"bytes",async pull(w){const H=await W.slice(K,Math.min(W.size,K+65536)).arrayBuffer();if(K+=H.byteLength,w.enqueue(new Uint8Array(H)),K===W.size)w.close()}})}}catch(X){}});async function*E4(X,Z=!0){for(let J of X)if("stream"in J)yield*J.stream();else if(ArrayBuffer.isView(J))if(Z){let K=J.byteOffset;const W=J.byteOffset+J.byteLength;while(K!==W){const w=Math.min(W-K,M5),O=J.buffer.slice(K,K+w);K+=O.byteLength,yield new Uint8Array(O)}}else yield J;else{let K=0,W=J;while(K!==W.size){const O=await W.slice(K,Math.min(W.size,K+M5)).arrayBuffer();K+=O.byteLength,yield new Uint8Array(O)}}}var yZ,M5,U5,AX,j0;var y1=f1(()=>{yZ=P4(H5(),1);/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */M5=65536,U5=class X{#$=[];#Q="";#X=0;#Z="transparent";constructor(Z=[],J={}){if(typeof Z!=="object"||Z===null)throw new TypeError("Failed to construct \'Blob\': The provided value cannot be converted to a sequence.");if(typeof Z[Symbol.iterator]!=="function")throw new TypeError("Failed to construct \'Blob\': The object must have a callable @@iterator property.");if(typeof J!=="object"&&typeof J!=="function")throw new TypeError("Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.");if(J===null)J={};const K=new TextEncoder;for(let w of Z){let O;if(ArrayBuffer.isView(w))O=new Uint8Array(w.buffer.slice(w.byteOffset,w.byteOffset+w.byteLength));else if(w instanceof ArrayBuffer)O=new Uint8Array(w.slice(0));else if(w instanceof X)O=w;else O=K.encode(`${w}`);this.#X+=ArrayBuffer.isView(O)?O.byteLength:O.size,this.#$.push(O)}this.#Z=`${J.endings===void 0?"transparent":J.endings}`;const W=J.type===void 0?"":String(J.type);this.#Q=/^[\x20-\x7E]*$/.test(W)?W:""}get size(){return this.#X}get type(){return this.#Q}async text(){const Z=new TextDecoder;let J="";for await(let K of E4(this.#$,!1))J+=Z.decode(K,{stream:!0});return J+=Z.decode(),J}async arrayBuffer(){const Z=new Uint8Array(this.size);let J=0;for await(let K of E4(this.#$,!1))Z.set(K,J),J+=K.length;return Z.buffer}stream(){const Z=E4(this.#$,!0);return new globalThis.ReadableStream({type:"bytes",async pull(J){const K=await Z.next();K.done?J.close():J.enqueue(K.value)},async cancel(){await Z.return()}})}slice(Z=0,J=this.size,K=""){const{size:W}=this;let w=Z<0?Math.max(W+Z,0):Math.min(Z,W),O=J<0?Math.max(W+J,0):Math.min(J,W);const H=Math.max(O-w,0),I=this.#$,U=[];let B=0;for(let T of I){if(B>=H)break;const E=ArrayBuffer.isView(T)?T.byteLength:T.size;if(w&&E<=w)w-=E,O-=E;else{let D;if(ArrayBuffer.isView(T))D=T.subarray(w,Math.min(E,O)),B+=D.byteLength;else D=T.slice(w,Math.min(E,O)),B+=D.size;O-=E,U.push(D),w=0}}const L=new X([],{type:String(K).toLowerCase()});return L.#X=H,L.#$=U,L}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](Z){return Z&&typeof Z==="object"&&typeof Z.constructor==="function"&&(typeof Z.stream==="function"||typeof Z.arrayBuffer==="function")&&/^(Blob|File)$/.test(Z[Symbol.toStringTag])}};Object.defineProperties(U5.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}});AX=U5,j0=AX});var xX,EX,M1;var F4=f1(()=>{y1();xX=class X extends j0{#$=0;#Q="";constructor(Z,J,K={}){if(arguments.length<2)throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);super(Z,K);if(K===null)K={};const W=K.lastModified===void 0?Date.now():Number(K.lastModified);if(!Number.isNaN(W))this.#$=W;this.#Q=String(J)}get name(){return this.#Q}get lastModified(){return this.#$}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](Z){return!!Z&&Z instanceof j0&&/^(File)$/.test(Z[Symbol.toStringTag])}},EX=xX,M1=EX});function P5(X,Z=j0){var J=`${B5()}${B5()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),K=[],W=`--${J}\r\nContent-Disposition: form-data; name="`;return X.forEach((w,O)=>typeof w=="string"?K.push(W+N4(O)+`"\r\n\r\n${w.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r\n`):K.push(W+N4(O)+`"; filename="${N4(w.name,1)}"\r\nContent-Type: ${w.type||"application/octet-stream"}\r\n\r\n`,w,"\r\n")),K.push(`--${J}--`),new Z(K,{type:"multipart/form-data; boundary="+J})}var b1,FX,NX,B5,qX,I5,N4,t0,r0;var D$=f1(()=>{y1();F4();/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */({toStringTag:b1,iterator:FX,hasInstance:NX}=Symbol),B5=Math.random,qX="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),I5=(X,Z,J)=>(X+="",/^(Blob|File)$/.test(Z&&Z[b1])?[(J=J!==void 0?J+"":Z[b1]=="File"?Z.name:"blob",X),Z.name!==J||Z[b1]=="blob"?new M1([Z],J,Z):Z]:[X,Z+""]),N4=(X,Z)=>(Z?X:X.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),t0=(X,Z,J)=>{if(Z.length<J)throw new TypeError(`Failed to execute '${X}' on 'FormData': ${J} arguments required, but only ${Z.length} present.`)},r0=class X{#$=[];constructor(...Z){if(Z.length)throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.")}get[b1](){return"FormData"}[FX](){return this.entries()}static[NX](Z){return Z&&typeof Z==="object"&&Z[b1]==="FormData"&&!qX.some((J)=>typeof Z[J]!="function")}append(...Z){t0("append",arguments,2),this.#$.push(I5(...Z))}delete(Z){t0("delete",arguments,1),Z+="",this.#$=this.#$.filter(([J])=>J!==Z)}get(Z){t0("get",arguments,1),Z+="";for(var J=this.#$,K=J.length,W=0;W<K;W++)if(J[W][0]===Z)return J[W][1];return null}getAll(Z,J){return t0("getAll",arguments,1),J=[],Z+="",this.#$.forEach((K)=>K[0]===Z&&J.push(K[1])),J}has(Z){return t0("has",arguments,1),Z+="",this.#$.some((J)=>J[0]===Z)}forEach(Z,J){t0("forEach",arguments,1);for(var[K,W]of this)Z.call(J,W,K,this)}set(...Z){t0("set",arguments,2);var J=[],K=!0;Z=I5(...Z),this.#$.forEach((W)=>{W[0]===Z[0]?K&&(K=!J.push(Z)):J.push(W)}),K&&J.push(Z),this.#$=J}*entries(){yield*this.#$}*keys(){for(var[Z]of this)yield Z}*values(){for(var[,Z]of this)yield Z}}});var E5=g0((aZ,x5)=>{/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */if(!globalThis.DOMException)try{const{MessageChannel:X}=y0("worker_threads"),Z=new X().port1,J=new ArrayBuffer;Z.postMessage(J,[J,J])}catch(X){X.constructor.name==="DOMException"&&(globalThis.DOMException=X.constructor)}x5.exports=globalThis.DOMException});import{statSync as tZ,createReadStream as jX,promises as TX} from"node:fs";class N5{#$;#Q;constructor(X){this.#$=X.path,this.#Q=X.start,this.size=X.size,this.lastModified=X.lastModified}slice(X,Z){return new N5({path:this.#$,lastModified:this.lastModified,size:Z-X,start:this.#Q+X})}async*stream(){const{mtimeMs:X}=await RX(this.#$);if(X>this.lastModified)throw new F5.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError");yield*jX(this.#$,{start:this.#Q,end:this.#Q+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}var F5,RX;var j4=f1(()=>{F5=P4(E5(),1);F4();y1();({stat:RX}=TX)});var T5={};tQ(T5,{toFormData:()=>{{return hX}}});async function hX(X,Z){if(!/multipart/i.test(Z))throw new TypeError("Failed to fetch");const J=Z.match(/boundary=(?:"([^"]+)"|([^;]+))/i);if(!J)throw new TypeError("no or bad content-type header, no multipart boundary");const K=new j5(J[1]||J[2]);let W,w,O,H,I,U;const B=[],L=new r0,T=(F)=>{O+=_.decode(F,{stream:!0})},E=(F)=>{B.push(F)},D=()=>{const F=new M1(B,U,{type:I});L.append(H,F)},S=()=>{L.append(H,O)},_=new TextDecoder("utf-8");_.decode(),K.onPartBegin=function(){K.onPartData=T,K.onPartEnd=S,W="",w="",O="",H="",I="",U=null,B.length=0},K.onHeaderField=function(F){W+=_.decode(F,{stream:!0})},K.onHeaderValue=function(F){w+=_.decode(F,{stream:!0})},K.onHeaderEnd=function(){if(w+=_.decode(),W=W.toLowerCase(),W==="content-disposition"){const F=w.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);if(F)H=F[2]||F[3]||"";if(U=fX(w),U)K.onPartData=E,K.onPartEnd=D}else if(W==="content-type")I=w;w="",W=""};for await(let F of X)K.write(F);return K.end(),L}class j5{constructor(X){this.index=0,this.flags=0,this.onHeaderEnd=e0,this.onHeaderField=e0,this.onHeadersEnd=e0,this.onHeaderValue=e0,this.onPartBegin=e0,this.onPartData=e0,this.onPartEnd=e0,this.boundaryChars={},X="\r\n--"+X;const Z=new Uint8Array(X.length);for(let J=0;J<X.length;J++)Z[J]=X.charCodeAt(J),this.boundaryChars[Z[J]]=!0;this.boundary=Z,this.lookbehind=new Uint8Array(this.boundary.length+8),this.state=g.START_BOUNDARY}write(X){let Z=0;const J=X.length;let K=this.index,{lookbehind:W,boundary:w,boundaryChars:O,index:H,state:I,flags:U}=this;const B=this.boundary.length,L=B-1,T=X.length;let E,D;const S=(y)=>{this[y+"Mark"]=Z},_=(y)=>{delete this[y+"Mark"]},F=(y,f,j,p)=>{if(f===void 0||f!==j)this[y](p&&p.subarray(f,j))},P=(y,f)=>{const j=y+"Mark";if(!(j in this))return;if(f)F(y,this[j],Z,X),delete this[j];else F(y,this[j],X.length,X),this[j]=0};for(Z=0;Z<J;Z++)switch(E=X[Z],I){case g.START_BOUNDARY:if(H===w.length-2){if(E===u1)U|=u0.LAST_BOUNDARY;else if(E!==E$)return;H++;break}else if(H-1===w.length-2){if(U&u0.LAST_BOUNDARY&&E===u1)I=g.END,U=0;else if(!(U&u0.LAST_BOUNDARY)&&E===x$)H=0,F("onPartBegin"),I=g.HEADER_FIELD_START;else return;break}if(E!==w[H+2])H=-2;if(E===w[H+2])H++;break;case g.HEADER_FIELD_START:I=g.HEADER_FIELD,S("onHeaderField"),H=0;case g.HEADER_FIELD:if(E===E$){_("onHeaderField"),I=g.HEADERS_ALMOST_DONE;break}if(H++,E===u1)break;if(E===_X){if(H===1)return;P("onHeaderField",!0),I=g.HEADER_VALUE_START;break}if(D=vX(E),D<LX||D>SX)return;break;case g.HEADER_VALUE_START:if(E===kX)break;S("onHeaderValue"),I=g.HEADER_VALUE;case g.HEADER_VALUE:if(E===E$)P("onHeaderValue",!0),F("onHeaderEnd"),I=g.HEADER_VALUE_ALMOST_DONE;break;case g.HEADER_VALUE_ALMOST_DONE:if(E!==x$)return;I=g.HEADER_FIELD_START;break;case g.HEADERS_ALMOST_DONE:if(E!==x$)return;F("onHeadersEnd"),I=g.PART_DATA_START;break;case g.PART_DATA_START:I=g.PART_DATA,S("onPartData");case g.PART_DATA:if(K=H,H===0){Z+=L;while(Z<T&&!(X[Z]in O))Z+=B;Z-=L,E=X[Z]}if(H<w.length)if(w[H]===E){if(H===0)P("onPartData",!0);H++}else H=0;else if(H===w.length)if(H++,E===E$)U|=u0.PART_BOUNDARY;else if(E===u1)U|=u0.LAST_BOUNDARY;else H=0;else if(H-1===w.length)if(U&u0.PART_BOUNDARY){if(H=0,E===x$){U&=~u0.PART_BOUNDARY,F("onPartEnd"),F("onPartBegin"),I=g.HEADER_FIELD_START;break}}else if(U&u0.LAST_BOUNDARY)if(E===u1)F("onPartEnd"),I=g.END,U=0;else H=0;else H=0;if(H>0)W[H-1]=E;else if(K>0){const y=new Uint8Array(W.buffer,W.byteOffset,W.byteLength);F("onPartData",0,K,y),K=0,S("onPartData"),Z--}break;case g.END:break;default:throw new Error(`Unexpected state entered: ${I}`)}P("onHeaderField"),P("onHeaderValue"),P("onPartData"),this.index=H,this.state=I,this.flags=U}end(){if(this.state===g.HEADER_FIELD_START&&this.index===0||this.state===g.PART_DATA&&this.index===this.boundary.length)this.onPartEnd();else if(this.state!==g.END)throw new Error("MultipartParser.end(): stream ended unexpectedly")}}var fX,B0,g,q5,u0,x$,E$,kX,u1,_X,LX,SX,vX,e0;var R5=f1(()=>{j4();D$();fX=function(X){const Z=X.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);if(!Z)return;const J=Z[2]||Z[3]||"";let K=J.slice(J.lastIndexOf("\\")+1);return K=K.replace(/%22/g,'"'),K=K.replace(/&#(\d{4});/g,(W,w)=>{return String.fromCharCode(w)}),K};B0=0,g={START_BOUNDARY:B0++,HEADER_FIELD_START:B0++,HEADER_FIELD:B0++,HEADER_VALUE_START:B0++,HEADER_VALUE:B0++,HEADER_VALUE_ALMOST_DONE:B0++,HEADERS_ALMOST_DONE:B0++,PART_DATA_START:B0++,PART_DATA:B0++,END:B0++},q5=1,u0={PART_BOUNDARY:q5,LAST_BOUNDARY:q5*=2},x$=10,E$=13,kX=32,u1=45,_X=58,LX=97,SX=122,vX=(X)=>X|32,e0=()=>{}});var l5=g0((QG,oX)=>{oX.exports={name:"dotenv",version:"16.4.5",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard","lint-readme":"standard-markdown",pretest:"npm run lint && npm run dts-check",test:"tap tests/*.js --100 -Rspec","test:coverage":"tap --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@definitelytyped/dtslint":"^0.0.133","@types/node":"^18.11.3",decache:"^4.6.1",sinon:"^14.0.1",standard:"^17.0.0","standard-markdown":"^7.1.0","standard-version":"^9.5.0",tap:"^16.3.0",tar:"^6.1.11",typescript:"^4.8.4"},engines:{node:">=12"},browser:{fs:!1}}});var o5=g0((XG,R0)=>{var QZ=function(X){const Z={};let J=X.toString();J=J.replace(/\r\n?/mg,"\n");let K;while((K=$Z.exec(J))!=null){const W=K[1];let w=K[2]||"";w=w.trim();const O=w[0];if(w=w.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),O==='"')w=w.replace(/\\n/g,"\n"),w=w.replace(/\\r/g,"\r");Z[W]=w}return Z},XZ=function(X){const Z=a5(X),J=u.configDotenv({path:Z});if(!J.parsed){const O=new Error(`MISSING_DATA: Cannot parse ${Z} for an unknown reason`);throw O.code="MISSING_DATA",O}const K=s5(X).split(","),W=K.length;let w;for(let O=0;O<W;O++)try{const H=K[O].trim(),I=JZ(J,H);w=u.decrypt(I.ciphertext,I.key);break}catch(H){if(O+1>=W)throw H}return u.parse(w)},ZZ=function(X){console.log(`[dotenv@${v4}][INFO] ${X}`)},GZ=function(X){console.log(`[dotenv@${v4}][WARN] ${X}`)},R$=function(X){console.log(`[dotenv@${v4}][DEBUG] ${X}`)},s5=function(X){if(X&&X.DOTENV_KEY&&X.DOTENV_KEY.length>0)return X.DOTENV_KEY;if(process.env.DOTENV_KEY&&process.env.DOTENV_KEY.length>0)return process.env.DOTENV_KEY;return""},JZ=function(X,Z){let J;try{J=new URL(Z)}catch(H){if(H.code==="ERR_INVALID_URL"){const I=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw I.code="INVALID_DOTENV_KEY",I}throw H}const K=J.password;if(!K){const H=new Error("INVALID_DOTENV_KEY: Missing key part");throw H.code="INVALID_DOTENV_KEY",H}const W=J.searchParams.get("environment");if(!W){const H=new Error("INVALID_DOTENV_KEY: Missing environment part");throw H.code="INVALID_DOTENV_KEY",H}const w=`DOTENV_VAULT_${W.toUpperCase()}`,O=X.parsed[w];if(!O){const H=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${w} in your .env.vault file.`);throw H.code="NOT_FOUND_DOTENV_ENVIRONMENT",H}return{ciphertext:O,key:K}},a5=function(X){let Z=null;if(X&&X.path&&X.path.length>0)if(Array.isArray(X.path)){for(let J of X.path)if(L4.existsSync(J))Z=J.endsWith(".vault")?J:`${J}.vault`}else Z=X.path.endsWith(".vault")?X.path:`${X.path}.vault`;else Z=S4.resolve(process.cwd(),".env.vault");if(L4.existsSync(Z))return Z;return null},n5=function(X){return X[0]==="~"?S4.join(tX.homedir(),X.slice(1)):X},KZ=function(X){ZZ("Loading env from encrypted .env.vault");const Z=u._parseVault(X);let J=process.env;if(X&&X.processEnv!=null)J=X.processEnv;return u.populate(J,Z,X),{parsed:Z}},WZ=function(X){const Z=S4.resolve(process.cwd(),".env");let J="utf8";const K=Boolean(X&&X.debug);if(X&&X.encoding)J=X.encoding;else if(K)R$("No encoding is specified. UTF-8 is used by default");let W=[Z];if(X&&X.path)if(!Array.isArray(X.path))W=[n5(X.path)];else{W=[];for(let I of X.path)W.push(n5(I))}let w;const O={};for(let I of W)try{const U=u.parse(L4.readFileSync(I,{encoding:J}));u.populate(O,U,X)}catch(U){if(K)R$(`Failed to load ${I} ${U.message}`);w=U}let H=process.env;if(X&&X.processEnv!=null)H=X.processEnv;if(u.populate(H,O,X),w)return{parsed:O,error:w};else return{parsed:O}},YZ=function(X){if(s5(X).length===0)return u.configDotenv(X);const Z=a5(X);if(!Z)return GZ(`You set DOTENV_KEY but you are missing a .env.vault file at ${Z}. Did you forget to build it?`),u.configDotenv(X);return u._configVault(X)},wZ=function(X,Z){const J=Buffer.from(Z.slice(-64),"hex");let K=Buffer.from(X,"base64");const W=K.subarray(0,12),w=K.subarray(-16);K=K.subarray(12,-16);try{const O=rX.createDecipheriv("aes-256-gcm",J,W);return O.setAuthTag(w),`${O.update(K)}${O.final()}`}catch(O){const H=O instanceof RangeError,I=O.message==="Invalid key length",U=O.message==="Unsupported state or unable to authenticate data";if(H||I){const B=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw B.code="INVALID_DOTENV_KEY",B}else if(U){const B=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw B.code="DECRYPTION_FAILED",B}else throw O}},VZ=function(X,Z,J={}){const K=Boolean(J&&J.debug),W=Boolean(J&&J.override);if(typeof Z!=="object"){const w=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw w.code="OBJECT_REQUIRED",w}for(let w of Object.keys(Z))if(Object.prototype.hasOwnProperty.call(X,w)){if(W===!0)X[w]=Z[w];if(K)if(W===!0)R$(`"${w}" is already defined and WAS overwritten`);else R$(`"${w}" is already defined and was NOT overwritten`)}else X[w]=Z[w]},L4=y0("fs"),S4=y0("path"),tX=y0("os"),rX=y0("crypto"),eX=l5(),v4=eX.version,$Z=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg,u={configDotenv:WZ,_configVault:KZ,_parseVault:XZ,config:YZ,decrypt:wZ,parse:QZ,populate:VZ};XG.configDotenv=u.configDotenv;XG._configVault=u._configVault;XG._parseVault=u._parseVault;XG.config=u.config;XG.decrypt=u.decrypt;XG.parse=u.parse;XG.populate=u.populate;R0.exports=u});var r5=g0((ZG,t5)=>{var C1={};if(process.env.DOTENV_CONFIG_ENCODING!=null)C1.encoding=process.env.DOTENV_CONFIG_ENCODING;if(process.env.DOTENV_CONFIG_PATH!=null)C1.path=process.env.DOTENV_CONFIG_PATH;if(process.env.DOTENV_CONFIG_DEBUG!=null)C1.debug=process.env.DOTENV_CONFIG_DEBUG;if(process.env.DOTENV_CONFIG_OVERRIDE!=null)C1.override=process.env.DOTENV_CONFIG_OVERRIDE;if(process.env.DOTENV_CONFIG_DOTENV_KEY!=null)C1.DOTENV_KEY=process.env.DOTENV_CONFIG_DOTENV_KEY;t5.exports=C1});var $8=g0((GG,e5)=>{var PZ=/^dotenv_config_(encoding|path|debug|override|DOTENV_KEY)=(.+)$/;e5.exports=function X(Z){return Z.reduce(function(J,K){const W=K.match(PZ);if(W)J[W[1]]=W[2];return J},{})}});var Q8=g0(()=>{(function(){o5().config(Object.assign({},r5(),$8()(process.argv)))})()});var QX=function(){const X=new Map;for(let[Z,J]of Object.entries(b)){for(let[K,W]of Object.entries(J))b[K]={open:`\x1B[${W[0]}m`,close:`\x1B[${W[1]}m`},J[K]=b[K],X.set(W[0],W[1]);Object.defineProperty(b,Z,{value:J,enumerable:!1})}return Object.defineProperty(b,"codes",{value:X,enumerable:!1}),b.color.close="\x1B[39m",b.bgColor.close="\x1B[49m",b.color.ansi=t6(),b.color.ansi256=r6(),b.color.ansi16m=e6(),b.bgColor.ansi=t6(10),b.bgColor.ansi256=r6(10),b.bgColor.ansi16m=e6(10),Object.defineProperties(b,{rgbToAnsi256:{value(Z,J,K){if(Z===J&&J===K){if(Z<8)return 16;if(Z>248)return 231;return Math.round((Z-8)/247*24)+232}return 16+36*Math.round(Z/255*5)+6*Math.round(J/255*5)+Math.round(K/255*5)},enumerable:!1},hexToRgb:{value(Z){const J=/[a-f\d]{6}|[a-f\d]{3}/i.exec(Z.toString(16));if(!J)return[0,0,0];let[K]=J;if(K.length===3)K=[...K].map((w)=>w+w).join("");const W=Number.parseInt(K,16);return[W>>16&255,W>>8&255,W&255]},enumerable:!1},hexToAnsi256:{value:(Z)=>b.rgbToAnsi256(...b.hexToRgb(Z)),enumerable:!1},ansi256ToAnsi:{value(Z){if(Z<8)return 30+Z;if(Z<16)return 90+(Z-8);let J,K,W;if(Z>=232)J=((Z-232)*10+8)/255,K=J,W=J;else{Z-=16;const H=Z%36;J=Math.floor(Z/36)/5,K=Math.floor(H/6)/5,W=H%6/5}const w=Math.max(J,K,W)*2;if(w===0)return 30;let O=30+(Math.round(W)<<2|Math.round(K)<<1|Math.round(J));if(w===2)O+=60;return O},enumerable:!1},rgbToAnsi:{value:(Z,J,K)=>b.ansi256ToAnsi(b.rgbToAnsi256(Z,J,K)),enumerable:!1},hexToAnsi:{value:(Z)=>b.ansi256ToAnsi(b.hexToAnsi256(Z)),enumerable:!1}}),b};var t6=(X=0)=>(Z)=>`\x1B[${Z+X}m`,r6=(X=0)=>(Z)=>`\x1B[${38+X};5;${Z}m`,e6=(X=0)=>(Z,J,K)=>`\x1B[${38+X};2;${Z};${J};${K}m`,b={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}},AZ=Object.keys(b.modifier),eQ=Object.keys(b.color),$X=Object.keys(b.bgColor),xZ=[...eQ,...$X],XX=QX(),Y0=XX;import C4 from"node:process";import ZX from"node:os";import $5 from"node:tty";var G0=function(X,Z=globalThis.Deno?globalThis.Deno.args:C4.argv){const J=X.startsWith("-")?"":X.length===1?"-":"--",K=Z.indexOf(J+X),W=Z.indexOf("--");return K!==-1&&(W===-1||K<W)},GX=function(){if("FORCE_COLOR"in m){if(m.FORCE_COLOR==="true")return 1;if(m.FORCE_COLOR==="false")return 0;return m.FORCE_COLOR.length===0?1:Math.min(Number.parseInt(m.FORCE_COLOR,10),3)}},JX=function(X){if(X===0)return!1;return{level:X,hasBasic:!0,has256:X>=2,has16m:X>=3}},KX=function(X,{streamIsTTY:Z,sniffFlags:J=!0}={}){const K=GX();if(K!==void 0)I$=K;const W=J?I$:K;if(W===0)return 0;if(J){if(G0("color=16m")||G0("color=full")||G0("color=truecolor"))return 3;if(G0("color=256"))return 2}if("TF_BUILD"in m&&"AGENT_NAME"in m)return 1;if(X&&!Z&&W===void 0)return 0;const w=W||0;if(m.TERM==="dumb")return w;if(C4.platform==="win32"){const O=ZX.release().split(".");if(Number(O[0])>=10&&Number(O[2])>=10586)return Number(O[2])>=14931?3:2;return 1}if("CI"in m){if("GITHUB_ACTIONS"in m||"GITEA_ACTIONS"in m)return 3;if(["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","BUILDKITE","DRONE"].some((O)=>(O in m))||m.CI_NAME==="codeship")return 1;return w}if("TEAMCITY_VERSION"in m)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(m.TEAMCITY_VERSION)?1:0;if(m.COLORTERM==="truecolor")return 3;if(m.TERM==="xterm-kitty")return 3;if("TERM_PROGRAM"in m){const O=Number.parseInt((m.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(m.TERM_PROGRAM){case"iTerm.app":return O>=3?3:2;case"Apple_Terminal":return 2}}if(/-256(color)?$/i.test(m.TERM))return 2;if(/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(m.TERM))return 1;if("COLORTERM"in m)return 1;return w};function Q5(X,Z={}){const J=KX(X,{streamIsTTY:X&&X.isTTY,...Z});return JX(J)}var{env:m}=C4,I$;if(G0("no-color")||G0("no-colors")||G0("color=false")||G0("color=never"))I$=0;else if(G0("color")||G0("colors")||G0("color=true")||G0("color=always"))I$=1;var WX={stdout:Q5({isTTY:$5.isatty(1)}),stderr:Q5({isTTY:$5.isatty(2)})},X5=WX;function Z5(X,Z,J){let K=X.indexOf(Z);if(K===-1)return X;const W=Z.length;let w=0,O="";do O+=X.slice(w,K)+Z+J,w=K+W,K=X.indexOf(Z,w);while(K!==-1);return O+=X.slice(w),O}function G5(X,Z,J,K){let W=0,w="";do{const O=X[K-1]==="\r";w+=X.slice(W,O?K-1:K)+Z+(O?"\r\n":"\n")+J,W=K+1,K=X.indexOf("\n",W)}while(K!==-1);return w+=X.slice(W),w}var g1=function(X){return wX(X)};var{stdout:J5,stderr:K5}=X5,D4=Symbol("GENERATOR"),O1=Symbol("STYLER"),h1=Symbol("IS_EMPTY"),W5=["ansi","ansi","ansi256","ansi16m"],H1=Object.create(null),YX=(X,Z={})=>{if(Z.level&&!(Number.isInteger(Z.level)&&Z.level>=0&&Z.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const J=J5?J5.level:0;X.level=Z.level===void 0?J:Z.level};var wX=(X)=>{const Z=(...J)=>J.join(" ");return YX(Z,X),Object.setPrototypeOf(Z,g1.prototype),Z};Object.setPrototypeOf(g1.prototype,Function.prototype);for(let[X,Z]of Object.entries(Y0))H1[X]={get(){const J=P$(this,x4(Z.open,Z.close,this[O1]),this[h1]);return Object.defineProperty(this,X,{value:J}),J}};H1.visible={get(){const X=P$(this,this[O1],!0);return Object.defineProperty(this,"visible",{value:X}),X}};var A4=(X,Z,J,...K)=>{if(X==="rgb"){if(Z==="ansi16m")return Y0[J].ansi16m(...K);if(Z==="ansi256")return Y0[J].ansi256(Y0.rgbToAnsi256(...K));return Y0[J].ansi(Y0.rgbToAnsi(...K))}if(X==="hex")return A4("rgb",Z,J,...Y0.hexToRgb(...K));return Y0[J][X](...K)},VX=["rgb","hex","ansi256"];for(let X of VX){H1[X]={get(){const{level:J}=this;return function(...K){const W=x4(A4(X,W5[J],"color",...K),Y0.color.close,this[O1]);return P$(this,W,this[h1])}}};const Z="bg"+X[0].toUpperCase()+X.slice(1);H1[Z]={get(){const{level:J}=this;return function(...K){const W=x4(A4(X,W5[J],"bgColor",...K),Y0.bgColor.close,this[O1]);return P$(this,W,this[h1])}}}}var zX=Object.defineProperties(()=>{},{...H1,level:{enumerable:!0,get(){return this[D4].level},set(X){this[D4].level=X}}}),x4=(X,Z,J)=>{let K,W;if(J===void 0)K=X,W=Z;else K=J.openAll+X,W=Z+J.closeAll;return{open:X,close:Z,openAll:K,closeAll:W,parent:J}},P$=(X,Z,J)=>{const K=(...W)=>OX(K,W.length===1?""+W[0]:W.join(" "));return Object.setPrototypeOf(K,zX),K[D4]=X,K[O1]=Z,K[h1]=J,K},OX=(X,Z)=>{if(X.level<=0||!Z)return X[h1]?"":Z;let J=X[O1];if(J===void 0)return Z;const{openAll:K,closeAll:W}=J;if(Z.includes("\x1B"))while(J!==void 0)Z=Z5(Z,J.close,J.open),J=J.parent;const w=Z.indexOf("\n");if(w!==-1)Z=G5(Z,W,K,w);return K+Z+W};Object.defineProperties(g1.prototype,H1);var HX=g1(),LZ=g1({level:K5?K5.level:0});var b0=HX;var MX=/d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g,UX=/\b(?:[A-Z]{1,3}[A-Z][TC])(?:[-+]\d{4})?|((?:Australian )?(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time)\b/g,BX=/[^-+\dA-Z]/g;function a(X,Z,J,K){if(arguments.length===1&&typeof X==="string"&&!/\d/.test(X))Z=X,X=void 0;if(X=X||X===0?X:new Date,!(X instanceof Date))X=new Date(X);if(isNaN(X))throw TypeError("Invalid date");Z=String(Y5[Z]||Z||Y5.default);var W=Z.slice(0,4);if(W==="UTC:"||W==="GMT:"){if(Z=Z.slice(4),J=!0,W==="GMT:")K=!0}var w=function P(){return J?"getUTC":"get"},O=function P(){return X[w()+"Date"]()},H=function P(){return X[w()+"Day"]()},I=function P(){return X[w()+"Month"]()},U=function P(){return X[w()+"FullYear"]()},B=function P(){return X[w()+"Hours"]()},L=function P(){return X[w()+"Minutes"]()},T=function P(){return X[w()+"Seconds"]()},E=function P(){return X[w()+"Milliseconds"]()},D=function P(){return J?0:X.getTimezoneOffset()},S=function P(){return IX(X)},_=function P(){return PX(X)},F={d:function P(){return O()},dd:function P(){return r(O())},ddd:function P(){return s.dayNames[H()]},DDD:function P(){return w5({y:U(),m:I(),d:O(),_:w(),dayName:s.dayNames[H()],short:!0})},dddd:function P(){return s.dayNames[H()+7]},DDDD:function P(){return w5({y:U(),m:I(),d:O(),_:w(),dayName:s.dayNames[H()+7]})},m:function P(){return I()+1},mm:function P(){return r(I()+1)},mmm:function P(){return s.monthNames[I()]},mmmm:function P(){return s.monthNames[I()+12]},yy:function P(){return String(U()).slice(2)},yyyy:function P(){return r(U(),4)},h:function P(){return B()%12||12},hh:function P(){return r(B()%12||12)},H:function P(){return B()},HH:function P(){return r(B())},M:function P(){return L()},MM:function P(){return r(L())},s:function P(){return T()},ss:function P(){return r(T())},l:function P(){return r(E(),3)},L:function P(){return r(Math.floor(E()/10))},t:function P(){return B()<12?s.timeNames[0]:s.timeNames[1]},tt:function P(){return B()<12?s.timeNames[2]:s.timeNames[3]},T:function P(){return B()<12?s.timeNames[4]:s.timeNames[5]},TT:function P(){return B()<12?s.timeNames[6]:s.timeNames[7]},Z:function P(){return K?"GMT":J?"UTC":CX(X)},o:function P(){return(D()>0?"-":"+")+r(Math.floor(Math.abs(D())/60)*100+Math.abs(D())%60,4)},p:function P(){return(D()>0?"-":"+")+r(Math.floor(Math.abs(D())/60),2)+":"+r(Math.floor(Math.abs(D())%60),2)},S:function P(){return["th","st","nd","rd"][O()%10>3?0:(O()%100-O()%10!=10)*O()%10]},W:function P(){return S()},WW:function P(){return r(S())},N:function P(){return _()}};return Z.replace(MX,function(P){if(P in F)return F[P]();return P.slice(1,P.length-1)})}var Y5={default:"ddd mmm dd yyyy HH:MM:ss",shortDate:"m/d/yy",paddedShortDate:"mm/dd/yyyy",mediumDate:"mmm d, yyyy",longDate:"mmmm d, yyyy",fullDate:"dddd, mmmm d, yyyy",shortTime:"h:MM TT",mediumTime:"h:MM:ss TT",longTime:"h:MM:ss TT Z",isoDate:"yyyy-mm-dd",isoTime:"HH:MM:ss",isoDateTime:"yyyy-mm-dd'T'HH:MM:sso",isoUtcDateTime:"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",expiresHeaderFormat:"ddd, dd mmm yyyy HH:MM:ss Z"},s={dayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","January","February","March","April","May","June","July","August","September","October","November","December"],timeNames:["a","p","am","pm","A","P","AM","PM"]},r=function X(Z){var J=arguments.length>1&&arguments[1]!==void 0?arguments[1]:2;return String(Z).padStart(J,"0")},w5=function X(Z){var{y:J,m:K,d:W,_:w,dayName:O,short:H}=Z,I=H===void 0?!1:H,U=new Date,B=new Date;B.setDate(B[w+"Date"]()-1);var L=new Date;L.setDate(L[w+"Date"]()+1);var T=function j(){return U[w+"Date"]()},E=function j(){return U[w+"Month"]()},D=function j(){return U[w+"FullYear"]()},S=function j(){return B[w+"Date"]()},_=function j(){return B[w+"Month"]()},F=function j(){return B[w+"FullYear"]()},P=function j(){return L[w+"Date"]()},y=function j(){return L[w+"Month"]()},f=function j(){return L[w+"FullYear"]()};if(D()===J&&E()===K&&T()===W)return I?"Tdy":"Today";else if(F()===J&&_()===K&&S()===W)return I?"Ysd":"Yesterday";else if(f()===J&&y()===K&&P()===W)return I?"Tmw":"Tomorrow";return O},IX=function X(Z){var J=new Date(Z.getFullYear(),Z.getMonth(),Z.getDate());J.setDate(J.getDate()-(J.getDay()+6)%7+3);var K=new Date(J.getFullYear(),0,4);K.setDate(K.getDate()-(K.getDay()+6)%7+3);var W=J.getTimezoneOffset()-K.getTimezoneOffset();J.setHours(J.getHours()-W);var w=(J-K)/604800000;return 1+Math.floor(w)},PX=function X(Z){var J=Z.getDay();if(J===0)J=7;return J},CX=function X(Z){return(String(Z).match(UX)||[""]).pop().replace(BX,"").replace(/GMT\+0000/g,"UTC")};import*as V0 from"node:fs";import lX from"node:http";import nX from"node:https";import I1 from"node:zlib";import d5,{PassThrough as i5,pipeline as P1} from"node:stream";import{Buffer as T$} from"node:buffer";function DX(X){if(!/^data:/i.test(X))throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');X=X.replace(/\r?\n/g,"");const Z=X.indexOf(",");if(Z===-1||Z<=4)throw new TypeError("malformed data: URI");const J=X.substring(5,Z).split(";");let K="",W=!1;const w=J[0]||"text/plain";let O=w;for(let B=1;B<J.length;B++)if(J[B]==="base64")W=!0;else if(J[B]){if(O+=`;${J[B]}`,J[B].indexOf("charset=")===0)K=J[B].substring(8)}if(!J[0]&&!K.length)O+=";charset=US-ASCII",K="US-ASCII";const H=W?"base64":"ascii",I=unescape(X.substring(Z+1)),U=Buffer.from(I,H);return U.type=w,U.typeFull=O,U.charset=K,U}var V5=DX;y1();D$();import p0,{PassThrough as k5} from"node:stream";import{types as _5,deprecate as R4,promisify as gX} from"node:util";import{Buffer as J0} from"node:buffer";class m0 extends Error{constructor(X,Z){super(X);Error.captureStackTrace(this,this.constructor),this.type=Z}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class e extends m0{constructor(X,Z,J){super(X,Z);if(J)this.code=this.errno=J.code,this.erroredSysCall=J.syscall}}var A$=Symbol.toStringTag,q4=(X)=>{return typeof X==="object"&&typeof X.append==="function"&&typeof X.delete==="function"&&typeof X.get==="function"&&typeof X.getAll==="function"&&typeof X.has==="function"&&typeof X.set==="function"&&typeof X.sort==="function"&&X[A$]==="URLSearchParams"},m1=(X)=>{return X&&typeof X==="object"&&typeof X.arrayBuffer==="function"&&typeof X.type==="string"&&typeof X.stream==="function"&&typeof X.constructor==="function"&&/^(Blob|File)$/.test(X[A$])},C5=(X)=>{return typeof X==="object"&&(X[A$]==="AbortSignal"||X[A$]==="EventTarget")},D5=(X,Z)=>{const J=new URL(Z).hostname,K=new URL(X).hostname;return J===K||J.endsWith(`.${K}`)},A5=(X,Z)=>{const J=new URL(Z).protocol,K=new URL(X).protocol;return J===K};async function T4(X){if(X[o].disturbed)throw new TypeError(`body used already for: ${X.url}`);if(X[o].disturbed=!0,X[o].error)throw X[o].error;const{body:Z}=X;if(Z===null)return J0.alloc(0);if(!(Z instanceof p0))return J0.alloc(0);const J=[];let K=0;try{for await(let W of Z){if(X.size>0&&K+W.length>X.size){const w=new e(`content size at ${X.url} over limit: ${X.size}`,"max-size");throw Z.destroy(w),w}K+=W.length,J.push(W)}}catch(W){throw W instanceof m0?W:new e(`Invalid response body while trying to fetch ${X.url}: ${W.message}`,"system",W)}if(Z.readableEnded===!0||Z._readableState.ended===!0)try{if(J.every((W)=>typeof W==="string"))return J0.from(J.join(""));return J0.concat(J,K)}catch(W){throw new e(`Could not create Buffer from response body for ${X.url}: ${W.message}`,"system",W)}else throw new e(`Premature close of server response while trying to fetch ${X.url}`)}var yX=gX(p0.pipeline),o=Symbol("Body internals");class T0{constructor(X,{size:Z=0}={}){let J=null;if(X===null)X=null;else if(q4(X))X=J0.from(X.toString());else if(m1(X));else if(J0.isBuffer(X));else if(_5.isAnyArrayBuffer(X))X=J0.from(X);else if(ArrayBuffer.isView(X))X=J0.from(X.buffer,X.byteOffset,X.byteLength);else if(X instanceof p0);else if(X instanceof r0)X=P5(X),J=X.type.split("=")[1];else X=J0.from(String(X));let K=X;if(J0.isBuffer(X))K=p0.Readable.from(X);else if(m1(X))K=p0.Readable.from(X.stream());if(this[o]={body:X,stream:K,boundary:J,disturbed:!1,error:null},this.size=Z,X instanceof p0)X.on("error",(W)=>{const w=W instanceof m0?W:new e(`Invalid response body while trying to fetch ${this.url}: ${W.message}`,"system",W);this[o].error=w})}get body(){return this[o].stream}get bodyUsed(){return this[o].disturbed}async arrayBuffer(){const{buffer:X,byteOffset:Z,byteLength:J}=await T4(this);return X.slice(Z,Z+J)}async formData(){const X=this.headers.get("content-type");if(X.startsWith("application/x-www-form-urlencoded")){const J=new r0,K=new URLSearchParams(await this.text());for(let[W,w]of K)J.append(W,w);return J}const{toFormData:Z}=await Promise.resolve().then(() => (R5(),T5));return Z(this.body,X)}async blob(){const X=this.headers&&this.headers.get("content-type")||this[o].body&&this[o].body.type||"",Z=await this.arrayBuffer();return new j0([Z],{type:X})}async json(){const X=await this.text();return JSON.parse(X)}async text(){const X=await T4(this);return(new TextDecoder()).decode(X)}buffer(){return T4(this)}}T0.prototype.buffer=R4(T0.prototype.buffer,"Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'","node-fetch#buffer");Object.defineProperties(T0.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0},data:{get:R4(()=>{},"data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});var U1=(X,Z)=>{let J,K,{body:W}=X[o];if(X.bodyUsed)throw new Error("cannot clone body after it is used");if(W instanceof p0&&typeof W.getBoundary!=="function")J=new k5({highWaterMark:Z}),K=new k5({highWaterMark:Z}),W.pipe(J),W.pipe(K),X[o].stream=J,W=K;return W},bX=R4((X)=>X.getBoundary(),"form-data doesn\'t follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167"),F$=(X,Z)=>{if(X===null)return null;if(typeof X==="string")return"text/plain;charset=UTF-8";if(q4(X))return"application/x-www-form-urlencoded;charset=UTF-8";if(m1(X))return X.type||null;if(J0.isBuffer(X)||_5.isAnyArrayBuffer(X)||ArrayBuffer.isView(X))return null;if(X instanceof r0)return`multipart/form-data; boundary=${Z[o].boundary}`;if(X&&typeof X.getBoundary==="function")return`multipart/form-data;boundary=${bX(X)}`;if(X instanceof p0)return null;return"text/plain;charset=UTF-8"},L5=(X)=>{const{body:Z}=X[o];if(Z===null)return 0;if(m1(Z))return Z.size;if(J0.isBuffer(Z))return Z.length;if(Z&&typeof Z.getLengthSync==="function")return Z.hasKnownLength&&Z.hasKnownLength()?Z.getLengthSync():null;return null},S5=async(X,{body:Z})=>{if(Z===null)X.end();else await yX(Z,X)};import{types as v5} from"node:util";import q$ from"node:http";function f5(X=[]){return new $0(X.reduce((Z,J,K,W)=>{if(K%2===0)Z.push(W.slice(K,K+2));return Z},[]).filter(([Z,J])=>{try{return N$(Z),k4(Z,String(J)),!0}catch{return!1}}))}var N$=typeof q$.validateHeaderName==="function"?q$.validateHeaderName:(X)=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(X)){const Z=new TypeError(`Header name must be a valid HTTP token [${X}]`);throw Object.defineProperty(Z,"code",{value:"ERR_INVALID_HTTP_TOKEN"}),Z}},k4=typeof q$.validateHeaderValue==="function"?q$.validateHeaderValue:(X,Z)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(Z)){const J=new TypeError(`Invalid character in header content ["${X}"]`);throw Object.defineProperty(J,"code",{value:"ERR_INVALID_CHAR"}),J}};class $0 extends URLSearchParams{constructor(X){let Z=[];if(X instanceof $0){const J=X.raw();for(let[K,W]of Object.entries(J))Z.push(...W.map((w)=>[K,w]))}else if(X==null);else if(typeof X==="object"&&!v5.isBoxedPrimitive(X)){const J=X[Symbol.iterator];if(J==null)Z.push(...Object.entries(X));else{if(typeof J!=="function")throw new TypeError("Header pairs must be iterable");Z=[...X].map((K)=>{if(typeof K!=="object"||v5.isBoxedPrimitive(K))throw new TypeError("Each header pair must be an iterable object");return[...K]}).map((K)=>{if(K.length!==2)throw new TypeError("Each header pair must be a name/value tuple");return[...K]})}}else throw new TypeError("Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");Z=Z.length>0?Z.map(([J,K])=>{return N$(J),k4(J,String(K)),[String(J).toLowerCase(),String(K)]}):void 0;super(Z);return new Proxy(this,{get(J,K,W){switch(K){case"append":case"set":return(w,O)=>{return N$(w),k4(w,String(O)),URLSearchParams.prototype[K].call(J,String(w).toLowerCase(),String(O))};case"delete":case"has":case"getAll":return(w)=>{return N$(w),URLSearchParams.prototype[K].call(J,String(w).toLowerCase())};case"keys":return()=>{return J.sort(),new Set(URLSearchParams.prototype.keys.call(J)).keys()};default:return Reflect.get(J,K,W)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(X){const Z=this.getAll(X);if(Z.length===0)return null;let J=Z.join(", ");if(/^content-encoding$/i.test(X))J=J.toLowerCase();return J}forEach(X,Z=void 0){for(let J of this.keys())Reflect.apply(X,Z,[this.get(J),J,this])}*values(){for(let X of this.keys())yield this.get(X)}*entries(){for(let X of this.keys())yield[X,this.get(X)]}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce((X,Z)=>{return X[Z]=this.getAll(Z),X},{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce((X,Z)=>{const J=this.getAll(Z);if(Z==="host")X[Z]=J[0];else X[Z]=J.length>1?J:J[0];return X},{})}}Object.defineProperties($0.prototype,["get","entries","forEach","values"].reduce((X,Z)=>{return X[Z]={enumerable:!0},X},{}));var mX=new Set([301,302,303,307,308]),j$=(X)=>{return mX.has(X)};var w0=Symbol("Response internals");class l extends T0{constructor(X=null,Z={}){super(X,Z);const J=Z.status!=null?Z.status:200,K=new $0(Z.headers);if(X!==null&&!K.has("Content-Type")){const W=F$(X,this);if(W)K.append("Content-Type",W)}this[w0]={type:"default",url:Z.url,status:J,statusText:Z.statusText||"",headers:K,counter:Z.counter,highWaterMark:Z.highWaterMark}}get type(){return this[w0].type}get url(){return this[w0].url||""}get status(){return this[w0].status}get ok(){return this[w0].status>=200&&this[w0].status<300}get redirected(){return this[w0].counter>0}get statusText(){return this[w0].statusText}get headers(){return this[w0].headers}get highWaterMark(){return this[w0].highWaterMark}clone(){return new l(U1(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(X,Z=302){if(!j$(Z))throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');return new l(null,{headers:{location:new URL(X).toString()},status:Z})}static error(){const X=new l(null,{status:0,statusText:""});return X[w0].type="error",X}static json(X=void 0,Z={}){const J=JSON.stringify(X);if(J===void 0)throw new TypeError("data is not JSON serializable");const K=new $0(Z&&Z.headers);if(!K.has("content-type"))K.set("content-type","application/json");return new l(J,{...Z,headers:K})}get[Symbol.toStringTag](){return"Response"}}Object.defineProperties(l.prototype,{type:{enumerable:!0},url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}});import{format as cX} from"node:url";import{deprecate as dX} from"node:util";var h5=(X)=>{if(X.search)return X.search;const Z=X.href.length-1,J=X.hash||(X.href[Z]==="#"?"#":"");return X.href[Z-J.length]==="?"?"?":""};import{isIP as uX} from"node:net";function g5(X,Z=!1){if(X==null)return"no-referrer";if(X=new URL(X),/^(about|blob|data):$/.test(X.protocol))return"no-referrer";if(X.username="",X.password="",X.hash="",Z)X.pathname="",X.search="";return X}function m5(X){if(!y5.has(X))throw new TypeError(`Invalid referrerPolicy: ${X}`);return X}function pX(X){if(/^(http|ws)s:$/.test(X.protocol))return!0;const Z=X.host.replace(/(^\[)|(]$)/g,""),J=uX(Z);if(J===4&&/^127\./.test(Z))return!0;if(J===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(Z))return!0;if(X.host==="localhost"||X.host.endsWith(".localhost"))return!1;if(X.protocol==="file:")return!0;return!1}function B1(X){if(/^about:(blank|srcdoc)$/.test(X))return!0;if(X.protocol==="data:")return!0;if(/^(blob|filesystem):$/.test(X.protocol))return!0;return pX(X)}function u5(X,{referrerURLCallback:Z,referrerOriginCallback:J}={}){if(X.referrer==="no-referrer"||X.referrerPolicy==="")return null;const K=X.referrerPolicy;if(X.referrer==="about:client")return"no-referrer";const W=X.referrer;let w=g5(W),O=g5(W,!0);if(w.toString().length>4096)w=O;if(Z)w=Z(w);if(J)O=J(O);const H=new URL(X.url);switch(K){case"no-referrer":return"no-referrer";case"origin":return O;case"unsafe-url":return w;case"strict-origin":if(B1(w)&&!B1(H))return"no-referrer";return O.toString();case"strict-origin-when-cross-origin":if(w.origin===H.origin)return w;if(B1(w)&&!B1(H))return"no-referrer";return O;case"same-origin":if(w.origin===H.origin)return w;return"no-referrer";case"origin-when-cross-origin":if(w.origin===H.origin)return w;return O;case"no-referrer-when-downgrade":if(B1(w)&&!B1(H))return"no-referrer";return w;default:throw new TypeError(`Invalid referrerPolicy: ${K}`)}}function p5(X){const Z=(X.get("referrer-policy")||"").split(/[,\s]+/);let J="";for(let K of Z)if(K&&y5.has(K))J=K;return J}var y5=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]),b5="strict-origin-when-cross-origin";var c=Symbol("Request internals"),p1=(X)=>{return typeof X==="object"&&typeof X[c]==="object"},iX=dX(()=>{},".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");class $1 extends T0{constructor(X,Z={}){let J;if(p1(X))J=new URL(X.url);else J=new URL(X),X={};if(J.username!==""||J.password!=="")throw new TypeError(`${J} is an url with embedded credentials.`);let K=Z.method||X.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(K))K=K.toUpperCase();if(!p1(Z)&&"data"in Z)iX();if((Z.body!=null||p1(X)&&X.body!==null)&&(K==="GET"||K==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");const W=Z.body?Z.body:p1(X)&&X.body!==null?U1(X):null;super(W,{size:Z.size||X.size||0});const w=new $0(Z.headers||X.headers||{});if(W!==null&&!w.has("Content-Type")){const I=F$(W,this);if(I)w.set("Content-Type",I)}let O=p1(X)?X.signal:null;if("signal"in Z)O=Z.signal;if(O!=null&&!C5(O))throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");let H=Z.referrer==null?X.referrer:Z.referrer;if(H==="")H="no-referrer";else if(H){const I=new URL(H);H=/^about:(\/\/)?client$/.test(I)?"client":I}else H=void 0;this[c]={method:K,redirect:Z.redirect||X.redirect||"follow",headers:w,parsedURL:J,signal:O,referrer:H},this.follow=Z.follow===void 0?X.follow===void 0?20:X.follow:Z.follow,this.compress=Z.compress===void 0?X.compress===void 0?!0:X.compress:Z.compress,this.counter=Z.counter||X.counter||0,this.agent=Z.agent||X.agent,this.highWaterMark=Z.highWaterMark||X.highWaterMark||16384,this.insecureHTTPParser=Z.insecureHTTPParser||X.insecureHTTPParser||!1,this.referrerPolicy=Z.referrerPolicy||X.referrerPolicy||""}get method(){return this[c].method}get url(){return cX(this[c].parsedURL)}get headers(){return this[c].headers}get redirect(){return this[c].redirect}get signal(){return this[c].signal}get referrer(){if(this[c].referrer==="no-referrer")return"";if(this[c].referrer==="client")return"about:client";if(this[c].referrer)return this[c].referrer.toString();return}get referrerPolicy(){return this[c].referrerPolicy}set referrerPolicy(X){this[c].referrerPolicy=m5(X)}clone(){return new $1(this)}get[Symbol.toStringTag](){return"Request"}}Object.defineProperties($1.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0},referrer:{enumerable:!0},referrerPolicy:{enumerable:!0}});var c5=(X)=>{const{parsedURL:Z}=X[c],J=new $0(X[c].headers);if(!J.has("Accept"))J.set("Accept","*/*");let K=null;if(X.body===null&&/^(post|put)$/i.test(X.method))K="0";if(X.body!==null){const H=L5(X);if(typeof H==="number"&&!Number.isNaN(H))K=String(H)}if(K)J.set("Content-Length",K);if(X.referrerPolicy==="")X.referrerPolicy=b5;if(X.referrer&&X.referrer!=="no-referrer")X[c].referrer=u5(X);else X[c].referrer="no-referrer";if(X[c].referrer instanceof URL)J.set("Referer",X.referrer);if(!J.has("User-Agent"))J.set("User-Agent","node-fetch");if(X.compress&&!J.has("Accept-Encoding"))J.set("Accept-Encoding","gzip, deflate, br");let{agent:W}=X;if(typeof W==="function")W=W(Z);const w=h5(Z),O={path:Z.pathname+w,method:X.method,headers:J[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:X.insecureHTTPParser,agent:W};return{parsedURL:Z,options:O}};class _4 extends m0{constructor(X,Z="aborted"){super(X,Z)}}D$();j4();var aX=function(X,Z){const J=T$.from("0\r\n\r\n");let K=!1,W=!1,w;X.on("response",(O)=>{const{headers:H}=O;K=H["transfer-encoding"]==="chunked"&&!H["content-length"]}),X.on("socket",(O)=>{const H=()=>{if(K&&!W){const U=new Error("Premature close");U.code="ERR_STREAM_PREMATURE_CLOSE",Z(U)}},I=(U)=>{if(W=T$.compare(U.slice(-5),J)===0,!W&&w)W=T$.compare(w.slice(-3),J.slice(0,3))===0&&T$.compare(U.slice(-2),J.slice(3))===0;w=U};O.prependListener("close",H),O.on("data",I),X.on("close",()=>{O.removeListener("close",H),O.removeListener("data",I)})})};var sX=new Set(["data:","http:","https:"]);async function c1(X,Z){return new Promise((J,K)=>{const W=new $1(X,Z),{parsedURL:w,options:O}=c5(W);if(!sX.has(w.protocol))throw new TypeError(`node-fetch cannot load ${X}. URL scheme "${w.protocol.replace(/:$/,"")}" is not supported.`);if(w.protocol==="data:"){const D=V5(W.url),S=new l(D,{headers:{"Content-Type":D.typeFull}});J(S);return}const H=(w.protocol==="https:"?nX:lX).request,{signal:I}=W;let U=null;const B=()=>{const D=new _4("The operation was aborted.");if(K(D),W.body&&W.body instanceof d5.Readable)W.body.destroy(D);if(!U||!U.body)return;U.body.emit("error",D)};if(I&&I.aborted){B();return}const L=()=>{B(),E()},T=H(w.toString(),O);if(I)I.addEventListener("abort",L);const E=()=>{if(T.abort(),I)I.removeEventListener("abort",L)};if(T.on("error",(D)=>{K(new e(`request to ${W.url} failed, reason: ${D.message}`,"system",D)),E()}),aX(T,(D)=>{if(U&&U.body)U.body.destroy(D)}),process.version<"v14")T.on("socket",(D)=>{let S;D.prependListener("end",()=>{S=D._eventsCount}),D.prependListener("close",(_)=>{if(U&&S<D._eventsCount&&!_){const F=new Error("Premature close");F.code="ERR_STREAM_PREMATURE_CLOSE",U.body.emit("error",F)}})});T.on("response",(D)=>{T.setTimeout(0);const S=f5(D.rawHeaders);if(j$(D.statusCode)){const f=S.get("Location");let j=null;try{j=f===null?null:new URL(f,W.url)}catch{if(W.redirect!=="manual"){K(new e(`uri requested responds with an invalid redirect URL: ${f}`,"invalid-redirect")),E();return}}switch(W.redirect){case"error":K(new e(`uri requested responds with a redirect, redirect mode is set to error: ${W.url}`,"no-redirect")),E();return;case"manual":break;case"follow":{if(j===null)break;if(W.counter>=W.follow){K(new e(`maximum redirect reached at: ${W.url}`,"max-redirect")),E();return}const p={headers:new $0(W.headers),follow:W.follow,counter:W.counter+1,agent:W.agent,compress:W.compress,method:W.method,body:U1(W),signal:W.signal,size:W.size,referrer:W.referrer,referrerPolicy:W.referrerPolicy};if(!D5(W.url,j)||!A5(W.url,j))for(let A1 of["authorization","www-authenticate","cookie","cookie2"])p.headers.delete(A1);if(D.statusCode!==303&&W.body&&Z.body instanceof d5.Readable){K(new e("Cannot follow redirect with body being a readable stream","unsupported-redirect")),E();return}if(D.statusCode===303||(D.statusCode===301||D.statusCode===302)&&W.method==="POST")p.method="GET",p.body=void 0,p.headers.delete("content-length");const D1=p5(S);if(D1)p.referrerPolicy=D1;J(c1(new $1(j,p))),E();return}default:return K(new TypeError(`Redirect option '${W.redirect}' is not a valid value of RequestRedirect`))}}if(I)D.once("end",()=>{I.removeEventListener("abort",L)});let _=P1(D,new i5,(f)=>{if(f)K(f)});if(process.version<"v12.10")D.on("aborted",L);const F={url:W.url,status:D.statusCode,statusText:D.statusMessage,headers:S,size:W.size,counter:W.counter,highWaterMark:W.highWaterMark},P=S.get("Content-Encoding");if(!W.compress||W.method==="HEAD"||P===null||D.statusCode===204||D.statusCode===304){U=new l(_,F),J(U);return}const y={flush:I1.Z_SYNC_FLUSH,finishFlush:I1.Z_SYNC_FLUSH};if(P==="gzip"||P==="x-gzip"){_=P1(_,I1.createGunzip(y),(f)=>{if(f)K(f)}),U=new l(_,F),J(U);return}if(P==="deflate"||P==="x-deflate"){const f=P1(D,new i5,(j)=>{if(j)K(j)});f.once("data",(j)=>{if((j[0]&15)===8)_=P1(_,I1.createInflate(),(p)=>{if(p)K(p)});else _=P1(_,I1.createInflateRaw(),(p)=>{if(p)K(p)});U=new l(_,F),J(U)}),f.once("end",()=>{if(!U)U=new l(_,F),J(U)});return}if(P==="br"){_=P1(_,I1.createBrotliDecompress(),(f)=>{if(f)K(f)}),U=new l(_,F),J(U);return}U=new l(_,F),J(U)}),S5(T,W).catch(K)})}var VG=P4(Q8(),1),f4={show:{stdoutEnable:!0,mainProgram:!0,subProgram:!0,date:!0,dateformat:"yyyy-mm-dd HH:MM:ss:l Z",level:!0,ignoreLevels:process.env.ENVIRONMENT!="DEV"?["DEBUG"]:[]},logStorage:{path:"./logs",json:!0,txt:!0,splitBy:"day",stratagy:"batch",batch:6,ignoreLevels:process.env.ENVIRONMENT!="DEV"?["DEBUG"]:[]},logWebook:{enable:!1,url:void 0,form:""}};class X8{formatSettings;storageSettings;webhookSettings;mainProcess;subProcess;processID;colours={FATAL:b0.bgRedBright,FATALRATE:b0.bgRedBright,ERROR:b0.red,WARN:b0.yellow,SUCCESS:b0.green,INFO:b0.blue,DEBUG:b0.magenta};logBuffer=[];webhookBuffer=[];constructor(X,Z,J={}){try{this.mainProcess=X,this.subProcess=Z}catch(K){console.error("There was an issue with initialising process names",K),process.exit(1)}try{this.formatSettings={...f4.show,...J.show}}catch(K){console.error("There was an issue with initialising settings: format Settings",J.show,K),process.exit(1)}try{this.storageSettings={...f4.logStorage,...J.logStorage}}catch(K){console.error("There was an issue with initialising settings: storage Settings",J.logStorage,K),process.exit(1)}try{this.webhookSettings={...f4.logWebook,...J.logWebook}}catch(K){console.error("There was an issue with initialising settings: webhook Settings",J.logWebook,K),process.exit(1)}try{this.success("Initialised Logger"),this.debug("Settings:\n"+JSON.stringify(this.formatSettings,null,4)),this.debug("\n"+JSON.stringify(this.storageSettings,null,4)),this.debug("\n"+JSON.stringify(this.webhookSettings,null,4)+"\n")}catch(K){console.error("There was an issue with logging settings"),process.exit(1)}try{process.on("beforeExit",()=>this.exit("Before exit")),process.on("exit",()=>this.exit("Process exit")),process.on("SIGINT",()=>this.exit("SIGINT")),process.on("SIGTERM",()=>this.exit("SIGTERM")),process.on("uncaughtException",async(K)=>{console.error("Uncaught exception:",K),await this.exit("uncaughtException")})}catch(K){}}sendLog(X,Z,J){try{const K=new Date,W=a(K,this.formatSettings.dateformat),w=this.handleLogDatatype(Z),O=this.handleLogDatatype(J),H=this.formTxtLog(W,w,X,O);if(this.formatSettings.stdoutEnable&&!this.formatSettings.ignoreLevels.includes(X))console.log(this.colours[X](H));if((this.storageSettings.json||this.storageSettings.txt)&&!this.storageSettings.ignoreLevels.includes(X))this.logToFile(K,W,w,X,O,H);if(this.webhookSettings.enable)this.sendWebhook(K,W,w,X,O,H)}catch(K){console.error("There was an issue logging data",K)}}sendWebhook(X,Z,J,K,W,w){if(K=="FATALRATE")return;if(this.webhookSettings.url==null)return;if(this.webhookSettings.form!="discord"){this.error("Currently only discord webhooks have been implemented");return}let O={title:`<${this.mainProcess}.${this.subProcess}> [${K}] ${J}`,description:W!=""?`\`\`\`json\n${W.length>4000?"The data provided is too long for an embed. Check file based or stdout based logs.":W}\n\`\`\``:"",color:null,footer:{text:Z}};if(this.webhookBuffer.push(O),this.webhookBuffer.length>8){this.fatalRate("Webhook Buffer too large to send in one message!",this.webhookBuffer.length),this.webhookBuffer=[];return}if(this.webhookBuffer.length==8)c1(this.webhookSettings.url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:`${this.mainProcess}.${this.subProcess}`,content:null,embeds:this.webhookBuffer,attachments:[]})}).then((H)=>{if(H.status!=204)this.fatalRate("Unexpected response from webhook",{status:H.status,message:H.statusText});this.webhookBuffer=[]}).catch((H)=>{this.fatalRate("Webhook failed to send",{error:H})}),this.webhookBuffer=[]}formTxtLog(X,Z,J,K){let W="";return W+=this.formatSettings.date?`[${X}] `:"",W+=this.formatSettings.mainProgram||this.formatSettings.subProgram?"<":"",W+=this.formatSettings.mainProgram?this.mainProcess:"",W+=this.formatSettings.mainProgram&&this.formatSettings.subProgram?".":"",W+=this.formatSettings.subProgram?this.subProcess:"",W+=this.formatSettings.mainProgram||this.formatSettings.subProgram?"> ":"",W+=this.formatSettings.level?`[${J}] `:"",W+=Z,W+=K!=""?"\nLog Data:\n"+K:"",W}logToFile(X,Z,J,K,W,w){const O={date:X,formattedDate:Z,mainProcess:this.mainProcess,subProcess:this.subProcess,logLevel:K,logMessage:J,logData:W};let H="";try{H=JSON.stringify(O)}catch(I){this.error("Error converting logJSON to string",{error:I,data:O})}if(this.storageSettings.stratagy=="batch"&&this.storageSettings.batch>1){if(this.logBuffer.push({logTXT:w,logJSONString:H})>=this.storageSettings.batch)this.extractBuffer(X)}else{let{dirLocation:I,logLocation:U}=this.generatePaths(X);if(!V0.existsSync(I))V0.mkdirSync(I,{recursive:!0});if(this.storageSettings.txt){const B=V0.createWriteStream(U+"txt.log",{flags:"a"});B.write(w+"\n"),B.end()}if(this.storageSettings.json){const B=V0.createWriteStream(U+"json.log",{flags:"a"});B.write(H+"\n"),B.end()}}}generatePaths(X){let Z="",J=this.storageSettings.path;switch(this.storageSettings.splitBy){case"don't split":J+="/",Z+=J+"logs.";break;case"year":J+="/",Z+=`${a(X,"yyyy")}.`;break;case"month":J+=`/${a(X,"yyyy")}/`,Z+=J+`${a(X,"mm")}.`;break;case"day":J+=`/${a(X,"yyyy/mm")}/`,Z+=J+`${a(X,"dd")}.`;break;case"hour":J+=`/${a(X,"yyyy/mm/dd")}/`,Z+=J+`${a(X,"HH")}.`;break;case"minute":J+=`/${a(X,"yyyy/mm/dd/HH")}/`,Z+=J+`${a(X,"MM")}.`;break;case"second":J+=`/${a(X,"yyyy/mm/dd/HH/MM")}/`,Z+=J+`${a(X,"ss")}.`;break;default:this.error("Logger split by value is invalid",this.storageSettings.splitBy);break}return{dirLocation:J,logLocation:Z}}extractBuffer(X){let{dirLocation:Z,logLocation:J}=this.generatePaths(X);if(!V0.existsSync(Z))V0.mkdirSync(Z,{recursive:!0});let K="",W="",w=this.logBuffer.length;for(let O=0;O<w;O++){let H=this.logBuffer.shift();if(H==null)this.error("Log buffer item is empty whilst trying to read from it");else K+=H.logTXT+"\n",W+=H.logJSONString+"\n"}if(this.storageSettings.txt){const O=V0.createWriteStream(J+"txt.log",{flags:"a"});O.write(K),O.end()}if(this.storageSettings.json){const O=V0.createWriteStream(J+"json.log",{flags:"a"});O.write(W),O.end()}}handleLogDatatype(X){if(X==null)return"";const Z=typeof X;if(Z=="string")return X;if(["bigint","boolean","number","symbol","function"].includes(Z))return X.toString();if(Z=="object")try{return JSON.stringify(X,null,4)}catch(J){return this.error("Datatype of object is not json",{dataType:Z,data:X}),""}return this.error("Datatype Error",{dataType:Z,data:X}),"Datatype error"}fatal(X,Z){this.sendLog("FATAL",X,Z)}fatalRate(X,Z){this.sendLog("FATALRATE",X,Z)}error(X,Z){this.sendLog("ERROR",X,Z)}err=this.error;warn(X,Z){this.sendLog("WARN",X,Z)}success(X,Z){this.sendLog("SUCCESS",X,Z)}info(X,Z){this.sendLog("INFO",X,Z)}log=this.info;debug(X,Z){this.sendLog("DEBUG",X,Z)}async exit(X){if(console.log("Shutting down gracefully with reason: ",X),this.storageSettings.stratagy=="batch"){console.log("Clearing file buffer, length:",this.logBuffer.length);try{const Z=new Date;this.extractBuffer(Z)}catch(Z){console.error("There was an issue clearing the log buffer",Z)}}if(this.webhookSettings.url!=null&&this.webhookBuffer.length>0){console.log("Sending last discord message, length: ",this.webhookBuffer.length);try{await c1(this.webhookSettings.url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:`${this.mainProcess}.${this.subProcess}`,content:null,embeds:this.webhookBuffer,attachments:[]})}).then((Z)=>{if(Z.status!=204)console.error("Unexpected response from webhook",{status:Z.status,message:Z.statusText});this.webhookBuffer=[],console.log("ready to shutdown")}).catch((Z)=>{console.error("Webhook failed to send",{error:Z})})}catch(Z){console.error("There was an issue clearing the webhook buffer")}}setTimeout(()=>{process.exit()},500)}}export{X8 as default};
