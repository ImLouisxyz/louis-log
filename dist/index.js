import{createRequire as rQ} from"node:module";var nQ=Object.create;var{defineProperty:I4,getPrototypeOf:sQ,getOwnPropertyNames:aQ}=Object;var oQ=Object.prototype.hasOwnProperty;var P4=(X,G,J)=>{J=X!=null?nQ(sQ(X)):{};const K=G||!X||!X.__esModule?I4(J,"default",{value:X,enumerable:!0}):J;for(let W of aQ(X))if(!oQ.call(K,W))I4(K,W,{get:()=>X[W],enumerable:!0});return K};var g0=(X,G)=>()=>(G||X((G={exports:{}}).exports,G),G.exports);var tQ=(X,G)=>{for(var J in G)I4(X,J,{get:G[J],enumerable:!0,configurable:!0,set:(K)=>G[J]=()=>K})};var f1=(X,G)=>()=>(X&&(G=X(X=0)),G);var y0=rQ(import.meta.url);var H6=g0((D$,z6)=>{(function(X,G){typeof D$==="object"&&typeof z6!=="undefined"?G(D$):typeof define==="function"&&define.amd?define(["exports"],G):(X=typeof globalThis!=="undefined"?globalThis:X||self,G(X.WebStreamsPolyfill={}))})(D$,function(X){function G(){return}function J($){return typeof $==="object"&&$!==null||typeof $==="function"}const K=G;function W($,Q){try{Object.defineProperty($,"name",{value:Q,configurable:!0})}catch(Z){}}const w=Promise,H=Promise.prototype.then,O=Promise.reject.bind(w);function I($){return new w($)}function B($){return I((Q)=>Q($))}function U($){return O($)}function _($,Q,Z){return H.call($,Q,Z)}function T($,Q,Z){_(_($,Q,Z),void 0,K)}function E($,Q){T($,Q)}function C($,Q){T($,void 0,Q)}function S($,Q,Z){return _($,Q,Z)}function L($){_($,void 0,K)}let F=($)=>{if(typeof queueMicrotask==="function")F=queueMicrotask;else{const Q=B(void 0);F=(Z)=>_(Q,Z)}return F($)};function P($,Q,Z){if(typeof $!=="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call($,Q,Z)}function y($,Q,Z){try{return B(P($,Q,Z))}catch(Y){return U(Y)}}const f=16384;class j{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push($){const Q=this._back;let Z=Q;if(Q._elements.length===f-1)Z={_elements:[],_next:void 0};if(Q._elements.push($),Z!==Q)this._back=Z,Q._next=Z;++this._size}shift(){const $=this._front;let Q=$;const Z=this._cursor;let Y=Z+1;const V=$._elements,z=V[Z];if(Y===f)Q=$._next,Y=0;if(--this._size,this._cursor=Y,$!==Q)this._front=Q;return V[Z]=void 0,z}forEach($){let Q=this._cursor,Z=this._front,Y=Z._elements;while(Q!==Y.length||Z._next!==void 0){if(Q===Y.length){if(Z=Z._next,Y=Z._elements,Q=0,Y.length===0)break}$(Y[Q]),++Q}}peek(){const $=this._front,Q=this._cursor;return $._elements[Q]}}const p=Symbol("[[AbortSteps]]"),C1=Symbol("[[ErrorSteps]]"),A1=Symbol("[[CancelSteps]]"),k$=Symbol("[[PullSteps]]"),L$=Symbol("[[ReleaseSteps]]");function h4($,Q){if($._ownerReadableStream=Q,Q._reader=$,Q._state==="readable")S$($);else if(Q._state==="closed")G8($);else g4($,Q._storedError)}function _$($,Q){const Z=$._ownerReadableStream;return W0(Z,Q)}function I0($){const Q=$._ownerReadableStream;if(Q._state==="readable")v$($,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));else Z8($,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));Q._readableStreamController[L$](),Q._reader=void 0,$._ownerReadableStream=void 0}function d1($){return new TypeError("Cannot "+$+" a stream using a released reader")}function S$($){$._closedPromise=I((Q,Z)=>{$._closedPromise_resolve=Q,$._closedPromise_reject=Z})}function g4($,Q){S$($),v$($,Q)}function G8($){S$($),y4($)}function v$($,Q){if($._closedPromise_reject===void 0)return;L($._closedPromise),$._closedPromise_reject(Q),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0}function Z8($,Q){g4($,Q)}function y4($){if($._closedPromise_resolve===void 0)return;$._closedPromise_resolve(void 0),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0}const b4=Number.isFinite||function($){return typeof $==="number"&&isFinite($)},J8=Math.trunc||function($){return $<0?Math.ceil($):Math.floor($)};function K8($){return typeof $==="object"||typeof $==="function"}function z0($,Q){if($!==void 0&&!K8($))throw new TypeError(`${Q} is not an object.`)}function Q0($,Q){if(typeof $!=="function")throw new TypeError(`${Q} is not a function.`)}function W8($){return typeof $==="object"&&$!==null||typeof $==="function"}function m4($,Q){if(!W8($))throw new TypeError(`${Q} is not an object.`)}function P0($,Q,Z){if($===void 0)throw new TypeError(`Parameter ${Q} is required in '${Z}'.`)}function f$($,Q,Z){if($===void 0)throw new TypeError(`${Q} is required in '${Z}'.`)}function h$($){return Number($)}function u4($){return $===0?0:$}function Y8($){return u4(J8($))}function g$($,Q){const Y=Number.MAX_SAFE_INTEGER;let V=Number($);if(V=u4(V),!b4(V))throw new TypeError(`${Q} is not a finite number`);if(V=Y8(V),V<0||V>Y)throw new TypeError(`${Q} is outside the accepted range of 0 to ${Y}, inclusive`);if(!b4(V)||V===0)return 0;return V}function y$($,Q){if(!v0($))throw new TypeError(`${Q} is not a ReadableStream.`)}function Q1($){return new D0($)}function p4($,Q){$._reader._readRequests.push(Q)}function b$($,Q,Z){const V=$._reader._readRequests.shift();if(Z)V._closeSteps();else V._chunkSteps(Q)}function i1($){return $._reader._readRequests.length}function c4($){const Q=$._reader;if(Q===void 0)return!1;if(!k0(Q))return!1;return!0}class D0{constructor($){if(P0($,1,"ReadableStreamDefaultReader"),y$($,"First parameter"),f0($))throw new TypeError("This stream has already been locked for exclusive reading by another reader");h4(this,$),this._readRequests=new j}get closed(){if(!k0(this))return U(l1("closed"));return this._closedPromise}cancel($=void 0){if(!k0(this))return U(l1("cancel"));if(this._ownerReadableStream===void 0)return U(d1("cancel"));return _$(this,$)}read(){if(!k0(this))return U(l1("read"));if(this._ownerReadableStream===void 0)return U(d1("read from"));let $,Q;const Z=I((V,z)=>{$=V,Q=z});return x1(this,{_chunkSteps:(V)=>$({value:V,done:!1}),_closeSteps:()=>$({value:void 0,done:!0}),_errorSteps:(V)=>Q(V)}),Z}releaseLock(){if(!k0(this))throw l1("releaseLock");if(this._ownerReadableStream===void 0)return;w8(this)}}if(Object.defineProperties(D0.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),W(D0.prototype.cancel,"cancel"),W(D0.prototype.read,"read"),W(D0.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(D0.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});function k0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readRequests"))return!1;return $ instanceof D0}function x1($,Q){const Z=$._ownerReadableStream;if(Z._disturbed=!0,Z._state==="closed")Q._closeSteps();else if(Z._state==="errored")Q._errorSteps(Z._storedError);else Z._readableStreamController[k$](Q)}function w8($){I0($);const Q=new TypeError("Reader was released");d4($,Q)}function d4($,Q){const Z=$._readRequests;$._readRequests=new j,Z.forEach((Y)=>{Y._errorSteps(Q)})}function l1($){return new TypeError(`ReadableStreamDefaultReader.prototype.${$} can only be used on a ReadableStreamDefaultReader`)}const V8=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);class m${constructor($,Q){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=$,this._preventCancel=Q}next(){const $=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?S(this._ongoingPromise,$,$):$(),this._ongoingPromise}return($){const Q=()=>this._returnSteps($);return this._ongoingPromise?S(this._ongoingPromise,Q,Q):Q()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const $=this._reader;let Q,Z;const Y=I((z,M)=>{Q=z,Z=M});return x1($,{_chunkSteps:(z)=>{this._ongoingPromise=void 0,F(()=>Q({value:z,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,I0($),Q({value:void 0,done:!0})},_errorSteps:(z)=>{this._ongoingPromise=void 0,this._isFinished=!0,I0($),Z(z)}}),Y}_returnSteps($){if(this._isFinished)return Promise.resolve({value:$,done:!0});this._isFinished=!0;const Q=this._reader;if(!this._preventCancel){const Z=_$(Q,$);return I0(Q),S(Z,()=>({value:$,done:!0}))}return I0(Q),B({value:$,done:!0})}}const i4={next(){if(!l4(this))return U(n4("next"));return this._asyncIteratorImpl.next()},return($){if(!l4(this))return U(n4("return"));return this._asyncIteratorImpl.return($)}};Object.setPrototypeOf(i4,V8);function z8($,Q){const Z=Q1($),Y=new m$(Z,Q),V=Object.create(i4);return V._asyncIteratorImpl=Y,V}function l4($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_asyncIteratorImpl"))return!1;try{return $._asyncIteratorImpl instanceof m$}catch(Q){return!1}}function n4($){return new TypeError(`ReadableStreamAsyncIterator.${$} can only be used on a ReadableSteamAsyncIterator`)}const s4=Number.isNaN||function($){return $!==$};var u$,p$,c$;function E1($){return $.slice()}function a4($,Q,Z,Y,V){new Uint8Array($).set(new Uint8Array(Z,Y,V),Q)}let C0=($)=>{if(typeof $.transfer==="function")C0=(Q)=>Q.transfer();else if(typeof structuredClone==="function")C0=(Q)=>structuredClone(Q,{transfer:[Q]});else C0=(Q)=>Q;return C0($)},L0=($)=>{if(typeof $.detached==="boolean")L0=(Q)=>Q.detached;else L0=(Q)=>Q.byteLength===0;return L0($)};function o4($,Q,Z){if($.slice)return $.slice(Q,Z);const Y=Z-Q,V=new ArrayBuffer(Y);return a4(V,0,$,Q,Y),V}function n1($,Q){const Z=$[Q];if(Z===void 0||Z===null)return;if(typeof Z!=="function")throw new TypeError(`${String(Q)} is not a function`);return Z}function H8($){const Q={[Symbol.iterator]:()=>$.iterator},Z=async function*(){return yield*Q}(),Y=Z.next;return{iterator:Z,nextMethod:Y,done:!1}}const d$=(c$=(u$=Symbol.asyncIterator)!==null&&u$!==void 0?u$:(p$=Symbol.for)===null||p$===void 0?void 0:p$.call(Symbol,"Symbol.asyncIterator"))!==null&&c$!==void 0?c$:"@@asyncIterator";function t4($,Q="sync",Z){if(Z===void 0)if(Q==="async"){if(Z=n1($,d$),Z===void 0){const z=n1($,Symbol.iterator),M=t4($,"sync",z);return H8(M)}}else Z=n1($,Symbol.iterator);if(Z===void 0)throw new TypeError("The object is not iterable");const Y=P(Z,$,[]);if(!J(Y))throw new TypeError("The iterator method must return an object");const V=Y.next;return{iterator:Y,nextMethod:V,done:!1}}function O8($){const Q=P($.nextMethod,$.iterator,[]);if(!J(Q))throw new TypeError("The iterator.next() method must return an object");return Q}function M8($){return Boolean($.done)}function B8($){return $.value}function U8($){if(typeof $!=="number")return!1;if(s4($))return!1;if($<0)return!1;return!0}function r4($){const Q=o4($.buffer,$.byteOffset,$.byteOffset+$.byteLength);return new Uint8Array(Q)}function i$($){const Q=$._queue.shift();if($._queueTotalSize-=Q.size,$._queueTotalSize<0)$._queueTotalSize=0;return Q.value}function l$($,Q,Z){if(!U8(Z)||Z===Infinity)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");$._queue.push({value:Q,size:Z}),$._queueTotalSize+=Z}function I8($){return $._queue.peek().value}function _0($){$._queue=new j,$._queueTotalSize=0}function e4($){return $===DataView}function P8($){return e4($.constructor)}function D8($){if(e4($))return 1;return $.BYTES_PER_ELEMENT}class S0{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!n$(this))throw r$("view");return this._view}respond($){if(!n$(this))throw r$("respond");if(P0($,1,"respond"),$=g$($,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(L0(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");t1(this._associatedReadableByteStreamController,$)}respondWithNewView($){if(!n$(this))throw r$("respondWithNewView");if(P0($,1,"respondWithNewView"),!ArrayBuffer.isView($))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(L0($.buffer))throw new TypeError("The given view\'s buffer has been detached and so cannot be used as a response");r1(this._associatedReadableByteStreamController,$)}}if(Object.defineProperties(S0.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),W(S0.prototype.respond,"respond"),W(S0.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(S0.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class H0{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!c0(this))throw N1("byobRequest");return t$(this)}get desiredSize(){if(!c0(this))throw N1("desiredSize");return w5(this)}close(){if(!c0(this))throw N1("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const $=this._controlledReadableByteStream._state;if($!=="readable")throw new TypeError(`The stream (in ${$} state) is not in the readable state and cannot be closed`);F1(this)}enqueue($){if(!c0(this))throw N1("enqueue");if(P0($,1,"enqueue"),!ArrayBuffer.isView($))throw new TypeError("chunk must be an array buffer view");if($.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if($.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const Q=this._controlledReadableByteStream._state;if(Q!=="readable")throw new TypeError(`The stream (in ${Q} state) is not in the readable state and cannot be enqueued to`);o1(this,$)}error($=void 0){if(!c0(this))throw N1("error");X0(this,$)}[A1]($){$5(this),_0(this);const Q=this._cancelAlgorithm($);return a1(this),Q}[k$]($){const Q=this._controlledReadableByteStream;if(this._queueTotalSize>0){Y5(this,$);return}const Z=this._autoAllocateChunkSize;if(Z!==void 0){let Y;try{Y=new ArrayBuffer(Z)}catch(z){$._errorSteps(z);return}const V={buffer:Y,bufferByteLength:Z,byteOffset:0,byteLength:Z,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(V)}p4(Q,$),d0(this)}[L$](){if(this._pendingPullIntos.length>0){const $=this._pendingPullIntos.peek();$.readerType="none",this._pendingPullIntos=new j,this._pendingPullIntos.push($)}}}if(Object.defineProperties(H0.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),W(H0.prototype.close,"close"),W(H0.prototype.enqueue,"enqueue"),W(H0.prototype.error,"error"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(H0.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});function c0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledReadableByteStream"))return!1;return $ instanceof H0}function n$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_associatedReadableByteStreamController"))return!1;return $ instanceof S0}function d0($){if(!F8($))return;if($._pulling){$._pullAgain=!0;return}$._pulling=!0;const Z=$._pullAlgorithm();T(Z,()=>{if($._pulling=!1,$._pullAgain)$._pullAgain=!1,d0($);return null},(Y)=>{return X0($,Y),null})}function $5($){a$($),$._pendingPullIntos=new j}function s$($,Q){let Z=!1;if($._state==="closed")Z=!0;const Y=Q5(Q);if(Q.readerType==="default")b$($,Y,Z);else k8($,Y,Z)}function Q5($){const{bytesFilled:Q,elementSize:Z}=$;return new $.viewConstructor($.buffer,$.byteOffset,Q/Z)}function s1($,Q,Z,Y){$._queue.push({buffer:Q,byteOffset:Z,byteLength:Y}),$._queueTotalSize+=Y}function X5($,Q,Z,Y){let V;try{V=o4(Q,Z,Z+Y)}catch(z){throw X0($,z),z}s1($,V,0,Y)}function G5($,Q){if(Q.bytesFilled>0)X5($,Q.buffer,Q.byteOffset,Q.bytesFilled);X1($)}function Z5($,Q){const Z=Math.min($._queueTotalSize,Q.byteLength-Q.bytesFilled),Y=Q.bytesFilled+Z;let V=Z,z=!1;const M=Y%Q.elementSize,D=Y-M;if(D>=Q.minimumFill)V=D-Q.bytesFilled,z=!0;const A=$._queue;while(V>0){const N=A.peek(),q=Math.min(V,N.byteLength),R=Q.byteOffset+Q.bytesFilled;if(a4(Q.buffer,R,N.buffer,N.byteOffset,q),N.byteLength===q)A.shift();else N.byteOffset+=q,N.byteLength-=q;$._queueTotalSize-=q,J5($,q,Q),V-=q}return z}function J5($,Q,Z){Z.bytesFilled+=Q}function K5($){if($._queueTotalSize===0&&$._closeRequested)a1($),L1($._controlledReadableByteStream);else d0($)}function a$($){if($._byobRequest===null)return;$._byobRequest._associatedReadableByteStreamController=void 0,$._byobRequest._view=null,$._byobRequest=null}function o$($){while($._pendingPullIntos.length>0){if($._queueTotalSize===0)return;const Q=$._pendingPullIntos.peek();if(Z5($,Q))X1($),s$($._controlledReadableByteStream,Q)}}function C8($){const Q=$._controlledReadableByteStream._reader;while(Q._readRequests.length>0){if($._queueTotalSize===0)return;const Z=Q._readRequests.shift();Y5($,Z)}}function A8($,Q,Z,Y){const V=$._controlledReadableByteStream,z=Q.constructor,M=D8(z),{byteOffset:D,byteLength:A}=Q,N=Z*M;let q;try{q=C0(Q.buffer)}catch(v){Y._errorSteps(v);return}const R={buffer:q,bufferByteLength:q.byteLength,byteOffset:D,byteLength:A,bytesFilled:0,minimumFill:N,elementSize:M,viewConstructor:z,readerType:"byob"};if($._pendingPullIntos.length>0){$._pendingPullIntos.push(R),H5(V,Y);return}if(V._state==="closed"){const v=new z(R.buffer,R.byteOffset,0);Y._closeSteps(v);return}if($._queueTotalSize>0){if(Z5($,R)){const v=Q5(R);K5($),Y._chunkSteps(v);return}if($._closeRequested){const v=new TypeError("Insufficient bytes to fill elements in the given buffer");X0($,v),Y._errorSteps(v);return}}$._pendingPullIntos.push(R),H5(V,Y),d0($)}function x8($,Q){if(Q.readerType==="none")X1($);const Z=$._controlledReadableByteStream;if(e$(Z))while(O5(Z)>0){const Y=X1($);s$(Z,Y)}}function E8($,Q,Z){if(J5($,Q,Z),Z.readerType==="none"){G5($,Z),o$($);return}if(Z.bytesFilled<Z.minimumFill)return;X1($);const Y=Z.bytesFilled%Z.elementSize;if(Y>0){const V=Z.byteOffset+Z.bytesFilled;X5($,Z.buffer,V-Y,Y)}Z.bytesFilled-=Y,s$($._controlledReadableByteStream,Z),o$($)}function W5($,Q){const Z=$._pendingPullIntos.peek();if(a$($),$._controlledReadableByteStream._state==="closed")x8($,Z);else E8($,Q,Z);d0($)}function X1($){return $._pendingPullIntos.shift()}function F8($){const Q=$._controlledReadableByteStream;if(Q._state!=="readable")return!1;if($._closeRequested)return!1;if(!$._started)return!1;if(c4(Q)&&i1(Q)>0)return!0;if(e$(Q)&&O5(Q)>0)return!0;if(w5($)>0)return!0;return!1}function a1($){$._pullAlgorithm=void 0,$._cancelAlgorithm=void 0}function F1($){const Q=$._controlledReadableByteStream;if($._closeRequested||Q._state!=="readable")return;if($._queueTotalSize>0){$._closeRequested=!0;return}if($._pendingPullIntos.length>0){const Z=$._pendingPullIntos.peek();if(Z.bytesFilled%Z.elementSize!==0){const Y=new TypeError("Insufficient bytes to fill elements in the given buffer");throw X0($,Y),Y}}a1($),L1(Q)}function o1($,Q){const Z=$._controlledReadableByteStream;if($._closeRequested||Z._state!=="readable")return;const{buffer:Y,byteOffset:V,byteLength:z}=Q;if(L0(Y))throw new TypeError("chunk\'s buffer is detached and so cannot be enqueued");const M=C0(Y);if($._pendingPullIntos.length>0){const D=$._pendingPullIntos.peek();if(L0(D.buffer))throw new TypeError("The BYOB request\'s buffer has been detached and so cannot be filled with an enqueued chunk");if(a$($),D.buffer=C0(D.buffer),D.readerType==="none")G5($,D)}if(c4(Z))if(C8($),i1(Z)===0)s1($,M,V,z);else{if($._pendingPullIntos.length>0)X1($);const D=new Uint8Array(M,V,z);b$(Z,D,!1)}else if(e$(Z))s1($,M,V,z),o$($);else s1($,M,V,z);d0($)}function X0($,Q){const Z=$._controlledReadableByteStream;if(Z._state!=="readable")return;$5($),_0($),a1($),g5(Z,Q)}function Y5($,Q){const Z=$._queue.shift();$._queueTotalSize-=Z.byteLength,K5($);const Y=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength);Q._chunkSteps(Y)}function t$($){if($._byobRequest===null&&$._pendingPullIntos.length>0){const Q=$._pendingPullIntos.peek(),Z=new Uint8Array(Q.buffer,Q.byteOffset+Q.bytesFilled,Q.byteLength-Q.bytesFilled),Y=Object.create(S0.prototype);q8(Y,$,Z),$._byobRequest=Y}return $._byobRequest}function w5($){const Q=$._controlledReadableByteStream._state;if(Q==="errored")return null;if(Q==="closed")return 0;return $._strategyHWM-$._queueTotalSize}function t1($,Q){const Z=$._pendingPullIntos.peek();if($._controlledReadableByteStream._state==="closed"){if(Q!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(Q===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(Z.bytesFilled+Q>Z.byteLength)throw new RangeError("bytesWritten out of range")}Z.buffer=C0(Z.buffer),W5($,Q)}function r1($,Q){const Z=$._pendingPullIntos.peek();if($._controlledReadableByteStream._state==="closed"){if(Q.byteLength!==0)throw new TypeError("The view\'s length must be 0 when calling respondWithNewView() on a closed stream")}else if(Q.byteLength===0)throw new TypeError("The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream");if(Z.byteOffset+Z.bytesFilled!==Q.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(Z.bufferByteLength!==Q.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(Z.bytesFilled+Q.byteLength>Z.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const V=Q.byteLength;Z.buffer=C0(Q.buffer),W5($,V)}function V5($,Q,Z,Y,V,z,M){Q._controlledReadableByteStream=$,Q._pullAgain=!1,Q._pulling=!1,Q._byobRequest=null,Q._queue=Q._queueTotalSize=void 0,_0(Q),Q._closeRequested=!1,Q._started=!1,Q._strategyHWM=z,Q._pullAlgorithm=Y,Q._cancelAlgorithm=V,Q._autoAllocateChunkSize=M,Q._pendingPullIntos=new j,$._readableStreamController=Q;const D=Z();T(B(D),()=>{return Q._started=!0,d0(Q),null},(A)=>{return X0(Q,A),null})}function N8($,Q,Z){const Y=Object.create(H0.prototype);let V,z,M;if(Q.start!==void 0)V=()=>Q.start(Y);else V=()=>{return};if(Q.pull!==void 0)z=()=>Q.pull(Y);else z=()=>B(void 0);if(Q.cancel!==void 0)M=(A)=>Q.cancel(A);else M=()=>B(void 0);const D=Q.autoAllocateChunkSize;if(D===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");V5($,Y,V,z,M,Z,D)}function q8($,Q,Z){$._associatedReadableByteStreamController=Q,$._view=Z}function r$($){return new TypeError(`ReadableStreamBYOBRequest.prototype.${$} can only be used on a ReadableStreamBYOBRequest`)}function N1($){return new TypeError(`ReadableByteStreamController.prototype.${$} can only be used on a ReadableByteStreamController`)}function j8($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.mode;return{mode:Z===void 0?void 0:T8(Z,`${Q} has member 'mode' that`)}}function T8($,Q){if($=`${$}`,$!=="byob")throw new TypeError(`${Q} '${$}' is not a valid enumeration value for ReadableStreamReaderMode`);return $}function R8($,Q){var Z;z0($,Q);const Y=(Z=$===null||$===void 0?void 0:$.min)!==null&&Z!==void 0?Z:1;return{min:g$(Y,`${Q} has member 'min' that`)}}function z5($){return new A0($)}function H5($,Q){$._reader._readIntoRequests.push(Q)}function k8($,Q,Z){const V=$._reader._readIntoRequests.shift();if(Z)V._closeSteps(Q);else V._chunkSteps(Q)}function O5($){return $._reader._readIntoRequests.length}function e$($){const Q=$._reader;if(Q===void 0)return!1;if(!i0(Q))return!1;return!0}class A0{constructor($){if(P0($,1,"ReadableStreamBYOBReader"),y$($,"First parameter"),f0($))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!c0($._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");h4(this,$),this._readIntoRequests=new j}get closed(){if(!i0(this))return U(e1("closed"));return this._closedPromise}cancel($=void 0){if(!i0(this))return U(e1("cancel"));if(this._ownerReadableStream===void 0)return U(d1("cancel"));return _$(this,$)}read($,Q={}){if(!i0(this))return U(e1("read"));if(!ArrayBuffer.isView($))return U(new TypeError("view must be an array buffer view"));if($.byteLength===0)return U(new TypeError("view must have non-zero byteLength"));if($.buffer.byteLength===0)return U(new TypeError("view's buffer must have non-zero byteLength"));if(L0($.buffer))return U(new TypeError("view\'s buffer has been detached"));let Z;try{Z=R8(Q,"options")}catch(A){return U(A)}const Y=Z.min;if(Y===0)return U(new TypeError("options.min must be greater than 0"));if(!P8($)){if(Y>$.length)return U(new RangeError("options.min must be less than or equal to view\'s length"))}else if(Y>$.byteLength)return U(new RangeError("options.min must be less than or equal to view\'s byteLength"));if(this._ownerReadableStream===void 0)return U(d1("read from"));let V,z;const M=I((A,N)=>{V=A,z=N});return M5(this,$,Y,{_chunkSteps:(A)=>V({value:A,done:!1}),_closeSteps:(A)=>V({value:A,done:!0}),_errorSteps:(A)=>z(A)}),M}releaseLock(){if(!i0(this))throw e1("releaseLock");if(this._ownerReadableStream===void 0)return;L8(this)}}if(Object.defineProperties(A0.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),W(A0.prototype.cancel,"cancel"),W(A0.prototype.read,"read"),W(A0.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(A0.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});function i0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readIntoRequests"))return!1;return $ instanceof A0}function M5($,Q,Z,Y){const V=$._ownerReadableStream;if(V._disturbed=!0,V._state==="errored")Y._errorSteps(V._storedError);else A8(V._readableStreamController,Q,Z,Y)}function L8($){I0($);const Q=new TypeError("Reader was released");B5($,Q)}function B5($,Q){const Z=$._readIntoRequests;$._readIntoRequests=new j,Z.forEach((Y)=>{Y._errorSteps(Q)})}function e1($){return new TypeError(`ReadableStreamBYOBReader.prototype.${$} can only be used on a ReadableStreamBYOBReader`)}function q1($,Q){const{highWaterMark:Z}=$;if(Z===void 0)return Q;if(s4(Z)||Z<0)throw new RangeError("Invalid highWaterMark");return Z}function $$($){const{size:Q}=$;if(!Q)return()=>1;return Q}function Q$($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.highWaterMark,Y=$===null||$===void 0?void 0:$.size;return{highWaterMark:Z===void 0?void 0:h$(Z),size:Y===void 0?void 0:_8(Y,`${Q} has member 'size' that`)}}function _8($,Q){return Q0($,Q),(Z)=>h$($(Z))}function S8($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.abort,Y=$===null||$===void 0?void 0:$.close,V=$===null||$===void 0?void 0:$.start,z=$===null||$===void 0?void 0:$.type,M=$===null||$===void 0?void 0:$.write;return{abort:Z===void 0?void 0:v8(Z,$,`${Q} has member 'abort' that`),close:Y===void 0?void 0:f8(Y,$,`${Q} has member 'close' that`),start:V===void 0?void 0:h8(V,$,`${Q} has member 'start' that`),write:M===void 0?void 0:g8(M,$,`${Q} has member 'write' that`),type:z}}function v8($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function f8($,Q,Z){return Q0($,Z),()=>y($,Q,[])}function h8($,Q,Z){return Q0($,Z),(Y)=>P($,Q,[Y])}function g8($,Q,Z){return Q0($,Z),(Y,V)=>y($,Q,[Y,V])}function U5($,Q){if(!G1($))throw new TypeError(`${Q} is not a WritableStream.`)}function y8($){if(typeof $!=="object"||$===null)return!1;try{return typeof $.aborted==="boolean"}catch(Q){return!1}}const b8=typeof AbortController==="function";function m8(){if(b8)return new AbortController;return}class x0{constructor($={},Q={}){if($===void 0)$=null;else m4($,"First parameter");const Z=Q$(Q,"Second parameter"),Y=S8($,"First parameter");if(P5(this),Y.type!==void 0)throw new RangeError("Invalid type is specified");const z=$$(Z),M=q1(Z,1);$Q(this,Y,M,z)}get locked(){if(!G1(this))throw K$("locked");return Z1(this)}abort($=void 0){if(!G1(this))return U(K$("abort"));if(Z1(this))return U(new TypeError("Cannot abort a stream that already has a writer"));return X$(this,$)}close(){if(!G1(this))return U(K$("close"));if(Z1(this))return U(new TypeError("Cannot close a stream that already has a writer"));if(O0(this))return U(new TypeError("Cannot close an already-closing stream"));return D5(this)}getWriter(){if(!G1(this))throw K$("getWriter");return I5(this)}}if(Object.defineProperties(x0.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),W(x0.prototype.abort,"abort"),W(x0.prototype.close,"close"),W(x0.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(x0.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});function I5($){return new M0($)}function u8($,Q,Z,Y,V=1,z=()=>1){const M=Object.create(x0.prototype);P5(M);const D=Object.create(n0.prototype);return N5(M,D,$,Q,Z,Y,V,z),M}function P5($){$._state="writable",$._storedError=void 0,$._writer=void 0,$._writableStreamController=void 0,$._writeRequests=new j,$._inFlightWriteRequest=void 0,$._closeRequest=void 0,$._inFlightCloseRequest=void 0,$._pendingAbortRequest=void 0,$._backpressure=!1}function G1($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_writableStreamController"))return!1;return $ instanceof x0}function Z1($){if($._writer===void 0)return!1;return!0}function X$($,Q){var Z;if($._state==="closed"||$._state==="errored")return B(void 0);$._writableStreamController._abortReason=Q,(Z=$._writableStreamController._abortController)===null||Z===void 0||Z.abort(Q);const Y=$._state;if(Y==="closed"||Y==="errored")return B(void 0);if($._pendingAbortRequest!==void 0)return $._pendingAbortRequest._promise;let V=!1;if(Y==="erroring")V=!0,Q=void 0;const z=I((M,D)=>{$._pendingAbortRequest={_promise:void 0,_resolve:M,_reject:D,_reason:Q,_wasAlreadyErroring:V}});if($._pendingAbortRequest._promise=z,!V)Q4($,Q);return z}function D5($){const Q=$._state;if(Q==="closed"||Q==="errored")return U(new TypeError(`The stream (in ${Q} state) is not in the writable state and cannot be closed`));const Z=I((V,z)=>{const M={_resolve:V,_reject:z};$._closeRequest=M}),Y=$._writer;if(Y!==void 0&&$._backpressure&&Q==="writable")w4(Y);return QQ($._writableStreamController),Z}function p8($){return I((Z,Y)=>{const V={_resolve:Z,_reject:Y};$._writeRequests.push(V)})}function $4($,Q){if($._state==="writable"){Q4($,Q);return}X4($)}function Q4($,Q){const Z=$._writableStreamController;$._state="erroring",$._storedError=Q;const Y=$._writer;if(Y!==void 0)A5(Y,Q);if(!n8($)&&Z._started)X4($)}function X4($){$._state="errored",$._writableStreamController[C1]();const Q=$._storedError;if($._writeRequests.forEach((V)=>{V._reject(Q)}),$._writeRequests=new j,$._pendingAbortRequest===void 0){G$($);return}const Z=$._pendingAbortRequest;if($._pendingAbortRequest=void 0,Z._wasAlreadyErroring){Z._reject(Q),G$($);return}const Y=$._writableStreamController[p](Z._reason);T(Y,()=>{return Z._resolve(),G$($),null},(V)=>{return Z._reject(V),G$($),null})}function c8($){$._inFlightWriteRequest._resolve(void 0),$._inFlightWriteRequest=void 0}function d8($,Q){$._inFlightWriteRequest._reject(Q),$._inFlightWriteRequest=void 0,$4($,Q)}function i8($){if($._inFlightCloseRequest._resolve(void 0),$._inFlightCloseRequest=void 0,$._state==="erroring"){if($._storedError=void 0,$._pendingAbortRequest!==void 0)$._pendingAbortRequest._resolve(),$._pendingAbortRequest=void 0}$._state="closed";const Z=$._writer;if(Z!==void 0)R5(Z)}function l8($,Q){if($._inFlightCloseRequest._reject(Q),$._inFlightCloseRequest=void 0,$._pendingAbortRequest!==void 0)$._pendingAbortRequest._reject(Q),$._pendingAbortRequest=void 0;$4($,Q)}function O0($){if($._closeRequest===void 0&&$._inFlightCloseRequest===void 0)return!1;return!0}function n8($){if($._inFlightWriteRequest===void 0&&$._inFlightCloseRequest===void 0)return!1;return!0}function s8($){$._inFlightCloseRequest=$._closeRequest,$._closeRequest=void 0}function a8($){$._inFlightWriteRequest=$._writeRequests.shift()}function G$($){if($._closeRequest!==void 0)$._closeRequest._reject($._storedError),$._closeRequest=void 0;const Q=$._writer;if(Q!==void 0)W4(Q,$._storedError)}function G4($,Q){const Z=$._writer;if(Z!==void 0&&Q!==$._backpressure)if(Q)YQ(Z);else w4(Z);$._backpressure=Q}class M0{constructor($){if(P0($,1,"WritableStreamDefaultWriter"),U5($,"First parameter"),Z1($))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=$,$._writer=this;const Q=$._state;if(Q==="writable"){if(!O0($)&&$._backpressure)Y$(this);else k5(this);W$(this)}else if(Q==="erroring")Y4(this,$._storedError),W$(this);else if(Q==="closed")k5(this),KQ(this);else{const Z=$._storedError;Y4(this,Z),T5(this,Z)}}get closed(){if(!l0(this))return U(s0("closed"));return this._closedPromise}get desiredSize(){if(!l0(this))throw s0("desiredSize");if(this._ownerWritableStream===void 0)throw T1("desiredSize");return e8(this)}get ready(){if(!l0(this))return U(s0("ready"));return this._readyPromise}abort($=void 0){if(!l0(this))return U(s0("abort"));if(this._ownerWritableStream===void 0)return U(T1("abort"));return o8(this,$)}close(){if(!l0(this))return U(s0("close"));const $=this._ownerWritableStream;if($===void 0)return U(T1("close"));if(O0($))return U(new TypeError("Cannot close an already-closing stream"));return C5(this)}releaseLock(){if(!l0(this))throw s0("releaseLock");if(this._ownerWritableStream===void 0)return;x5(this)}write($=void 0){if(!l0(this))return U(s0("write"));if(this._ownerWritableStream===void 0)return U(T1("write to"));return E5(this,$)}}if(Object.defineProperties(M0.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),W(M0.prototype.abort,"abort"),W(M0.prototype.close,"close"),W(M0.prototype.releaseLock,"releaseLock"),W(M0.prototype.write,"write"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(M0.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});function l0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_ownerWritableStream"))return!1;return $ instanceof M0}function o8($,Q){const Z=$._ownerWritableStream;return X$(Z,Q)}function C5($){const Q=$._ownerWritableStream;return D5(Q)}function t8($){const Q=$._ownerWritableStream,Z=Q._state;if(O0(Q)||Z==="closed")return B(void 0);if(Z==="errored")return U(Q._storedError);return C5($)}function r8($,Q){if($._closedPromiseState==="pending")W4($,Q);else WQ($,Q)}function A5($,Q){if($._readyPromiseState==="pending")L5($,Q);else wQ($,Q)}function e8($){const Q=$._ownerWritableStream,Z=Q._state;if(Z==="errored"||Z==="erroring")return null;if(Z==="closed")return 0;return q5(Q._writableStreamController)}function x5($){const Q=$._ownerWritableStream,Z=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");A5($,Z),r8($,Z),Q._writer=void 0,$._ownerWritableStream=void 0}function E5($,Q){const Z=$._ownerWritableStream,Y=Z._writableStreamController,V=XQ(Y,Q);if(Z!==$._ownerWritableStream)return U(T1("write to"));const z=Z._state;if(z==="errored")return U(Z._storedError);if(O0(Z)||z==="closed")return U(new TypeError("The stream is closing or closed and cannot be written to"));if(z==="erroring")return U(Z._storedError);const M=p8(Z);return GQ(Y,Q,V),M}const F5={};class n0{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!Z4(this))throw K4("abortReason");return this._abortReason}get signal(){if(!Z4(this))throw K4("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error($=void 0){if(!Z4(this))throw K4("error");if(this._controlledWritableStream._state!=="writable")return;j5(this,$)}[p]($){const Q=this._abortAlgorithm($);return Z$(this),Q}[C1](){_0(this)}}if(Object.defineProperties(n0.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(n0.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});function Z4($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledWritableStream"))return!1;return $ instanceof n0}function N5($,Q,Z,Y,V,z,M,D){Q._controlledWritableStream=$,$._writableStreamController=Q,Q._queue=void 0,Q._queueTotalSize=void 0,_0(Q),Q._abortReason=void 0,Q._abortController=m8(),Q._started=!1,Q._strategySizeAlgorithm=D,Q._strategyHWM=M,Q._writeAlgorithm=Y,Q._closeAlgorithm=V,Q._abortAlgorithm=z;const A=J4(Q);G4($,A);const N=Z(),q=B(N);T(q,()=>{return Q._started=!0,J$(Q),null},(R)=>{return Q._started=!0,$4($,R),null})}function $Q($,Q,Z,Y){const V=Object.create(n0.prototype);let z,M,D,A;if(Q.start!==void 0)z=()=>Q.start(V);else z=()=>{return};if(Q.write!==void 0)M=(N)=>Q.write(N,V);else M=()=>B(void 0);if(Q.close!==void 0)D=()=>Q.close();else D=()=>B(void 0);if(Q.abort!==void 0)A=(N)=>Q.abort(N);else A=()=>B(void 0);N5($,V,z,M,D,A,Z,Y)}function Z$($){$._writeAlgorithm=void 0,$._closeAlgorithm=void 0,$._abortAlgorithm=void 0,$._strategySizeAlgorithm=void 0}function QQ($){l$($,F5,0),J$($)}function XQ($,Q){try{return $._strategySizeAlgorithm(Q)}catch(Z){return j1($,Z),1}}function q5($){return $._strategyHWM-$._queueTotalSize}function GQ($,Q,Z){try{l$($,Q,Z)}catch(V){j1($,V);return}const Y=$._controlledWritableStream;if(!O0(Y)&&Y._state==="writable"){const V=J4($);G4(Y,V)}J$($)}function J$($){const Q=$._controlledWritableStream;if(!$._started)return;if(Q._inFlightWriteRequest!==void 0)return;if(Q._state==="erroring"){X4(Q);return}if($._queue.length===0)return;const Y=I8($);if(Y===F5)ZQ($);else JQ($,Y)}function j1($,Q){if($._controlledWritableStream._state==="writable")j5($,Q)}function ZQ($){const Q=$._controlledWritableStream;s8(Q),i$($);const Z=$._closeAlgorithm();Z$($),T(Z,()=>{return i8(Q),null},(Y)=>{return l8(Q,Y),null})}function JQ($,Q){const Z=$._controlledWritableStream;a8(Z);const Y=$._writeAlgorithm(Q);T(Y,()=>{c8(Z);const V=Z._state;if(i$($),!O0(Z)&&V==="writable"){const z=J4($);G4(Z,z)}return J$($),null},(V)=>{if(Z._state==="writable")Z$($);return d8(Z,V),null})}function J4($){return q5($)<=0}function j5($,Q){const Z=$._controlledWritableStream;Z$($),Q4(Z,Q)}function K$($){return new TypeError(`WritableStream.prototype.${$} can only be used on a WritableStream`)}function K4($){return new TypeError(`WritableStreamDefaultController.prototype.${$} can only be used on a WritableStreamDefaultController`)}function s0($){return new TypeError(`WritableStreamDefaultWriter.prototype.${$} can only be used on a WritableStreamDefaultWriter`)}function T1($){return new TypeError("Cannot "+$+" a stream using a released writer")}function W$($){$._closedPromise=I((Q,Z)=>{$._closedPromise_resolve=Q,$._closedPromise_reject=Z,$._closedPromiseState="pending"})}function T5($,Q){W$($),W4($,Q)}function KQ($){W$($),R5($)}function W4($,Q){if($._closedPromise_reject===void 0)return;L($._closedPromise),$._closedPromise_reject(Q),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0,$._closedPromiseState="rejected"}function WQ($,Q){T5($,Q)}function R5($){if($._closedPromise_resolve===void 0)return;$._closedPromise_resolve(void 0),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0,$._closedPromiseState="resolved"}function Y$($){$._readyPromise=I((Q,Z)=>{$._readyPromise_resolve=Q,$._readyPromise_reject=Z}),$._readyPromiseState="pending"}function Y4($,Q){Y$($),L5($,Q)}function k5($){Y$($),w4($)}function L5($,Q){if($._readyPromise_reject===void 0)return;L($._readyPromise),$._readyPromise_reject(Q),$._readyPromise_resolve=void 0,$._readyPromise_reject=void 0,$._readyPromiseState="rejected"}function YQ($){Y$($)}function wQ($,Q){Y4($,Q)}function w4($){if($._readyPromise_resolve===void 0)return;$._readyPromise_resolve(void 0),$._readyPromise_resolve=void 0,$._readyPromise_reject=void 0,$._readyPromiseState="fulfilled"}function VQ(){if(typeof globalThis!=="undefined")return globalThis;else if(typeof self!=="undefined")return self;else if(typeof global!=="undefined")return global;return}const V4=VQ();function zQ($){if(!(typeof $==="function"||typeof $==="object"))return!1;if($.name!=="DOMException")return!1;try{return new $,!0}catch(Q){return!1}}function HQ(){const $=V4===null||V4===void 0?void 0:V4.DOMException;return zQ($)?$:void 0}function OQ(){const $=function Q(Z,Y){if(this.message=Z||"",this.name=Y||"Error",Error.captureStackTrace)Error.captureStackTrace(this,this.constructor)};return W($,"DOMException"),$.prototype=Object.create(Error.prototype),Object.defineProperty($.prototype,"constructor",{value:$,writable:!0,configurable:!0}),$}const MQ=HQ()||OQ();function _5($,Q,Z,Y,V,z){const M=Q1($),D=I5(Q);$._disturbed=!0;let A=!1,N=B(void 0);return I((q,R)=>{let v;if(z!==void 0){if(v=()=>{const x=z.reason!==void 0?z.reason:new MQ("Aborted","AbortError"),k=[];if(!Y)k.push(()=>{if(Q._state==="writable")return X$(Q,x);return B(void 0)});if(!V)k.push(()=>{if($._state==="readable")return W0($,x);return B(void 0)});n(()=>Promise.all(k.map((h)=>h())),!0,x)},z.aborted){v();return}z.addEventListener("abort",v)}function F0(){return I((x,k)=>{function h(t){if(t)x();else _(Y1(),h,k)}h(!1)})}function Y1(){if(A)return B(!0);return _(D._readyPromise,()=>{return I((x,k)=>{x1(M,{_chunkSteps:(h)=>{N=_(E5(D,h),void 0,G),x(!1)},_closeSteps:()=>x(!0),_errorSteps:k})})})}if(N0($,M._closedPromise,(x)=>{if(!Y)n(()=>X$(Q,x),!0,x);else G0(!0,x);return null}),N0(Q,D._closedPromise,(x)=>{if(!V)n(()=>W0($,x),!0,x);else G0(!0,x);return null}),i($,M._closedPromise,()=>{if(!Z)n(()=>t8(D));else G0();return null}),O0(Q)||Q._state==="closed"){const x=new TypeError("the destination writable stream closed before all data could be piped to it");if(!V)n(()=>W0($,x),!0,x);else G0(!0,x)}L(F0());function h0(){const x=N;return _(N,()=>x!==N?h0():void 0)}function N0(x,k,h){if(x._state==="errored")h(x._storedError);else C(k,h)}function i(x,k,h){if(x._state==="closed")h();else E(k,h)}function n(x,k,h){if(A)return;if(A=!0,Q._state==="writable"&&!O0(Q))E(h0(),t);else t();function t(){return T(x(),()=>q0(k,h),(w1)=>q0(!0,w1)),null}}function G0(x,k){if(A)return;if(A=!0,Q._state==="writable"&&!O0(Q))E(h0(),()=>q0(x,k));else q0(x,k)}function q0(x,k){if(x5(D),I0(M),z!==void 0)z.removeEventListener("abort",v);if(x)R(k);else q(void 0);return null}})}class B0{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!w$(this))throw z$("desiredSize");return z4(this)}close(){if(!w$(this))throw z$("close");if(!K1(this))throw new TypeError("The stream is not in a state that permits close");a0(this)}enqueue($=void 0){if(!w$(this))throw z$("enqueue");if(!K1(this))throw new TypeError("The stream is not in a state that permits enqueue");return J1(this,$)}error($=void 0){if(!w$(this))throw z$("error");K0(this,$)}[A1]($){_0(this);const Q=this._cancelAlgorithm($);return V$(this),Q}[k$]($){const Q=this._controlledReadableStream;if(this._queue.length>0){const Z=i$(this);if(this._closeRequested&&this._queue.length===0)V$(this),L1(Q);else R1(this);$._chunkSteps(Z)}else p4(Q,$),R1(this)}[L$](){}}if(Object.defineProperties(B0.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),W(B0.prototype.close,"close"),W(B0.prototype.enqueue,"enqueue"),W(B0.prototype.error,"error"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(B0.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});function w$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledReadableStream"))return!1;return $ instanceof B0}function R1($){if(!S5($))return;if($._pulling){$._pullAgain=!0;return}$._pulling=!0;const Z=$._pullAlgorithm();T(Z,()=>{if($._pulling=!1,$._pullAgain)$._pullAgain=!1,R1($);return null},(Y)=>{return K0($,Y),null})}function S5($){const Q=$._controlledReadableStream;if(!K1($))return!1;if(!$._started)return!1;if(f0(Q)&&i1(Q)>0)return!0;if(z4($)>0)return!0;return!1}function V$($){$._pullAlgorithm=void 0,$._cancelAlgorithm=void 0,$._strategySizeAlgorithm=void 0}function a0($){if(!K1($))return;const Q=$._controlledReadableStream;if($._closeRequested=!0,$._queue.length===0)V$($),L1(Q)}function J1($,Q){if(!K1($))return;const Z=$._controlledReadableStream;if(f0(Z)&&i1(Z)>0)b$(Z,Q,!1);else{let Y;try{Y=$._strategySizeAlgorithm(Q)}catch(V){throw K0($,V),V}try{l$($,Q,Y)}catch(V){throw K0($,V),V}}R1($)}function K0($,Q){const Z=$._controlledReadableStream;if(Z._state!=="readable")return;_0($),V$($),g5(Z,Q)}function z4($){const Q=$._controlledReadableStream._state;if(Q==="errored")return null;if(Q==="closed")return 0;return $._strategyHWM-$._queueTotalSize}function BQ($){if(S5($))return!1;return!0}function K1($){const Q=$._controlledReadableStream._state;if(!$._closeRequested&&Q==="readable")return!0;return!1}function v5($,Q,Z,Y,V,z,M){Q._controlledReadableStream=$,Q._queue=void 0,Q._queueTotalSize=void 0,_0(Q),Q._started=!1,Q._closeRequested=!1,Q._pullAgain=!1,Q._pulling=!1,Q._strategySizeAlgorithm=M,Q._strategyHWM=z,Q._pullAlgorithm=Y,Q._cancelAlgorithm=V,$._readableStreamController=Q;const D=Z();T(B(D),()=>{return Q._started=!0,R1(Q),null},(A)=>{return K0(Q,A),null})}function UQ($,Q,Z,Y){const V=Object.create(B0.prototype);let z,M,D;if(Q.start!==void 0)z=()=>Q.start(V);else z=()=>{return};if(Q.pull!==void 0)M=()=>Q.pull(V);else M=()=>B(void 0);if(Q.cancel!==void 0)D=(A)=>Q.cancel(A);else D=()=>B(void 0);v5($,V,z,M,D,Z,Y)}function z$($){return new TypeError(`ReadableStreamDefaultController.prototype.${$} can only be used on a ReadableStreamDefaultController`)}function IQ($,Q){if(c0($._readableStreamController))return DQ($);return PQ($)}function PQ($,Q){const Z=Q1($);let Y=!1,V=!1,z=!1,M=!1,D,A,N,q,R;const v=I((i)=>{R=i});function F0(){if(Y)return V=!0,B(void 0);return Y=!0,x1(Z,{_chunkSteps:(n)=>{F(()=>{V=!1;const G0=n,q0=n;if(!z)J1(N._readableStreamController,G0);if(!M)J1(q._readableStreamController,q0);if(Y=!1,V)F0()})},_closeSteps:()=>{if(Y=!1,!z)a0(N._readableStreamController);if(!M)a0(q._readableStreamController);if(!z||!M)R(void 0)},_errorSteps:()=>{Y=!1}}),B(void 0)}function Y1(i){if(z=!0,D=i,M){const n=E1([D,A]),G0=W0($,n);R(G0)}return v}function h0(i){if(M=!0,A=i,z){const n=E1([D,A]),G0=W0($,n);R(G0)}return v}function N0(){}return N=k1(N0,F0,Y1),q=k1(N0,F0,h0),C(Z._closedPromise,(i)=>{if(K0(N._readableStreamController,i),K0(q._readableStreamController,i),!z||!M)R(void 0);return null}),[N,q]}function DQ($){let Q=Q1($),Z=!1,Y=!1,V=!1,z=!1,M=!1,D,A,N,q,R;const v=I((x)=>{R=x});function F0(x){C(x._closedPromise,(k)=>{if(x!==Q)return null;if(X0(N._readableStreamController,k),X0(q._readableStreamController,k),!z||!M)R(void 0);return null})}function Y1(){if(i0(Q))I0(Q),Q=Q1($),F0(Q);x1(Q,{_chunkSteps:(k)=>{F(()=>{Y=!1,V=!1;const h=k;let t=k;if(!z&&!M)try{t=r4(k)}catch(w1){X0(N._readableStreamController,w1),X0(q._readableStreamController,w1),R(W0($,w1));return}if(!z)o1(N._readableStreamController,h);if(!M)o1(q._readableStreamController,t);if(Z=!1,Y)N0();else if(V)i()})},_closeSteps:()=>{if(Z=!1,!z)F1(N._readableStreamController);if(!M)F1(q._readableStreamController);if(N._readableStreamController._pendingPullIntos.length>0)t1(N._readableStreamController,0);if(q._readableStreamController._pendingPullIntos.length>0)t1(q._readableStreamController,0);if(!z||!M)R(void 0)},_errorSteps:()=>{Z=!1}})}function h0(x,k){if(k0(Q))I0(Q),Q=z5($),F0(Q);const h=k?q:N,t=k?N:q;M5(Q,x,1,{_chunkSteps:(V1)=>{F(()=>{Y=!1,V=!1;const z1=k?M:z;if(!(k?z:M)){let o5;try{o5=r4(V1)}catch(U4){X0(h._readableStreamController,U4),X0(t._readableStreamController,U4),R(W0($,U4));return}if(!z1)r1(h._readableStreamController,V1);o1(t._readableStreamController,o5)}else if(!z1)r1(h._readableStreamController,V1);if(Z=!1,Y)N0();else if(V)i()})},_closeSteps:(V1)=>{Z=!1;const z1=k?M:z,U$=k?z:M;if(!z1)F1(h._readableStreamController);if(!U$)F1(t._readableStreamController);if(V1!==void 0){if(!z1)r1(h._readableStreamController,V1);if(!U$&&t._readableStreamController._pendingPullIntos.length>0)t1(t._readableStreamController,0)}if(!z1||!U$)R(void 0)},_errorSteps:()=>{Z=!1}})}function N0(){if(Z)return Y=!0,B(void 0);Z=!0;const x=t$(N._readableStreamController);if(x===null)Y1();else h0(x._view,!1);return B(void 0)}function i(){if(Z)return V=!0,B(void 0);Z=!0;const x=t$(q._readableStreamController);if(x===null)Y1();else h0(x._view,!0);return B(void 0)}function n(x){if(z=!0,D=x,M){const k=E1([D,A]),h=W0($,k);R(h)}return v}function G0(x){if(M=!0,A=x,z){const k=E1([D,A]),h=W0($,k);R(h)}return v}function q0(){return}return N=h5(q0,N0,n),q=h5(q0,i,G0),F0(Q),[N,q]}function CQ($){return J($)&&typeof $.getReader!=="undefined"}function AQ($){if(CQ($))return EQ($.getReader());return xQ($)}function xQ($){let Q;const Z=t4($,"async"),Y=G;function V(){let M;try{M=O8(Z)}catch(A){return U(A)}const D=B(M);return S(D,(A)=>{if(!J(A))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(M8(A))a0(Q._readableStreamController);else{const q=B8(A);J1(Q._readableStreamController,q)}})}function z(M){const D=Z.iterator;let A;try{A=n1(D,"return")}catch(R){return U(R)}if(A===void 0)return B(void 0);let N;try{N=P(A,D,[M])}catch(R){return U(R)}const q=B(N);return S(q,(R)=>{if(!J(R))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");return})}return Q=k1(Y,V,z,0),Q}function EQ($){let Q;const Z=G;function Y(){let z;try{z=$.read()}catch(M){return U(M)}return S(z,(M)=>{if(!J(M))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(M.done)a0(Q._readableStreamController);else{const D=M.value;J1(Q._readableStreamController,D)}})}function V(z){try{return B($.cancel(z))}catch(M){return U(M)}}return Q=k1(Z,Y,V,0),Q}function FQ($,Q){z0($,Q);const Z=$,Y=Z===null||Z===void 0?void 0:Z.autoAllocateChunkSize,V=Z===null||Z===void 0?void 0:Z.cancel,z=Z===null||Z===void 0?void 0:Z.pull,M=Z===null||Z===void 0?void 0:Z.start,D=Z===null||Z===void 0?void 0:Z.type;return{autoAllocateChunkSize:Y===void 0?void 0:g$(Y,`${Q} has member 'autoAllocateChunkSize' that`),cancel:V===void 0?void 0:NQ(V,Z,`${Q} has member 'cancel' that`),pull:z===void 0?void 0:qQ(z,Z,`${Q} has member 'pull' that`),start:M===void 0?void 0:jQ(M,Z,`${Q} has member 'start' that`),type:D===void 0?void 0:TQ(D,`${Q} has member 'type' that`)}}function NQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function qQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function jQ($,Q,Z){return Q0($,Z),(Y)=>P($,Q,[Y])}function TQ($,Q){if($=`${$}`,$!=="bytes")throw new TypeError(`${Q} '${$}' is not a valid enumeration value for ReadableStreamType`);return $}function RQ($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.preventCancel;return{preventCancel:Boolean(Z)}}function f5($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.preventAbort,Y=$===null||$===void 0?void 0:$.preventCancel,V=$===null||$===void 0?void 0:$.preventClose,z=$===null||$===void 0?void 0:$.signal;if(z!==void 0)kQ(z,`${Q} has member 'signal' that`);return{preventAbort:Boolean(Z),preventCancel:Boolean(Y),preventClose:Boolean(V),signal:z}}function kQ($,Q){if(!y8($))throw new TypeError(`${Q} is not an AbortSignal.`)}function LQ($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.readable;f$(Z,"readable","ReadableWritablePair"),y$(Z,`${Q} has member 'readable' that`);const Y=$===null||$===void 0?void 0:$.writable;return f$(Y,"writable","ReadableWritablePair"),U5(Y,`${Q} has member 'writable' that`),{readable:Z,writable:Y}}class d{constructor($={},Q={}){if($===void 0)$=null;else m4($,"First parameter");const Z=Q$(Q,"Second parameter"),Y=FQ($,"First parameter");if(H4(this),Y.type==="bytes"){if(Z.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");const V=q1(Z,0);N8(this,Y,V)}else{const V=$$(Z),z=q1(Z,1);UQ(this,Y,z,V)}}get locked(){if(!v0(this))throw o0("locked");return f0(this)}cancel($=void 0){if(!v0(this))return U(o0("cancel"));if(f0(this))return U(new TypeError("Cannot cancel a stream that already has a reader"));return W0(this,$)}getReader($=void 0){if(!v0(this))throw o0("getReader");if(j8($,"First parameter").mode===void 0)return Q1(this);return z5(this)}pipeThrough($,Q={}){if(!v0(this))throw o0("pipeThrough");P0($,1,"pipeThrough");const Z=LQ($,"First parameter"),Y=f5(Q,"Second parameter");if(f0(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Z1(Z.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");const V=_5(this,Z.writable,Y.preventClose,Y.preventAbort,Y.preventCancel,Y.signal);return L(V),Z.readable}pipeTo($,Q={}){if(!v0(this))return U(o0("pipeTo"));if($===void 0)return U("Parameter 1 is required in 'pipeTo'.");if(!G1($))return U(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let Z;try{Z=f5(Q,"Second parameter")}catch(Y){return U(Y)}if(f0(this))return U(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(Z1($))return U(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));return _5(this,$,Z.preventClose,Z.preventAbort,Z.preventCancel,Z.signal)}tee(){if(!v0(this))throw o0("tee");const $=IQ(this);return E1($)}values($=void 0){if(!v0(this))throw o0("values");const Q=RQ($,"First parameter");return z8(this,Q.preventCancel)}[d$]($){return this.values($)}static from($){return AQ($)}}if(Object.defineProperties(d,{from:{enumerable:!0}}),Object.defineProperties(d.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),W(d.from,"from"),W(d.prototype.cancel,"cancel"),W(d.prototype.getReader,"getReader"),W(d.prototype.pipeThrough,"pipeThrough"),W(d.prototype.pipeTo,"pipeTo"),W(d.prototype.tee,"tee"),W(d.prototype.values,"values"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(d.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0});Object.defineProperty(d.prototype,d$,{value:d.prototype.values,writable:!0,configurable:!0});function k1($,Q,Z,Y=1,V=()=>1){const z=Object.create(d.prototype);H4(z);const M=Object.create(B0.prototype);return v5(z,M,$,Q,Z,Y,V),z}function h5($,Q,Z){const Y=Object.create(d.prototype);H4(Y);const V=Object.create(H0.prototype);return V5(Y,V,$,Q,Z,0,void 0),Y}function H4($){$._state="readable",$._reader=void 0,$._storedError=void 0,$._disturbed=!1}function v0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readableStreamController"))return!1;return $ instanceof d}function f0($){if($._reader===void 0)return!1;return!0}function W0($,Q){if($._disturbed=!0,$._state==="closed")return B(void 0);if($._state==="errored")return U($._storedError);L1($);const Z=$._reader;if(Z!==void 0&&i0(Z)){const V=Z._readIntoRequests;Z._readIntoRequests=new j,V.forEach((z)=>{z._closeSteps(void 0)})}const Y=$._readableStreamController[A1](Q);return S(Y,G)}function L1($){$._state="closed";const Q=$._reader;if(Q===void 0)return;if(y4(Q),k0(Q)){const Z=Q._readRequests;Q._readRequests=new j,Z.forEach((Y)=>{Y._closeSteps()})}}function g5($,Q){$._state="errored",$._storedError=Q;const Z=$._reader;if(Z===void 0)return;if(v$(Z,Q),k0(Z))d4(Z,Q);else B5(Z,Q)}function o0($){return new TypeError(`ReadableStream.prototype.${$} can only be used on a ReadableStream`)}function y5($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.highWaterMark;return f$(Z,"highWaterMark","QueuingStrategyInit"),{highWaterMark:h$(Z)}}const b5=($)=>{return $.byteLength};W(b5,"size");class _1{constructor($){P0($,1,"ByteLengthQueuingStrategy"),$=y5($,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=$.highWaterMark}get highWaterMark(){if(!u5(this))throw m5("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!u5(this))throw m5("size");return b5}}if(Object.defineProperties(_1.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(_1.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});function m5($){return new TypeError(`ByteLengthQueuingStrategy.prototype.${$} can only be used on a ByteLengthQueuingStrategy`)}function u5($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_byteLengthQueuingStrategyHighWaterMark"))return!1;return $ instanceof _1}const p5=()=>{return 1};W(p5,"size");class S1{constructor($){P0($,1,"CountQueuingStrategy"),$=y5($,"First parameter"),this._countQueuingStrategyHighWaterMark=$.highWaterMark}get highWaterMark(){if(!d5(this))throw c5("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!d5(this))throw c5("size");return p5}}if(Object.defineProperties(S1.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(S1.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:!0});function c5($){return new TypeError(`CountQueuingStrategy.prototype.${$} can only be used on a CountQueuingStrategy`)}function d5($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_countQueuingStrategyHighWaterMark"))return!1;return $ instanceof S1}function _Q($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.cancel,Y=$===null||$===void 0?void 0:$.flush,V=$===null||$===void 0?void 0:$.readableType,z=$===null||$===void 0?void 0:$.start,M=$===null||$===void 0?void 0:$.transform,D=$===null||$===void 0?void 0:$.writableType;return{cancel:Z===void 0?void 0:hQ(Z,$,`${Q} has member 'cancel' that`),flush:Y===void 0?void 0:SQ(Y,$,`${Q} has member 'flush' that`),readableType:V,start:z===void 0?void 0:vQ(z,$,`${Q} has member 'start' that`),transform:M===void 0?void 0:fQ(M,$,`${Q} has member 'transform' that`),writableType:D}}function SQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function vQ($,Q,Z){return Q0($,Z),(Y)=>P($,Q,[Y])}function fQ($,Q,Z){return Q0($,Z),(Y,V)=>y($,Q,[Y,V])}function hQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}class v1{constructor($={},Q={},Z={}){if($===void 0)$=null;const Y=Q$(Q,"Second parameter"),V=Q$(Z,"Third parameter"),z=_Q($,"First parameter");if(z.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(z.writableType!==void 0)throw new RangeError("Invalid writableType specified");const M=q1(V,0),D=$$(V),A=q1(Y,1),N=$$(Y);let q;const R=I((v)=>{q=v});if(gQ(this,R,A,N,M,D),bQ(this,z),z.start!==void 0)q(z.start(this._transformStreamController));else q(void 0)}get readable(){if(!i5(this))throw a5("readable");return this._readable}get writable(){if(!i5(this))throw a5("writable");return this._writable}}if(Object.defineProperties(v1.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(v1.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:!0});function gQ($,Q,Z,Y,V,z){function M(){return Q}function D(v){return pQ($,v)}function A(v){return cQ($,v)}function N(){return dQ($)}$._writable=u8(M,D,N,A,Z,Y);function q(){return iQ($)}function R(v){return lQ($,v)}$._readable=k1(M,q,R,V,z),$._backpressure=void 0,$._backpressureChangePromise=void 0,$._backpressureChangePromise_resolve=void 0,H$($,!0),$._transformStreamController=void 0}function i5($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_transformStreamController"))return!1;return $ instanceof v1}function l5($,Q){K0($._readable._readableStreamController,Q),O4($,Q)}function O4($,Q){M$($._transformStreamController),j1($._writable._writableStreamController,Q),M4($)}function M4($){if($._backpressure)H$($,!1)}function H$($,Q){if($._backpressureChangePromise!==void 0)$._backpressureChangePromise_resolve();$._backpressureChangePromise=I((Z)=>{$._backpressureChangePromise_resolve=Z}),$._backpressure=Q}class E0{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!O$(this))throw B$("desiredSize");const $=this._controlledTransformStream._readable._readableStreamController;return z4($)}enqueue($=void 0){if(!O$(this))throw B$("enqueue");n5(this,$)}error($=void 0){if(!O$(this))throw B$("error");mQ(this,$)}terminate(){if(!O$(this))throw B$("terminate");uQ(this)}}if(Object.defineProperties(E0.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),W(E0.prototype.enqueue,"enqueue"),W(E0.prototype.error,"error"),W(E0.prototype.terminate,"terminate"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(E0.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});function O$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledTransformStream"))return!1;return $ instanceof E0}function yQ($,Q,Z,Y,V){Q._controlledTransformStream=$,$._transformStreamController=Q,Q._transformAlgorithm=Z,Q._flushAlgorithm=Y,Q._cancelAlgorithm=V,Q._finishPromise=void 0,Q._finishPromise_resolve=void 0,Q._finishPromise_reject=void 0}function bQ($,Q){const Z=Object.create(E0.prototype);let Y,V,z;if(Q.transform!==void 0)Y=(M)=>Q.transform(M,Z);else Y=(M)=>{try{return n5(Z,M),B(void 0)}catch(D){return U(D)}};if(Q.flush!==void 0)V=()=>Q.flush(Z);else V=()=>B(void 0);if(Q.cancel!==void 0)z=(M)=>Q.cancel(M);else z=()=>B(void 0);yQ($,Z,Y,V,z)}function M$($){$._transformAlgorithm=void 0,$._flushAlgorithm=void 0,$._cancelAlgorithm=void 0}function n5($,Q){const Z=$._controlledTransformStream,Y=Z._readable._readableStreamController;if(!K1(Y))throw new TypeError("Readable side is not in a state that permits enqueue");try{J1(Y,Q)}catch(z){throw O4(Z,z),Z._readable._storedError}if(BQ(Y)!==Z._backpressure)H$(Z,!0)}function mQ($,Q){l5($._controlledTransformStream,Q)}function s5($,Q){const Z=$._transformAlgorithm(Q);return S(Z,void 0,(Y)=>{throw l5($._controlledTransformStream,Y),Y})}function uQ($){const Q=$._controlledTransformStream,Z=Q._readable._readableStreamController;a0(Z);const Y=new TypeError("TransformStream terminated");O4(Q,Y)}function pQ($,Q){const Z=$._transformStreamController;if($._backpressure){const Y=$._backpressureChangePromise;return S(Y,()=>{const V=$._writable;if(V._state==="erroring")throw V._storedError;return s5(Z,Q)})}return s5(Z,Q)}function cQ($,Q){const Z=$._transformStreamController;if(Z._finishPromise!==void 0)return Z._finishPromise;const Y=$._readable;Z._finishPromise=I((z,M)=>{Z._finishPromise_resolve=z,Z._finishPromise_reject=M});const V=Z._cancelAlgorithm(Q);return M$(Z),T(V,()=>{if(Y._state==="errored")W1(Z,Y._storedError);else K0(Y._readableStreamController,Q),B4(Z);return null},(z)=>{return K0(Y._readableStreamController,z),W1(Z,z),null}),Z._finishPromise}function dQ($){const Q=$._transformStreamController;if(Q._finishPromise!==void 0)return Q._finishPromise;const Z=$._readable;Q._finishPromise=I((V,z)=>{Q._finishPromise_resolve=V,Q._finishPromise_reject=z});const Y=Q._flushAlgorithm();return M$(Q),T(Y,()=>{if(Z._state==="errored")W1(Q,Z._storedError);else a0(Z._readableStreamController),B4(Q);return null},(V)=>{return K0(Z._readableStreamController,V),W1(Q,V),null}),Q._finishPromise}function iQ($){return H$($,!1),$._backpressureChangePromise}function lQ($,Q){const Z=$._transformStreamController;if(Z._finishPromise!==void 0)return Z._finishPromise;const Y=$._writable;Z._finishPromise=I((z,M)=>{Z._finishPromise_resolve=z,Z._finishPromise_reject=M});const V=Z._cancelAlgorithm(Q);return M$(Z),T(V,()=>{if(Y._state==="errored")W1(Z,Y._storedError);else j1(Y._writableStreamController,Q),M4($),B4(Z);return null},(z)=>{return j1(Y._writableStreamController,z),M4($),W1(Z,z),null}),Z._finishPromise}function B$($){return new TypeError(`TransformStreamDefaultController.prototype.${$} can only be used on a TransformStreamDefaultController`)}function B4($){if($._finishPromise_resolve===void 0)return;$._finishPromise_resolve(),$._finishPromise_resolve=void 0,$._finishPromise_reject=void 0}function W1($,Q){if($._finishPromise_reject===void 0)return;L($._finishPromise),$._finishPromise_reject(Q),$._finishPromise_resolve=void 0,$._finishPromise_reject=void 0}function a5($){return new TypeError(`TransformStream.prototype.${$} can only be used on a TransformStream`)}X.ByteLengthQueuingStrategy=_1,X.CountQueuingStrategy=S1,X.ReadableByteStreamController=H0,X.ReadableStream=d,X.ReadableStreamBYOBReader=A0,X.ReadableStreamBYOBRequest=S0,X.ReadableStreamDefaultController=B0,X.ReadableStreamDefaultReader=D0,X.TransformStream=v1,X.TransformStreamDefaultController=E0,X.WritableStream=x0,X.WritableStreamDefaultController=n0,X.WritableStreamDefaultWriter=M0})});var O6=g0(()=>{if(!globalThis.ReadableStream)try{const X=y0("node:process"),{emitWarning:G}=X;try{X.emitWarning=()=>{},Object.assign(globalThis,y0("node:stream/web")),X.emitWarning=G}catch(J){throw X.emitWarning=G,J}}catch(X){Object.assign(globalThis,H6())}try{const{Blob:X}=y0("buffer");if(X&&!X.prototype.stream)X.prototype.stream=function G(J){let K=0;const W=this;return new ReadableStream({type:"bytes",async pull(w){const O=await W.slice(K,Math.min(W.size,K+65536)).arrayBuffer();if(K+=O.byteLength,w.enqueue(new Uint8Array(O)),K===W.size)w.close()}})}}catch(X){}});async function*E4(X,G=!0){for(let J of X)if("stream"in J)yield*J.stream();else if(ArrayBuffer.isView(J))if(G){let K=J.byteOffset;const W=J.byteOffset+J.byteLength;while(K!==W){const w=Math.min(W-K,M6),H=J.buffer.slice(K,K+w);K+=H.byteLength,yield new Uint8Array(H)}}else yield J;else{let K=0,W=J;while(K!==W.size){const H=await W.slice(K,Math.min(W.size,K+M6)).arrayBuffer();K+=H.byteLength,yield new Uint8Array(H)}}}var yG,M6,B6,AX,j0;var y1=f1(()=>{yG=P4(O6(),1);/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */M6=65536,B6=class X{#$=[];#Q="";#X=0;#G="transparent";constructor(G=[],J={}){if(typeof G!=="object"||G===null)throw new TypeError("Failed to construct \'Blob\': The provided value cannot be converted to a sequence.");if(typeof G[Symbol.iterator]!=="function")throw new TypeError("Failed to construct \'Blob\': The object must have a callable @@iterator property.");if(typeof J!=="object"&&typeof J!=="function")throw new TypeError("Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.");if(J===null)J={};const K=new TextEncoder;for(let w of G){let H;if(ArrayBuffer.isView(w))H=new Uint8Array(w.buffer.slice(w.byteOffset,w.byteOffset+w.byteLength));else if(w instanceof ArrayBuffer)H=new Uint8Array(w.slice(0));else if(w instanceof X)H=w;else H=K.encode(`${w}`);this.#X+=ArrayBuffer.isView(H)?H.byteLength:H.size,this.#$.push(H)}this.#G=`${J.endings===void 0?"transparent":J.endings}`;const W=J.type===void 0?"":String(J.type);this.#Q=/^[\x20-\x7E]*$/.test(W)?W:""}get size(){return this.#X}get type(){return this.#Q}async text(){const G=new TextDecoder;let J="";for await(let K of E4(this.#$,!1))J+=G.decode(K,{stream:!0});return J+=G.decode(),J}async arrayBuffer(){const G=new Uint8Array(this.size);let J=0;for await(let K of E4(this.#$,!1))G.set(K,J),J+=K.length;return G.buffer}stream(){const G=E4(this.#$,!0);return new globalThis.ReadableStream({type:"bytes",async pull(J){const K=await G.next();K.done?J.close():J.enqueue(K.value)},async cancel(){await G.return()}})}slice(G=0,J=this.size,K=""){const{size:W}=this;let w=G<0?Math.max(W+G,0):Math.min(G,W),H=J<0?Math.max(W+J,0):Math.min(J,W);const O=Math.max(H-w,0),I=this.#$,B=[];let U=0;for(let T of I){if(U>=O)break;const E=ArrayBuffer.isView(T)?T.byteLength:T.size;if(w&&E<=w)w-=E,H-=E;else{let C;if(ArrayBuffer.isView(T))C=T.subarray(w,Math.min(E,H)),U+=C.byteLength;else C=T.slice(w,Math.min(E,H)),U+=C.size;H-=E,B.push(C),w=0}}const _=new X([],{type:String(K).toLowerCase()});return _.#X=O,_.#$=B,_}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](G){return G&&typeof G==="object"&&typeof G.constructor==="function"&&(typeof G.stream==="function"||typeof G.arrayBuffer==="function")&&/^(Blob|File)$/.test(G[Symbol.toStringTag])}};Object.defineProperties(B6.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}});AX=B6,j0=AX});var xX,EX,M1;var F4=f1(()=>{y1();xX=class X extends j0{#$=0;#Q="";constructor(G,J,K={}){if(arguments.length<2)throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);super(G,K);if(K===null)K={};const W=K.lastModified===void 0?Date.now():Number(K.lastModified);if(!Number.isNaN(W))this.#$=W;this.#Q=String(J)}get name(){return this.#Q}get lastModified(){return this.#$}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](G){return!!G&&G instanceof j0&&/^(File)$/.test(G[Symbol.toStringTag])}},EX=xX,M1=EX});function P6(X,G=j0){var J=`${U6()}${U6()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),K=[],W=`--${J}\r\nContent-Disposition: form-data; name="`;return X.forEach((w,H)=>typeof w=="string"?K.push(W+N4(H)+`"\r\n\r\n${w.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r\n`):K.push(W+N4(H)+`"; filename="${N4(w.name,1)}"\r\nContent-Type: ${w.type||"application/octet-stream"}\r\n\r\n`,w,"\r\n")),K.push(`--${J}--`),new G(K,{type:"multipart/form-data; boundary="+J})}var b1,FX,NX,U6,qX,I6,N4,t0,r0;var C$=f1(()=>{y1();F4();/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */({toStringTag:b1,iterator:FX,hasInstance:NX}=Symbol),U6=Math.random,qX="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),I6=(X,G,J)=>(X+="",/^(Blob|File)$/.test(G&&G[b1])?[(J=J!==void 0?J+"":G[b1]=="File"?G.name:"blob",X),G.name!==J||G[b1]=="blob"?new M1([G],J,G):G]:[X,G+""]),N4=(X,G)=>(G?X:X.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),t0=(X,G,J)=>{if(G.length<J)throw new TypeError(`Failed to execute '${X}' on 'FormData': ${J} arguments required, but only ${G.length} present.`)},r0=class X{#$=[];constructor(...G){if(G.length)throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.")}get[b1](){return"FormData"}[FX](){return this.entries()}static[NX](G){return G&&typeof G==="object"&&G[b1]==="FormData"&&!qX.some((J)=>typeof G[J]!="function")}append(...G){t0("append",arguments,2),this.#$.push(I6(...G))}delete(G){t0("delete",arguments,1),G+="",this.#$=this.#$.filter(([J])=>J!==G)}get(G){t0("get",arguments,1),G+="";for(var J=this.#$,K=J.length,W=0;W<K;W++)if(J[W][0]===G)return J[W][1];return null}getAll(G,J){return t0("getAll",arguments,1),J=[],G+="",this.#$.forEach((K)=>K[0]===G&&J.push(K[1])),J}has(G){return t0("has",arguments,1),G+="",this.#$.some((J)=>J[0]===G)}forEach(G,J){t0("forEach",arguments,1);for(var[K,W]of this)G.call(J,W,K,this)}set(...G){t0("set",arguments,2);var J=[],K=!0;G=I6(...G),this.#$.forEach((W)=>{W[0]===G[0]?K&&(K=!J.push(G)):J.push(W)}),K&&J.push(G),this.#$=J}*entries(){yield*this.#$}*keys(){for(var[G]of this)yield G}*values(){for(var[,G]of this)yield G}}});var E6=g0((aG,x6)=>{/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */if(!globalThis.DOMException)try{const{MessageChannel:X}=y0("worker_threads"),G=new X().port1,J=new ArrayBuffer;G.postMessage(J,[J,J])}catch(X){X.constructor.name==="DOMException"&&(globalThis.DOMException=X.constructor)}x6.exports=globalThis.DOMException});import{statSync as tG,createReadStream as jX,promises as TX} from"node:fs";class N6{#$;#Q;constructor(X){this.#$=X.path,this.#Q=X.start,this.size=X.size,this.lastModified=X.lastModified}slice(X,G){return new N6({path:this.#$,lastModified:this.lastModified,size:G-X,start:this.#Q+X})}async*stream(){const{mtimeMs:X}=await RX(this.#$);if(X>this.lastModified)throw new F6.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError");yield*jX(this.#$,{start:this.#Q,end:this.#Q+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}var F6,RX;var j4=f1(()=>{F6=P4(E6(),1);F4();y1();({stat:RX}=TX)});var T6={};tQ(T6,{toFormData:()=>{{return hX}}});async function hX(X,G){if(!/multipart/i.test(G))throw new TypeError("Failed to fetch");const J=G.match(/boundary=(?:"([^"]+)"|([^;]+))/i);if(!J)throw new TypeError("no or bad content-type header, no multipart boundary");const K=new j6(J[1]||J[2]);let W,w,H,O,I,B;const U=[],_=new r0,T=(F)=>{H+=L.decode(F,{stream:!0})},E=(F)=>{U.push(F)},C=()=>{const F=new M1(U,B,{type:I});_.append(O,F)},S=()=>{_.append(O,H)},L=new TextDecoder("utf-8");L.decode(),K.onPartBegin=function(){K.onPartData=T,K.onPartEnd=S,W="",w="",H="",O="",I="",B=null,U.length=0},K.onHeaderField=function(F){W+=L.decode(F,{stream:!0})},K.onHeaderValue=function(F){w+=L.decode(F,{stream:!0})},K.onHeaderEnd=function(){if(w+=L.decode(),W=W.toLowerCase(),W==="content-disposition"){const F=w.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);if(F)O=F[2]||F[3]||"";if(B=fX(w),B)K.onPartData=E,K.onPartEnd=C}else if(W==="content-type")I=w;w="",W=""};for await(let F of X)K.write(F);return K.end(),_}class j6{constructor(X){this.index=0,this.flags=0,this.onHeaderEnd=e0,this.onHeaderField=e0,this.onHeadersEnd=e0,this.onHeaderValue=e0,this.onPartBegin=e0,this.onPartData=e0,this.onPartEnd=e0,this.boundaryChars={},X="\r\n--"+X;const G=new Uint8Array(X.length);for(let J=0;J<X.length;J++)G[J]=X.charCodeAt(J),this.boundaryChars[G[J]]=!0;this.boundary=G,this.lookbehind=new Uint8Array(this.boundary.length+8),this.state=g.START_BOUNDARY}write(X){let G=0;const J=X.length;let K=this.index,{lookbehind:W,boundary:w,boundaryChars:H,index:O,state:I,flags:B}=this;const U=this.boundary.length,_=U-1,T=X.length;let E,C;const S=(y)=>{this[y+"Mark"]=G},L=(y)=>{delete this[y+"Mark"]},F=(y,f,j,p)=>{if(f===void 0||f!==j)this[y](p&&p.subarray(f,j))},P=(y,f)=>{const j=y+"Mark";if(!(j in this))return;if(f)F(y,this[j],G,X),delete this[j];else F(y,this[j],X.length,X),this[j]=0};for(G=0;G<J;G++)switch(E=X[G],I){case g.START_BOUNDARY:if(O===w.length-2){if(E===u1)B|=u0.LAST_BOUNDARY;else if(E!==E$)return;O++;break}else if(O-1===w.length-2){if(B&u0.LAST_BOUNDARY&&E===u1)I=g.END,B=0;else if(!(B&u0.LAST_BOUNDARY)&&E===x$)O=0,F("onPartBegin"),I=g.HEADER_FIELD_START;else return;break}if(E!==w[O+2])O=-2;if(E===w[O+2])O++;break;case g.HEADER_FIELD_START:I=g.HEADER_FIELD,S("onHeaderField"),O=0;case g.HEADER_FIELD:if(E===E$){L("onHeaderField"),I=g.HEADERS_ALMOST_DONE;break}if(O++,E===u1)break;if(E===LX){if(O===1)return;P("onHeaderField",!0),I=g.HEADER_VALUE_START;break}if(C=vX(E),C<_X||C>SX)return;break;case g.HEADER_VALUE_START:if(E===kX)break;S("onHeaderValue"),I=g.HEADER_VALUE;case g.HEADER_VALUE:if(E===E$)P("onHeaderValue",!0),F("onHeaderEnd"),I=g.HEADER_VALUE_ALMOST_DONE;break;case g.HEADER_VALUE_ALMOST_DONE:if(E!==x$)return;I=g.HEADER_FIELD_START;break;case g.HEADERS_ALMOST_DONE:if(E!==x$)return;F("onHeadersEnd"),I=g.PART_DATA_START;break;case g.PART_DATA_START:I=g.PART_DATA,S("onPartData");case g.PART_DATA:if(K=O,O===0){G+=_;while(G<T&&!(X[G]in H))G+=U;G-=_,E=X[G]}if(O<w.length)if(w[O]===E){if(O===0)P("onPartData",!0);O++}else O=0;else if(O===w.length)if(O++,E===E$)B|=u0.PART_BOUNDARY;else if(E===u1)B|=u0.LAST_BOUNDARY;else O=0;else if(O-1===w.length)if(B&u0.PART_BOUNDARY){if(O=0,E===x$){B&=~u0.PART_BOUNDARY,F("onPartEnd"),F("onPartBegin"),I=g.HEADER_FIELD_START;break}}else if(B&u0.LAST_BOUNDARY)if(E===u1)F("onPartEnd"),I=g.END,B=0;else O=0;else O=0;if(O>0)W[O-1]=E;else if(K>0){const y=new Uint8Array(W.buffer,W.byteOffset,W.byteLength);F("onPartData",0,K,y),K=0,S("onPartData"),G--}break;case g.END:break;default:throw new Error(`Unexpected state entered: ${I}`)}P("onHeaderField"),P("onHeaderValue"),P("onPartData"),this.index=O,this.state=I,this.flags=B}end(){if(this.state===g.HEADER_FIELD_START&&this.index===0||this.state===g.PART_DATA&&this.index===this.boundary.length)this.onPartEnd();else if(this.state!==g.END)throw new Error("MultipartParser.end(): stream ended unexpectedly")}}var fX,U0,g,q6,u0,x$,E$,kX,u1,LX,_X,SX,vX,e0;var R6=f1(()=>{j4();C$();fX=function(X){const G=X.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);if(!G)return;const J=G[2]||G[3]||"";let K=J.slice(J.lastIndexOf("\\")+1);return K=K.replace(/%22/g,'"'),K=K.replace(/&#(\d{4});/g,(W,w)=>{return String.fromCharCode(w)}),K};U0=0,g={START_BOUNDARY:U0++,HEADER_FIELD_START:U0++,HEADER_FIELD:U0++,HEADER_VALUE_START:U0++,HEADER_VALUE:U0++,HEADER_VALUE_ALMOST_DONE:U0++,HEADERS_ALMOST_DONE:U0++,PART_DATA_START:U0++,PART_DATA:U0++,END:U0++},q6=1,u0={PART_BOUNDARY:q6,LAST_BOUNDARY:q6*=2},x$=10,E$=13,kX=32,u1=45,LX=58,_X=97,SX=122,vX=(X)=>X|32,e0=()=>{}});var l6=g0((QZ,oX)=>{oX.exports={name:"dotenv",version:"16.4.5",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard","lint-readme":"standard-markdown",pretest:"npm run lint && npm run dts-check",test:"tap tests/*.js --100 -Rspec","test:coverage":"tap --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@definitelytyped/dtslint":"^0.0.133","@types/node":"^18.11.3",decache:"^4.6.1",sinon:"^14.0.1",standard:"^17.0.0","standard-markdown":"^7.1.0","standard-version":"^9.5.0",tap:"^16.3.0",tar:"^6.1.11",typescript:"^4.8.4"},engines:{node:">=12"},browser:{fs:!1}}});var o6=g0((XZ,R0)=>{var QG=function(X){const G={};let J=X.toString();J=J.replace(/\r\n?/mg,"\n");let K;while((K=$G.exec(J))!=null){const W=K[1];let w=K[2]||"";w=w.trim();const H=w[0];if(w=w.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),H==='"')w=w.replace(/\\n/g,"\n"),w=w.replace(/\\r/g,"\r");G[W]=w}return G},XG=function(X){const G=a6(X),J=u.configDotenv({path:G});if(!J.parsed){const H=new Error(`MISSING_DATA: Cannot parse ${G} for an unknown reason`);throw H.code="MISSING_DATA",H}const K=s6(X).split(","),W=K.length;let w;for(let H=0;H<W;H++)try{const O=K[H].trim(),I=JG(J,O);w=u.decrypt(I.ciphertext,I.key);break}catch(O){if(H+1>=W)throw O}return u.parse(w)},GG=function(X){console.log(`[dotenv@${v4}][INFO] ${X}`)},ZG=function(X){console.log(`[dotenv@${v4}][WARN] ${X}`)},R$=function(X){console.log(`[dotenv@${v4}][DEBUG] ${X}`)},s6=function(X){if(X&&X.DOTENV_KEY&&X.DOTENV_KEY.length>0)return X.DOTENV_KEY;if(process.env.DOTENV_KEY&&process.env.DOTENV_KEY.length>0)return process.env.DOTENV_KEY;return""},JG=function(X,G){let J;try{J=new URL(G)}catch(O){if(O.code==="ERR_INVALID_URL"){const I=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw I.code="INVALID_DOTENV_KEY",I}throw O}const K=J.password;if(!K){const O=new Error("INVALID_DOTENV_KEY: Missing key part");throw O.code="INVALID_DOTENV_KEY",O}const W=J.searchParams.get("environment");if(!W){const O=new Error("INVALID_DOTENV_KEY: Missing environment part");throw O.code="INVALID_DOTENV_KEY",O}const w=`DOTENV_VAULT_${W.toUpperCase()}`,H=X.parsed[w];if(!H){const O=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${w} in your .env.vault file.`);throw O.code="NOT_FOUND_DOTENV_ENVIRONMENT",O}return{ciphertext:H,key:K}},a6=function(X){let G=null;if(X&&X.path&&X.path.length>0)if(Array.isArray(X.path)){for(let J of X.path)if(_4.existsSync(J))G=J.endsWith(".vault")?J:`${J}.vault`}else G=X.path.endsWith(".vault")?X.path:`${X.path}.vault`;else G=S4.resolve(process.cwd(),".env.vault");if(_4.existsSync(G))return G;return null},n6=function(X){return X[0]==="~"?S4.join(tX.homedir(),X.slice(1)):X},KG=function(X){GG("Loading env from encrypted .env.vault");const G=u._parseVault(X);let J=process.env;if(X&&X.processEnv!=null)J=X.processEnv;return u.populate(J,G,X),{parsed:G}},WG=function(X){const G=S4.resolve(process.cwd(),".env");let J="utf8";const K=Boolean(X&&X.debug);if(X&&X.encoding)J=X.encoding;else if(K)R$("No encoding is specified. UTF-8 is used by default");let W=[G];if(X&&X.path)if(!Array.isArray(X.path))W=[n6(X.path)];else{W=[];for(let I of X.path)W.push(n6(I))}let w;const H={};for(let I of W)try{const B=u.parse(_4.readFileSync(I,{encoding:J}));u.populate(H,B,X)}catch(B){if(K)R$(`Failed to load ${I} ${B.message}`);w=B}let O=process.env;if(X&&X.processEnv!=null)O=X.processEnv;if(u.populate(O,H,X),w)return{parsed:H,error:w};else return{parsed:H}},YG=function(X){if(s6(X).length===0)return u.configDotenv(X);const G=a6(X);if(!G)return ZG(`You set DOTENV_KEY but you are missing a .env.vault file at ${G}. Did you forget to build it?`),u.configDotenv(X);return u._configVault(X)},wG=function(X,G){const J=Buffer.from(G.slice(-64),"hex");let K=Buffer.from(X,"base64");const W=K.subarray(0,12),w=K.subarray(-16);K=K.subarray(12,-16);try{const H=rX.createDecipheriv("aes-256-gcm",J,W);return H.setAuthTag(w),`${H.update(K)}${H.final()}`}catch(H){const O=H instanceof RangeError,I=H.message==="Invalid key length",B=H.message==="Unsupported state or unable to authenticate data";if(O||I){const U=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw U.code="INVALID_DOTENV_KEY",U}else if(B){const U=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw U.code="DECRYPTION_FAILED",U}else throw H}},VG=function(X,G,J={}){const K=Boolean(J&&J.debug),W=Boolean(J&&J.override);if(typeof G!=="object"){const w=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw w.code="OBJECT_REQUIRED",w}for(let w of Object.keys(G))if(Object.prototype.hasOwnProperty.call(X,w)){if(W===!0)X[w]=G[w];if(K)if(W===!0)R$(`"${w}" is already defined and WAS overwritten`);else R$(`"${w}" is already defined and was NOT overwritten`)}else X[w]=G[w]},_4=y0("fs"),S4=y0("path"),tX=y0("os"),rX=y0("crypto"),eX=l6(),v4=eX.version,$G=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg,u={configDotenv:WG,_configVault:KG,_parseVault:XG,config:YG,decrypt:wG,parse:QG,populate:VG};XZ.configDotenv=u.configDotenv;XZ._configVault=u._configVault;XZ._parseVault=u._parseVault;XZ.config=u.config;XZ.decrypt=u.decrypt;XZ.parse=u.parse;XZ.populate=u.populate;R0.exports=u});var r6=g0((GZ,t6)=>{var D1={};if(process.env.DOTENV_CONFIG_ENCODING!=null)D1.encoding=process.env.DOTENV_CONFIG_ENCODING;if(process.env.DOTENV_CONFIG_PATH!=null)D1.path=process.env.DOTENV_CONFIG_PATH;if(process.env.DOTENV_CONFIG_DEBUG!=null)D1.debug=process.env.DOTENV_CONFIG_DEBUG;if(process.env.DOTENV_CONFIG_OVERRIDE!=null)D1.override=process.env.DOTENV_CONFIG_OVERRIDE;if(process.env.DOTENV_CONFIG_DOTENV_KEY!=null)D1.DOTENV_KEY=process.env.DOTENV_CONFIG_DOTENV_KEY;t6.exports=D1});var $8=g0((ZZ,e6)=>{var PG=/^dotenv_config_(encoding|path|debug|override|DOTENV_KEY)=(.+)$/;e6.exports=function X(G){return G.reduce(function(J,K){const W=K.match(PG);if(W)J[W[1]]=W[2];return J},{})}});var Q8=g0(()=>{(function(){o6().config(Object.assign({},r6(),$8()(process.argv)))})()});var QX=function(){const X=new Map;for(let[G,J]of Object.entries(b)){for(let[K,W]of Object.entries(J))b[K]={open:`\x1B[${W[0]}m`,close:`\x1B[${W[1]}m`},J[K]=b[K],X.set(W[0],W[1]);Object.defineProperty(b,G,{value:J,enumerable:!1})}return Object.defineProperty(b,"codes",{value:X,enumerable:!1}),b.color.close="\x1B[39m",b.bgColor.close="\x1B[49m",b.color.ansi=t5(),b.color.ansi256=r5(),b.color.ansi16m=e5(),b.bgColor.ansi=t5(10),b.bgColor.ansi256=r5(10),b.bgColor.ansi16m=e5(10),Object.defineProperties(b,{rgbToAnsi256:{value(G,J,K){if(G===J&&J===K){if(G<8)return 16;if(G>248)return 231;return Math.round((G-8)/247*24)+232}return 16+36*Math.round(G/255*5)+6*Math.round(J/255*5)+Math.round(K/255*5)},enumerable:!1},hexToRgb:{value(G){const J=/[a-f\d]{6}|[a-f\d]{3}/i.exec(G.toString(16));if(!J)return[0,0,0];let[K]=J;if(K.length===3)K=[...K].map((w)=>w+w).join("");const W=Number.parseInt(K,16);return[W>>16&255,W>>8&255,W&255]},enumerable:!1},hexToAnsi256:{value:(G)=>b.rgbToAnsi256(...b.hexToRgb(G)),enumerable:!1},ansi256ToAnsi:{value(G){if(G<8)return 30+G;if(G<16)return 90+(G-8);let J,K,W;if(G>=232)J=((G-232)*10+8)/255,K=J,W=J;else{G-=16;const O=G%36;J=Math.floor(G/36)/5,K=Math.floor(O/6)/5,W=O%6/5}const w=Math.max(J,K,W)*2;if(w===0)return 30;let H=30+(Math.round(W)<<2|Math.round(K)<<1|Math.round(J));if(w===2)H+=60;return H},enumerable:!1},rgbToAnsi:{value:(G,J,K)=>b.ansi256ToAnsi(b.rgbToAnsi256(G,J,K)),enumerable:!1},hexToAnsi:{value:(G)=>b.ansi256ToAnsi(b.hexToAnsi256(G)),enumerable:!1}}),b};var t5=(X=0)=>(G)=>`\x1B[${G+X}m`,r5=(X=0)=>(G)=>`\x1B[${38+X};5;${G}m`,e5=(X=0)=>(G,J,K)=>`\x1B[${38+X};2;${G};${J};${K}m`,b={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}},AG=Object.keys(b.modifier),eQ=Object.keys(b.color),$X=Object.keys(b.bgColor),xG=[...eQ,...$X],XX=QX(),Y0=XX;import D4 from"node:process";import GX from"node:os";import $6 from"node:tty";var Z0=function(X,G=globalThis.Deno?globalThis.Deno.args:D4.argv){const J=X.startsWith("-")?"":X.length===1?"-":"--",K=G.indexOf(J+X),W=G.indexOf("--");return K!==-1&&(W===-1||K<W)},ZX=function(){if("FORCE_COLOR"in m){if(m.FORCE_COLOR==="true")return 1;if(m.FORCE_COLOR==="false")return 0;return m.FORCE_COLOR.length===0?1:Math.min(Number.parseInt(m.FORCE_COLOR,10),3)}},JX=function(X){if(X===0)return!1;return{level:X,hasBasic:!0,has256:X>=2,has16m:X>=3}},KX=function(X,{streamIsTTY:G,sniffFlags:J=!0}={}){const K=ZX();if(K!==void 0)I$=K;const W=J?I$:K;if(W===0)return 0;if(J){if(Z0("color=16m")||Z0("color=full")||Z0("color=truecolor"))return 3;if(Z0("color=256"))return 2}if("TF_BUILD"in m&&"AGENT_NAME"in m)return 1;if(X&&!G&&W===void 0)return 0;const w=W||0;if(m.TERM==="dumb")return w;if(D4.platform==="win32"){const H=GX.release().split(".");if(Number(H[0])>=10&&Number(H[2])>=10586)return Number(H[2])>=14931?3:2;return 1}if("CI"in m){if("GITHUB_ACTIONS"in m||"GITEA_ACTIONS"in m)return 3;if(["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","BUILDKITE","DRONE"].some((H)=>(H in m))||m.CI_NAME==="codeship")return 1;return w}if("TEAMCITY_VERSION"in m)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(m.TEAMCITY_VERSION)?1:0;if(m.COLORTERM==="truecolor")return 3;if(m.TERM==="xterm-kitty")return 3;if("TERM_PROGRAM"in m){const H=Number.parseInt((m.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(m.TERM_PROGRAM){case"iTerm.app":return H>=3?3:2;case"Apple_Terminal":return 2}}if(/-256(color)?$/i.test(m.TERM))return 2;if(/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(m.TERM))return 1;if("COLORTERM"in m)return 1;return w};function Q6(X,G={}){const J=KX(X,{streamIsTTY:X&&X.isTTY,...G});return JX(J)}var{env:m}=D4,I$;if(Z0("no-color")||Z0("no-colors")||Z0("color=false")||Z0("color=never"))I$=0;else if(Z0("color")||Z0("colors")||Z0("color=true")||Z0("color=always"))I$=1;var WX={stdout:Q6({isTTY:$6.isatty(1)}),stderr:Q6({isTTY:$6.isatty(2)})},X6=WX;function G6(X,G,J){let K=X.indexOf(G);if(K===-1)return X;const W=G.length;let w=0,H="";do H+=X.slice(w,K)+G+J,w=K+W,K=X.indexOf(G,w);while(K!==-1);return H+=X.slice(w),H}function Z6(X,G,J,K){let W=0,w="";do{const H=X[K-1]==="\r";w+=X.slice(W,H?K-1:K)+G+(H?"\r\n":"\n")+J,W=K+1,K=X.indexOf("\n",W)}while(K!==-1);return w+=X.slice(W),w}var g1=function(X){return wX(X)};var{stdout:J6,stderr:K6}=X6,C4=Symbol("GENERATOR"),H1=Symbol("STYLER"),h1=Symbol("IS_EMPTY"),W6=["ansi","ansi","ansi256","ansi16m"],O1=Object.create(null),YX=(X,G={})=>{if(G.level&&!(Number.isInteger(G.level)&&G.level>=0&&G.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const J=J6?J6.level:0;X.level=G.level===void 0?J:G.level};var wX=(X)=>{const G=(...J)=>J.join(" ");return YX(G,X),Object.setPrototypeOf(G,g1.prototype),G};Object.setPrototypeOf(g1.prototype,Function.prototype);for(let[X,G]of Object.entries(Y0))O1[X]={get(){const J=P$(this,x4(G.open,G.close,this[H1]),this[h1]);return Object.defineProperty(this,X,{value:J}),J}};O1.visible={get(){const X=P$(this,this[H1],!0);return Object.defineProperty(this,"visible",{value:X}),X}};var A4=(X,G,J,...K)=>{if(X==="rgb"){if(G==="ansi16m")return Y0[J].ansi16m(...K);if(G==="ansi256")return Y0[J].ansi256(Y0.rgbToAnsi256(...K));return Y0[J].ansi(Y0.rgbToAnsi(...K))}if(X==="hex")return A4("rgb",G,J,...Y0.hexToRgb(...K));return Y0[J][X](...K)},VX=["rgb","hex","ansi256"];for(let X of VX){O1[X]={get(){const{level:J}=this;return function(...K){const W=x4(A4(X,W6[J],"color",...K),Y0.color.close,this[H1]);return P$(this,W,this[h1])}}};const G="bg"+X[0].toUpperCase()+X.slice(1);O1[G]={get(){const{level:J}=this;return function(...K){const W=x4(A4(X,W6[J],"bgColor",...K),Y0.bgColor.close,this[H1]);return P$(this,W,this[h1])}}}}var zX=Object.defineProperties(()=>{},{...O1,level:{enumerable:!0,get(){return this[C4].level},set(X){this[C4].level=X}}}),x4=(X,G,J)=>{let K,W;if(J===void 0)K=X,W=G;else K=J.openAll+X,W=G+J.closeAll;return{open:X,close:G,openAll:K,closeAll:W,parent:J}},P$=(X,G,J)=>{const K=(...W)=>HX(K,W.length===1?""+W[0]:W.join(" "));return Object.setPrototypeOf(K,zX),K[C4]=X,K[H1]=G,K[h1]=J,K},HX=(X,G)=>{if(X.level<=0||!G)return X[h1]?"":G;let J=X[H1];if(J===void 0)return G;const{openAll:K,closeAll:W}=J;if(G.includes("\x1B"))while(J!==void 0)G=G6(G,J.close,J.open),J=J.parent;const w=G.indexOf("\n");if(w!==-1)G=Z6(G,W,K,w);return K+G+W};Object.defineProperties(g1.prototype,O1);var OX=g1(),_G=g1({level:K6?K6.level:0});var b0=OX;var MX=/d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g,BX=/\b(?:[A-Z]{1,3}[A-Z][TC])(?:[-+]\d{4})?|((?:Australian )?(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time)\b/g,UX=/[^-+\dA-Z]/g;function a(X,G,J,K){if(arguments.length===1&&typeof X==="string"&&!/\d/.test(X))G=X,X=void 0;if(X=X||X===0?X:new Date,!(X instanceof Date))X=new Date(X);if(isNaN(X))throw TypeError("Invalid date");G=String(Y6[G]||G||Y6.default);var W=G.slice(0,4);if(W==="UTC:"||W==="GMT:"){if(G=G.slice(4),J=!0,W==="GMT:")K=!0}var w=function P(){return J?"getUTC":"get"},H=function P(){return X[w()+"Date"]()},O=function P(){return X[w()+"Day"]()},I=function P(){return X[w()+"Month"]()},B=function P(){return X[w()+"FullYear"]()},U=function P(){return X[w()+"Hours"]()},_=function P(){return X[w()+"Minutes"]()},T=function P(){return X[w()+"Seconds"]()},E=function P(){return X[w()+"Milliseconds"]()},C=function P(){return J?0:X.getTimezoneOffset()},S=function P(){return IX(X)},L=function P(){return PX(X)},F={d:function P(){return H()},dd:function P(){return r(H())},ddd:function P(){return s.dayNames[O()]},DDD:function P(){return w6({y:B(),m:I(),d:H(),_:w(),dayName:s.dayNames[O()],short:!0})},dddd:function P(){return s.dayNames[O()+7]},DDDD:function P(){return w6({y:B(),m:I(),d:H(),_:w(),dayName:s.dayNames[O()+7]})},m:function P(){return I()+1},mm:function P(){return r(I()+1)},mmm:function P(){return s.monthNames[I()]},mmmm:function P(){return s.monthNames[I()+12]},yy:function P(){return String(B()).slice(2)},yyyy:function P(){return r(B(),4)},h:function P(){return U()%12||12},hh:function P(){return r(U()%12||12)},H:function P(){return U()},HH:function P(){return r(U())},M:function P(){return _()},MM:function P(){return r(_())},s:function P(){return T()},ss:function P(){return r(T())},l:function P(){return r(E(),3)},L:function P(){return r(Math.floor(E()/10))},t:function P(){return U()<12?s.timeNames[0]:s.timeNames[1]},tt:function P(){return U()<12?s.timeNames[2]:s.timeNames[3]},T:function P(){return U()<12?s.timeNames[4]:s.timeNames[5]},TT:function P(){return U()<12?s.timeNames[6]:s.timeNames[7]},Z:function P(){return K?"GMT":J?"UTC":DX(X)},o:function P(){return(C()>0?"-":"+")+r(Math.floor(Math.abs(C())/60)*100+Math.abs(C())%60,4)},p:function P(){return(C()>0?"-":"+")+r(Math.floor(Math.abs(C())/60),2)+":"+r(Math.floor(Math.abs(C())%60),2)},S:function P(){return["th","st","nd","rd"][H()%10>3?0:(H()%100-H()%10!=10)*H()%10]},W:function P(){return S()},WW:function P(){return r(S())},N:function P(){return L()}};return G.replace(MX,function(P){if(P in F)return F[P]();return P.slice(1,P.length-1)})}var Y6={default:"ddd mmm dd yyyy HH:MM:ss",shortDate:"m/d/yy",paddedShortDate:"mm/dd/yyyy",mediumDate:"mmm d, yyyy",longDate:"mmmm d, yyyy",fullDate:"dddd, mmmm d, yyyy",shortTime:"h:MM TT",mediumTime:"h:MM:ss TT",longTime:"h:MM:ss TT Z",isoDate:"yyyy-mm-dd",isoTime:"HH:MM:ss",isoDateTime:"yyyy-mm-dd'T'HH:MM:sso",isoUtcDateTime:"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",expiresHeaderFormat:"ddd, dd mmm yyyy HH:MM:ss Z"},s={dayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","January","February","March","April","May","June","July","August","September","October","November","December"],timeNames:["a","p","am","pm","A","P","AM","PM"]},r=function X(G){var J=arguments.length>1&&arguments[1]!==void 0?arguments[1]:2;return String(G).padStart(J,"0")},w6=function X(G){var{y:J,m:K,d:W,_:w,dayName:H,short:O}=G,I=O===void 0?!1:O,B=new Date,U=new Date;U.setDate(U[w+"Date"]()-1);var _=new Date;_.setDate(_[w+"Date"]()+1);var T=function j(){return B[w+"Date"]()},E=function j(){return B[w+"Month"]()},C=function j(){return B[w+"FullYear"]()},S=function j(){return U[w+"Date"]()},L=function j(){return U[w+"Month"]()},F=function j(){return U[w+"FullYear"]()},P=function j(){return _[w+"Date"]()},y=function j(){return _[w+"Month"]()},f=function j(){return _[w+"FullYear"]()};if(C()===J&&E()===K&&T()===W)return I?"Tdy":"Today";else if(F()===J&&L()===K&&S()===W)return I?"Ysd":"Yesterday";else if(f()===J&&y()===K&&P()===W)return I?"Tmw":"Tomorrow";return H},IX=function X(G){var J=new Date(G.getFullYear(),G.getMonth(),G.getDate());J.setDate(J.getDate()-(J.getDay()+6)%7+3);var K=new Date(J.getFullYear(),0,4);K.setDate(K.getDate()-(K.getDay()+6)%7+3);var W=J.getTimezoneOffset()-K.getTimezoneOffset();J.setHours(J.getHours()-W);var w=(J-K)/604800000;return 1+Math.floor(w)},PX=function X(G){var J=G.getDay();if(J===0)J=7;return J},DX=function X(G){return(String(G).match(BX)||[""]).pop().replace(UX,"").replace(/GMT\+0000/g,"UTC")};import*as V0 from"node:fs";import lX from"node:http";import nX from"node:https";import I1 from"node:zlib";import d6,{PassThrough as i6,pipeline as P1} from"node:stream";import{Buffer as T$} from"node:buffer";function CX(X){if(!/^data:/i.test(X))throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');X=X.replace(/\r?\n/g,"");const G=X.indexOf(",");if(G===-1||G<=4)throw new TypeError("malformed data: URI");const J=X.substring(5,G).split(";");let K="",W=!1;const w=J[0]||"text/plain";let H=w;for(let U=1;U<J.length;U++)if(J[U]==="base64")W=!0;else if(J[U]){if(H+=`;${J[U]}`,J[U].indexOf("charset=")===0)K=J[U].substring(8)}if(!J[0]&&!K.length)H+=";charset=US-ASCII",K="US-ASCII";const O=W?"base64":"ascii",I=unescape(X.substring(G+1)),B=Buffer.from(I,O);return B.type=w,B.typeFull=H,B.charset=K,B}var V6=CX;y1();C$();import p0,{PassThrough as k6} from"node:stream";import{types as L6,deprecate as R4,promisify as gX} from"node:util";import{Buffer as J0} from"node:buffer";class m0 extends Error{constructor(X,G){super(X);Error.captureStackTrace(this,this.constructor),this.type=G}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class e extends m0{constructor(X,G,J){super(X,G);if(J)this.code=this.errno=J.code,this.erroredSysCall=J.syscall}}var A$=Symbol.toStringTag,q4=(X)=>{return typeof X==="object"&&typeof X.append==="function"&&typeof X.delete==="function"&&typeof X.get==="function"&&typeof X.getAll==="function"&&typeof X.has==="function"&&typeof X.set==="function"&&typeof X.sort==="function"&&X[A$]==="URLSearchParams"},m1=(X)=>{return X&&typeof X==="object"&&typeof X.arrayBuffer==="function"&&typeof X.type==="string"&&typeof X.stream==="function"&&typeof X.constructor==="function"&&/^(Blob|File)$/.test(X[A$])},D6=(X)=>{return typeof X==="object"&&(X[A$]==="AbortSignal"||X[A$]==="EventTarget")},C6=(X,G)=>{const J=new URL(G).hostname,K=new URL(X).hostname;return J===K||J.endsWith(`.${K}`)},A6=(X,G)=>{const J=new URL(G).protocol,K=new URL(X).protocol;return J===K};async function T4(X){if(X[o].disturbed)throw new TypeError(`body used already for: ${X.url}`);if(X[o].disturbed=!0,X[o].error)throw X[o].error;const{body:G}=X;if(G===null)return J0.alloc(0);if(!(G instanceof p0))return J0.alloc(0);const J=[];let K=0;try{for await(let W of G){if(X.size>0&&K+W.length>X.size){const w=new e(`content size at ${X.url} over limit: ${X.size}`,"max-size");throw G.destroy(w),w}K+=W.length,J.push(W)}}catch(W){throw W instanceof m0?W:new e(`Invalid response body while trying to fetch ${X.url}: ${W.message}`,"system",W)}if(G.readableEnded===!0||G._readableState.ended===!0)try{if(J.every((W)=>typeof W==="string"))return J0.from(J.join(""));return J0.concat(J,K)}catch(W){throw new e(`Could not create Buffer from response body for ${X.url}: ${W.message}`,"system",W)}else throw new e(`Premature close of server response while trying to fetch ${X.url}`)}var yX=gX(p0.pipeline),o=Symbol("Body internals");class T0{constructor(X,{size:G=0}={}){let J=null;if(X===null)X=null;else if(q4(X))X=J0.from(X.toString());else if(m1(X));else if(J0.isBuffer(X));else if(L6.isAnyArrayBuffer(X))X=J0.from(X);else if(ArrayBuffer.isView(X))X=J0.from(X.buffer,X.byteOffset,X.byteLength);else if(X instanceof p0);else if(X instanceof r0)X=P6(X),J=X.type.split("=")[1];else X=J0.from(String(X));let K=X;if(J0.isBuffer(X))K=p0.Readable.from(X);else if(m1(X))K=p0.Readable.from(X.stream());if(this[o]={body:X,stream:K,boundary:J,disturbed:!1,error:null},this.size=G,X instanceof p0)X.on("error",(W)=>{const w=W instanceof m0?W:new e(`Invalid response body while trying to fetch ${this.url}: ${W.message}`,"system",W);this[o].error=w})}get body(){return this[o].stream}get bodyUsed(){return this[o].disturbed}async arrayBuffer(){const{buffer:X,byteOffset:G,byteLength:J}=await T4(this);return X.slice(G,G+J)}async formData(){const X=this.headers.get("content-type");if(X.startsWith("application/x-www-form-urlencoded")){const J=new r0,K=new URLSearchParams(await this.text());for(let[W,w]of K)J.append(W,w);return J}const{toFormData:G}=await Promise.resolve().then(() => (R6(),T6));return G(this.body,X)}async blob(){const X=this.headers&&this.headers.get("content-type")||this[o].body&&this[o].body.type||"",G=await this.arrayBuffer();return new j0([G],{type:X})}async json(){const X=await this.text();return JSON.parse(X)}async text(){const X=await T4(this);return(new TextDecoder()).decode(X)}buffer(){return T4(this)}}T0.prototype.buffer=R4(T0.prototype.buffer,"Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'","node-fetch#buffer");Object.defineProperties(T0.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0},data:{get:R4(()=>{},"data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});var B1=(X,G)=>{let J,K,{body:W}=X[o];if(X.bodyUsed)throw new Error("cannot clone body after it is used");if(W instanceof p0&&typeof W.getBoundary!=="function")J=new k6({highWaterMark:G}),K=new k6({highWaterMark:G}),W.pipe(J),W.pipe(K),X[o].stream=J,W=K;return W},bX=R4((X)=>X.getBoundary(),"form-data doesn\'t follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167"),F$=(X,G)=>{if(X===null)return null;if(typeof X==="string")return"text/plain;charset=UTF-8";if(q4(X))return"application/x-www-form-urlencoded;charset=UTF-8";if(m1(X))return X.type||null;if(J0.isBuffer(X)||L6.isAnyArrayBuffer(X)||ArrayBuffer.isView(X))return null;if(X instanceof r0)return`multipart/form-data; boundary=${G[o].boundary}`;if(X&&typeof X.getBoundary==="function")return`multipart/form-data;boundary=${bX(X)}`;if(X instanceof p0)return null;return"text/plain;charset=UTF-8"},_6=(X)=>{const{body:G}=X[o];if(G===null)return 0;if(m1(G))return G.size;if(J0.isBuffer(G))return G.length;if(G&&typeof G.getLengthSync==="function")return G.hasKnownLength&&G.hasKnownLength()?G.getLengthSync():null;return null},S6=async(X,{body:G})=>{if(G===null)X.end();else await yX(G,X)};import{types as v6} from"node:util";import q$ from"node:http";function f6(X=[]){return new $0(X.reduce((G,J,K,W)=>{if(K%2===0)G.push(W.slice(K,K+2));return G},[]).filter(([G,J])=>{try{return N$(G),k4(G,String(J)),!0}catch{return!1}}))}var N$=typeof q$.validateHeaderName==="function"?q$.validateHeaderName:(X)=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(X)){const G=new TypeError(`Header name must be a valid HTTP token [${X}]`);throw Object.defineProperty(G,"code",{value:"ERR_INVALID_HTTP_TOKEN"}),G}},k4=typeof q$.validateHeaderValue==="function"?q$.validateHeaderValue:(X,G)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(G)){const J=new TypeError(`Invalid character in header content ["${X}"]`);throw Object.defineProperty(J,"code",{value:"ERR_INVALID_CHAR"}),J}};class $0 extends URLSearchParams{constructor(X){let G=[];if(X instanceof $0){const J=X.raw();for(let[K,W]of Object.entries(J))G.push(...W.map((w)=>[K,w]))}else if(X==null);else if(typeof X==="object"&&!v6.isBoxedPrimitive(X)){const J=X[Symbol.iterator];if(J==null)G.push(...Object.entries(X));else{if(typeof J!=="function")throw new TypeError("Header pairs must be iterable");G=[...X].map((K)=>{if(typeof K!=="object"||v6.isBoxedPrimitive(K))throw new TypeError("Each header pair must be an iterable object");return[...K]}).map((K)=>{if(K.length!==2)throw new TypeError("Each header pair must be a name/value tuple");return[...K]})}}else throw new TypeError("Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");G=G.length>0?G.map(([J,K])=>{return N$(J),k4(J,String(K)),[String(J).toLowerCase(),String(K)]}):void 0;super(G);return new Proxy(this,{get(J,K,W){switch(K){case"append":case"set":return(w,H)=>{return N$(w),k4(w,String(H)),URLSearchParams.prototype[K].call(J,String(w).toLowerCase(),String(H))};case"delete":case"has":case"getAll":return(w)=>{return N$(w),URLSearchParams.prototype[K].call(J,String(w).toLowerCase())};case"keys":return()=>{return J.sort(),new Set(URLSearchParams.prototype.keys.call(J)).keys()};default:return Reflect.get(J,K,W)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(X){const G=this.getAll(X);if(G.length===0)return null;let J=G.join(", ");if(/^content-encoding$/i.test(X))J=J.toLowerCase();return J}forEach(X,G=void 0){for(let J of this.keys())Reflect.apply(X,G,[this.get(J),J,this])}*values(){for(let X of this.keys())yield this.get(X)}*entries(){for(let X of this.keys())yield[X,this.get(X)]}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce((X,G)=>{return X[G]=this.getAll(G),X},{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce((X,G)=>{const J=this.getAll(G);if(G==="host")X[G]=J[0];else X[G]=J.length>1?J:J[0];return X},{})}}Object.defineProperties($0.prototype,["get","entries","forEach","values"].reduce((X,G)=>{return X[G]={enumerable:!0},X},{}));var mX=new Set([301,302,303,307,308]),j$=(X)=>{return mX.has(X)};var w0=Symbol("Response internals");class l extends T0{constructor(X=null,G={}){super(X,G);const J=G.status!=null?G.status:200,K=new $0(G.headers);if(X!==null&&!K.has("Content-Type")){const W=F$(X,this);if(W)K.append("Content-Type",W)}this[w0]={type:"default",url:G.url,status:J,statusText:G.statusText||"",headers:K,counter:G.counter,highWaterMark:G.highWaterMark}}get type(){return this[w0].type}get url(){return this[w0].url||""}get status(){return this[w0].status}get ok(){return this[w0].status>=200&&this[w0].status<300}get redirected(){return this[w0].counter>0}get statusText(){return this[w0].statusText}get headers(){return this[w0].headers}get highWaterMark(){return this[w0].highWaterMark}clone(){return new l(B1(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(X,G=302){if(!j$(G))throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');return new l(null,{headers:{location:new URL(X).toString()},status:G})}static error(){const X=new l(null,{status:0,statusText:""});return X[w0].type="error",X}static json(X=void 0,G={}){const J=JSON.stringify(X);if(J===void 0)throw new TypeError("data is not JSON serializable");const K=new $0(G&&G.headers);if(!K.has("content-type"))K.set("content-type","application/json");return new l(J,{...G,headers:K})}get[Symbol.toStringTag](){return"Response"}}Object.defineProperties(l.prototype,{type:{enumerable:!0},url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}});import{format as cX} from"node:url";import{deprecate as dX} from"node:util";var h6=(X)=>{if(X.search)return X.search;const G=X.href.length-1,J=X.hash||(X.href[G]==="#"?"#":"");return X.href[G-J.length]==="?"?"?":""};import{isIP as uX} from"node:net";function g6(X,G=!1){if(X==null)return"no-referrer";if(X=new URL(X),/^(about|blob|data):$/.test(X.protocol))return"no-referrer";if(X.username="",X.password="",X.hash="",G)X.pathname="",X.search="";return X}function m6(X){if(!y6.has(X))throw new TypeError(`Invalid referrerPolicy: ${X}`);return X}function pX(X){if(/^(http|ws)s:$/.test(X.protocol))return!0;const G=X.host.replace(/(^\[)|(]$)/g,""),J=uX(G);if(J===4&&/^127\./.test(G))return!0;if(J===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(G))return!0;if(X.host==="localhost"||X.host.endsWith(".localhost"))return!1;if(X.protocol==="file:")return!0;return!1}function U1(X){if(/^about:(blank|srcdoc)$/.test(X))return!0;if(X.protocol==="data:")return!0;if(/^(blob|filesystem):$/.test(X.protocol))return!0;return pX(X)}function u6(X,{referrerURLCallback:G,referrerOriginCallback:J}={}){if(X.referrer==="no-referrer"||X.referrerPolicy==="")return null;const K=X.referrerPolicy;if(X.referrer==="about:client")return"no-referrer";const W=X.referrer;let w=g6(W),H=g6(W,!0);if(w.toString().length>4096)w=H;if(G)w=G(w);if(J)H=J(H);const O=new URL(X.url);switch(K){case"no-referrer":return"no-referrer";case"origin":return H;case"unsafe-url":return w;case"strict-origin":if(U1(w)&&!U1(O))return"no-referrer";return H.toString();case"strict-origin-when-cross-origin":if(w.origin===O.origin)return w;if(U1(w)&&!U1(O))return"no-referrer";return H;case"same-origin":if(w.origin===O.origin)return w;return"no-referrer";case"origin-when-cross-origin":if(w.origin===O.origin)return w;return H;case"no-referrer-when-downgrade":if(U1(w)&&!U1(O))return"no-referrer";return w;default:throw new TypeError(`Invalid referrerPolicy: ${K}`)}}function p6(X){const G=(X.get("referrer-policy")||"").split(/[,\s]+/);let J="";for(let K of G)if(K&&y6.has(K))J=K;return J}var y6=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]),b6="strict-origin-when-cross-origin";var c=Symbol("Request internals"),p1=(X)=>{return typeof X==="object"&&typeof X[c]==="object"},iX=dX(()=>{},".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");class $1 extends T0{constructor(X,G={}){let J;if(p1(X))J=new URL(X.url);else J=new URL(X),X={};if(J.username!==""||J.password!=="")throw new TypeError(`${J} is an url with embedded credentials.`);let K=G.method||X.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(K))K=K.toUpperCase();if(!p1(G)&&"data"in G)iX();if((G.body!=null||p1(X)&&X.body!==null)&&(K==="GET"||K==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");const W=G.body?G.body:p1(X)&&X.body!==null?B1(X):null;super(W,{size:G.size||X.size||0});const w=new $0(G.headers||X.headers||{});if(W!==null&&!w.has("Content-Type")){const I=F$(W,this);if(I)w.set("Content-Type",I)}let H=p1(X)?X.signal:null;if("signal"in G)H=G.signal;if(H!=null&&!D6(H))throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");let O=G.referrer==null?X.referrer:G.referrer;if(O==="")O="no-referrer";else if(O){const I=new URL(O);O=/^about:(\/\/)?client$/.test(I)?"client":I}else O=void 0;this[c]={method:K,redirect:G.redirect||X.redirect||"follow",headers:w,parsedURL:J,signal:H,referrer:O},this.follow=G.follow===void 0?X.follow===void 0?20:X.follow:G.follow,this.compress=G.compress===void 0?X.compress===void 0?!0:X.compress:G.compress,this.counter=G.counter||X.counter||0,this.agent=G.agent||X.agent,this.highWaterMark=G.highWaterMark||X.highWaterMark||16384,this.insecureHTTPParser=G.insecureHTTPParser||X.insecureHTTPParser||!1,this.referrerPolicy=G.referrerPolicy||X.referrerPolicy||""}get method(){return this[c].method}get url(){return cX(this[c].parsedURL)}get headers(){return this[c].headers}get redirect(){return this[c].redirect}get signal(){return this[c].signal}get referrer(){if(this[c].referrer==="no-referrer")return"";if(this[c].referrer==="client")return"about:client";if(this[c].referrer)return this[c].referrer.toString();return}get referrerPolicy(){return this[c].referrerPolicy}set referrerPolicy(X){this[c].referrerPolicy=m6(X)}clone(){return new $1(this)}get[Symbol.toStringTag](){return"Request"}}Object.defineProperties($1.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0},referrer:{enumerable:!0},referrerPolicy:{enumerable:!0}});var c6=(X)=>{const{parsedURL:G}=X[c],J=new $0(X[c].headers);if(!J.has("Accept"))J.set("Accept","*/*");let K=null;if(X.body===null&&/^(post|put)$/i.test(X.method))K="0";if(X.body!==null){const O=_6(X);if(typeof O==="number"&&!Number.isNaN(O))K=String(O)}if(K)J.set("Content-Length",K);if(X.referrerPolicy==="")X.referrerPolicy=b6;if(X.referrer&&X.referrer!=="no-referrer")X[c].referrer=u6(X);else X[c].referrer="no-referrer";if(X[c].referrer instanceof URL)J.set("Referer",X.referrer);if(!J.has("User-Agent"))J.set("User-Agent","node-fetch");if(X.compress&&!J.has("Accept-Encoding"))J.set("Accept-Encoding","gzip, deflate, br");let{agent:W}=X;if(typeof W==="function")W=W(G);const w=h6(G),H={path:G.pathname+w,method:X.method,headers:J[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:X.insecureHTTPParser,agent:W};return{parsedURL:G,options:H}};class L4 extends m0{constructor(X,G="aborted"){super(X,G)}}C$();j4();var aX=function(X,G){const J=T$.from("0\r\n\r\n");let K=!1,W=!1,w;X.on("response",(H)=>{const{headers:O}=H;K=O["transfer-encoding"]==="chunked"&&!O["content-length"]}),X.on("socket",(H)=>{const O=()=>{if(K&&!W){const B=new Error("Premature close");B.code="ERR_STREAM_PREMATURE_CLOSE",G(B)}},I=(B)=>{if(W=T$.compare(B.slice(-5),J)===0,!W&&w)W=T$.compare(w.slice(-3),J.slice(0,3))===0&&T$.compare(B.slice(-2),J.slice(3))===0;w=B};H.prependListener("close",O),H.on("data",I),X.on("close",()=>{H.removeListener("close",O),H.removeListener("data",I)})})};var sX=new Set(["data:","http:","https:"]);async function c1(X,G){return new Promise((J,K)=>{const W=new $1(X,G),{parsedURL:w,options:H}=c6(W);if(!sX.has(w.protocol))throw new TypeError(`node-fetch cannot load ${X}. URL scheme "${w.protocol.replace(/:$/,"")}" is not supported.`);if(w.protocol==="data:"){const C=V6(W.url),S=new l(C,{headers:{"Content-Type":C.typeFull}});J(S);return}const O=(w.protocol==="https:"?nX:lX).request,{signal:I}=W;let B=null;const U=()=>{const C=new L4("The operation was aborted.");if(K(C),W.body&&W.body instanceof d6.Readable)W.body.destroy(C);if(!B||!B.body)return;B.body.emit("error",C)};if(I&&I.aborted){U();return}const _=()=>{U(),E()},T=O(w.toString(),H);if(I)I.addEventListener("abort",_);const E=()=>{if(T.abort(),I)I.removeEventListener("abort",_)};if(T.on("error",(C)=>{K(new e(`request to ${W.url} failed, reason: ${C.message}`,"system",C)),E()}),aX(T,(C)=>{if(B&&B.body)B.body.destroy(C)}),process.version<"v14")T.on("socket",(C)=>{let S;C.prependListener("end",()=>{S=C._eventsCount}),C.prependListener("close",(L)=>{if(B&&S<C._eventsCount&&!L){const F=new Error("Premature close");F.code="ERR_STREAM_PREMATURE_CLOSE",B.body.emit("error",F)}})});T.on("response",(C)=>{T.setTimeout(0);const S=f6(C.rawHeaders);if(j$(C.statusCode)){const f=S.get("Location");let j=null;try{j=f===null?null:new URL(f,W.url)}catch{if(W.redirect!=="manual"){K(new e(`uri requested responds with an invalid redirect URL: ${f}`,"invalid-redirect")),E();return}}switch(W.redirect){case"error":K(new e(`uri requested responds with a redirect, redirect mode is set to error: ${W.url}`,"no-redirect")),E();return;case"manual":break;case"follow":{if(j===null)break;if(W.counter>=W.follow){K(new e(`maximum redirect reached at: ${W.url}`,"max-redirect")),E();return}const p={headers:new $0(W.headers),follow:W.follow,counter:W.counter+1,agent:W.agent,compress:W.compress,method:W.method,body:B1(W),signal:W.signal,size:W.size,referrer:W.referrer,referrerPolicy:W.referrerPolicy};if(!C6(W.url,j)||!A6(W.url,j))for(let A1 of["authorization","www-authenticate","cookie","cookie2"])p.headers.delete(A1);if(C.statusCode!==303&&W.body&&G.body instanceof d6.Readable){K(new e("Cannot follow redirect with body being a readable stream","unsupported-redirect")),E();return}if(C.statusCode===303||(C.statusCode===301||C.statusCode===302)&&W.method==="POST")p.method="GET",p.body=void 0,p.headers.delete("content-length");const C1=p6(S);if(C1)p.referrerPolicy=C1;J(c1(new $1(j,p))),E();return}default:return K(new TypeError(`Redirect option '${W.redirect}' is not a valid value of RequestRedirect`))}}if(I)C.once("end",()=>{I.removeEventListener("abort",_)});let L=P1(C,new i6,(f)=>{if(f)K(f)});if(process.version<"v12.10")C.on("aborted",_);const F={url:W.url,status:C.statusCode,statusText:C.statusMessage,headers:S,size:W.size,counter:W.counter,highWaterMark:W.highWaterMark},P=S.get("Content-Encoding");if(!W.compress||W.method==="HEAD"||P===null||C.statusCode===204||C.statusCode===304){B=new l(L,F),J(B);return}const y={flush:I1.Z_SYNC_FLUSH,finishFlush:I1.Z_SYNC_FLUSH};if(P==="gzip"||P==="x-gzip"){L=P1(L,I1.createGunzip(y),(f)=>{if(f)K(f)}),B=new l(L,F),J(B);return}if(P==="deflate"||P==="x-deflate"){const f=P1(C,new i6,(j)=>{if(j)K(j)});f.once("data",(j)=>{if((j[0]&15)===8)L=P1(L,I1.createInflate(),(p)=>{if(p)K(p)});else L=P1(L,I1.createInflateRaw(),(p)=>{if(p)K(p)});B=new l(L,F),J(B)}),f.once("end",()=>{if(!B)B=new l(L,F),J(B)});return}if(P==="br"){L=P1(L,I1.createBrotliDecompress(),(f)=>{if(f)K(f)}),B=new l(L,F),J(B);return}B=new l(L,F),J(B)}),S6(T,W).catch(K)})}var VZ=P4(Q8(),1),f4={show:{stdoutEnable:!0,mainProgram:!0,subProgram:!0,date:!0,dateformat:"yyyy-mm-dd HH:MM:ss:l Z",level:!0,ignoreLevels:process.env.ENVIRONMENT!="DEV"?["DEBUG"]:[]},logStorage:{path:"./logs",json:!0,txt:!0,splitBy:"day",stratagy:"batch",batch:6,ignoreLevels:process.env.ENVIRONMENT!="DEV"?["DEBUG"]:[]},logWebook:{enable:!1,url:void 0,form:""}};class X8{formatSettings;storageSettings;webhookSettings;mainProcess;subProcess;processID;colours={FATAL:b0.bgRedBright,FATALRATE:b0.bgRedBright,ERROR:b0.red,WARN:b0.yellow,SUCCESS:b0.green,INFO:b0.blue,DEBUG:b0.magenta};logBuffer=[];webhookBuffer=[];constructor(X,G,J={}){try{this.mainProcess=X,this.subProcess=G}catch(K){console.error("There was an issue with initialising process names",K),process.exit(1)}try{this.formatSettings={...f4.show,...J.show}}catch(K){console.error("There was an issue with initialising settings: format Settings",J.show,K),process.exit(1)}try{this.storageSettings={...f4.logStorage,...J.logStorage}}catch(K){console.error("There was an issue with initialising settings: storage Settings",J.logStorage,K),process.exit(1)}try{this.webhookSettings={...f4.logWebook,...J.logWebook}}catch(K){console.error("There was an issue with initialising settings: webhook Settings",J.logWebook,K),process.exit(1)}try{this.success("Initialised Logger"),this.debug("Settings:\n"+JSON.stringify(this.formatSettings,null,4)),this.debug("\n"+JSON.stringify(this.storageSettings,null,4)),this.debug("\n"+JSON.stringify(this.webhookSettings,null,4)+"\n")}catch(K){console.error("There was an issue with logging settings"),process.exit(1)}try{process.on("beforeExit",()=>this.exit("Before exit")),process.on("exit",()=>this.exit("Process exit")),process.on("SIGINT",()=>this.exit("SIGINT")),process.on("SIGTERM",()=>this.exit("SIGTERM")),process.on("uncaughtException",async(K)=>{console.error("Uncaught exception:",K),await this.exit("uncaughtException")})}catch(K){}}sendLog(X,G,J){try{const K=new Date,W=a(K,this.formatSettings.dateformat),w=this.handleLogDatatype(G),H=this.handleLogDatatype(J),O=this.formTxtLog(W,w,X,H);if(this.formatSettings.stdoutEnable&&!this.formatSettings.ignoreLevels.includes(X))console.log(this.colours[X](O));if((this.storageSettings.json||this.storageSettings.txt)&&!this.storageSettings.ignoreLevels.includes(X))this.logToFile(K,W,w,X,H,O);if(this.webhookSettings.enable)this.sendWebhook(K,W,w,X,H,O)}catch(K){console.error("There was an issue logging data",K)}}sendWebhook(X,G,J,K,W,w){if(K=="FATALRATE")return;if(this.webhookSettings.url==null)return;if(this.webhookSettings.form!="discord"){this.error("Currently only discord webhooks have been implemented");return}let H={title:`<${this.mainProcess}.${this.subProcess}> [${K}] ${J}`,description:W!=""?`\`\`\`json\n${W.length>4000?"The data provided is too long for an embed. Check file based or stdout based logs.":W}\n\`\`\``:"",color:null,footer:{text:G}};if(this.webhookBuffer.push(H),this.webhookBuffer.length>8){this.fatalRate("Webhook Buffer too large to send in one message!",this.webhookBuffer.length),this.webhookBuffer=[];return}if(this.webhookBuffer.length==8)c1(this.webhookSettings.url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:`${this.mainProcess}.${this.subProcess}`,content:null,embeds:this.webhookBuffer,attachments:[]})}).then((O)=>{if(O.status!=204)this.fatalRate("Unexpected response from webhook",{status:O.status,message:O.statusText});this.webhookBuffer=[]}).catch((O)=>{this.fatalRate("Webhook failed to send",{error:O})}),this.webhookBuffer=[]}formTxtLog(X,G,J,K){let W="";return W+=this.formatSettings.date?`[${X}] `:"",W+=this.formatSettings.mainProgram||this.formatSettings.subProgram?"<":"",W+=this.formatSettings.mainProgram?this.mainProcess:"",W+=this.formatSettings.mainProgram&&this.formatSettings.subProgram?".":"",W+=this.formatSettings.subProgram?this.subProcess:"",W+=this.formatSettings.mainProgram||this.formatSettings.subProgram?"> ":"",W+=this.formatSettings.level?`[${J}] `:"",W+=G,W+=K!=""?"\nLog Data:\n"+K:"",W}logToFile(X,G,J,K,W,w){const H={date:X,formattedDate:G,mainProcess:this.mainProcess,subProcess:this.subProcess,logLevel:K,logMessage:J,logData:W};let O="";try{O=JSON.stringify(H)}catch(I){this.error("Error converting logJSON to string",{error:I,data:H})}if(this.storageSettings.stratagy=="batch"&&this.storageSettings.batch>1){if(this.logBuffer.push({logTXT:w,logJSONString:O})>=this.storageSettings.batch)this.extractBuffer(X)}else{let{dirLocation:I,logLocation:B}=this.generatePaths(X);if(!V0.existsSync(I))V0.mkdirSync(I,{recursive:!0});if(this.storageSettings.txt){const U=V0.createWriteStream(B+"txt.log",{flags:"a"});U.write(w+"\n"),U.end()}if(this.storageSettings.json){const U=V0.createWriteStream(B+"json.log",{flags:"a"});U.write(O+"\n"),U.end()}}}generatePaths(X){let G="",J=this.storageSettings.path;switch(this.storageSettings.splitBy){case"don't split":J+="/",G+=J+"logs.";break;case"year":J+="/",G+=`${a(X,"yyyy")}.`;break;case"month":J+=`/${a(X,"yyyy")}/`,G+=J+`${a(X,"mm")}.`;break;case"day":J+=`/${a(X,"yyyy/mm")}/`,G+=J+`${a(X,"dd")}.`;break;case"hour":J+=`/${a(X,"yyyy/mm/dd")}/`,G+=J+`${a(X,"HH")}.`;break;case"minute":J+=`/${a(X,"yyyy/mm/dd/HH")}/`,G+=J+`${a(X,"MM")}.`;break;case"second":J+=`/${a(X,"yyyy/mm/dd/HH/MM")}/`,G+=J+`${a(X,"ss")}.`;break;default:this.error("Logger split by value is invalid",this.storageSettings.splitBy);break}return{dirLocation:J,logLocation:G}}extractBuffer(X){let{dirLocation:G,logLocation:J}=this.generatePaths(X);if(!V0.existsSync(G))V0.mkdirSync(G,{recursive:!0});let K="",W="",w=this.logBuffer.length;for(let H=0;H<w;H++){let O=this.logBuffer.shift();if(O==null)this.error("Log buffer item is empty whilst trying to read from it");else K+=O.logTXT+"\n",W+=O.logJSONString+"\n"}if(this.storageSettings.txt){const H=V0.createWriteStream(J+"txt.log",{flags:"a"});H.write(K),H.end()}if(this.storageSettings.json){const H=V0.createWriteStream(J+"json.log",{flags:"a"});H.write(W),H.end()}}handleLogDatatype(X){if(X==null)return"";const G=typeof X;if(G=="string")return X;if(["bigint","boolean","number","symbol","function"].includes(G))return X.toString();if(G=="object")try{return JSON.stringify(X,null,4)}catch(J){return this.error("Datatype of object is not json",{dataType:G,data:X}),""}return this.error("Datatype Error",{dataType:G,data:X}),"Datatype error"}fatal(X,G){this.sendLog("FATAL",X,G)}fatalRate(X,G){this.sendLog("FATALRATE",X,G)}error(X,G){this.sendLog("ERROR",X,G)}err=this.error;warn(X,G){this.sendLog("WARN",X,G)}success(X,G){this.sendLog("SUCCESS",X,G)}info(X,G){this.sendLog("INFO",X,G)}log=this.info;debug(X,G){this.sendLog("DEBUG",X,G)}async exit(X){if(console.log("Shutting down gracefully with reason: ",X),this.storageSettings.stratagy=="batch"){console.log("Clearing file buffer, length:",this.logBuffer.length);try{const G=new Date;this.extractBuffer(G)}catch(G){console.error("There was an issue clearing the log buffer",G)}}if(this.webhookSettings.url!=null&&this.webhookBuffer.length>0){console.log("Sending last discord message, length: ",this.webhookBuffer.length);try{await c1(this.webhookSettings.url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:`${this.mainProcess}.${this.subProcess}`,content:null,embeds:this.webhookBuffer,attachments:[]})}).then((G)=>{if(G.status!=204)console.error("Unexpected response from webhook",{status:G.status,message:G.statusText});this.webhookBuffer=[],console.log("ready to shutdown")}).catch((G)=>{console.error("Webhook failed to send",{error:G})})}catch(G){console.error("There was an issue clearing the webhook buffer")}}setTimeout(()=>{process.exit()},500)}}export{X8 as default};
