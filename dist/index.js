import{createRequire as rQ} from"node:module";var nQ=Object.create;var{defineProperty:I4,getPrototypeOf:sQ,getOwnPropertyNames:aQ}=Object;var oQ=Object.prototype.hasOwnProperty;var D4=(X,G,J)=>{J=X!=null?nQ(sQ(X)):{};const K=G||!X||!X.__esModule?I4(J,"default",{value:X,enumerable:!0}):J;for(let W of aQ(X))if(!oQ.call(K,W))I4(K,W,{get:()=>X[W],enumerable:!0});return K};var g0=(X,G)=>()=>(G||X((G={exports:{}}).exports,G),G.exports);var tQ=(X,G)=>{for(var J in G)I4(X,J,{get:G[J],enumerable:!0,configurable:!0,set:(K)=>G[J]=()=>K})};var f1=(X,G)=>()=>(X&&(G=X(X=0)),G);var y0=rQ(import.meta.url);var O5=g0((D$,z5)=>{(function(X,G){typeof D$==="object"&&typeof z5!=="undefined"?G(D$):typeof define==="function"&&define.amd?define(["exports"],G):(X=typeof globalThis!=="undefined"?globalThis:X||self,G(X.WebStreamsPolyfill={}))})(D$,function(X){function G(){return}function J($){return typeof $==="object"&&$!==null||typeof $==="function"}const K=G;function W($,Q){try{Object.defineProperty($,"name",{value:Q,configurable:!0})}catch(Z){}}const w=Promise,O=Promise.prototype.then,H=Promise.reject.bind(w);function I($){return new w($)}function U($){return I((Q)=>Q($))}function B($){return H($)}function L($,Q,Z){return O.call($,Q,Z)}function T($,Q,Z){L(L($,Q,Z),void 0,K)}function E($,Q){T($,Q)}function C($,Q){T($,void 0,Q)}function S($,Q,Z){return L($,Q,Z)}function _($){L($,void 0,K)}let F=($)=>{if(typeof queueMicrotask==="function")F=queueMicrotask;else{const Q=U(void 0);F=(Z)=>L(Q,Z)}return F($)};function D($,Q,Z){if(typeof $!=="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call($,Q,Z)}function y($,Q,Z){try{return U(D($,Q,Z))}catch(Y){return B(Y)}}const f=16384;class j{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push($){const Q=this._back;let Z=Q;if(Q._elements.length===f-1)Z={_elements:[],_next:void 0};if(Q._elements.push($),Z!==Q)this._back=Z,Q._next=Z;++this._size}shift(){const $=this._front;let Q=$;const Z=this._cursor;let Y=Z+1;const V=$._elements,z=V[Z];if(Y===f)Q=$._next,Y=0;if(--this._size,this._cursor=Y,$!==Q)this._front=Q;return V[Z]=void 0,z}forEach($){let Q=this._cursor,Z=this._front,Y=Z._elements;while(Q!==Y.length||Z._next!==void 0){if(Q===Y.length){if(Z=Z._next,Y=Z._elements,Q=0,Y.length===0)break}$(Y[Q]),++Q}}peek(){const $=this._front,Q=this._cursor;return $._elements[Q]}}const p=Symbol("[[AbortSteps]]"),C1=Symbol("[[ErrorSteps]]"),A1=Symbol("[[CancelSteps]]"),k$=Symbol("[[PullSteps]]"),_$=Symbol("[[ReleaseSteps]]");function h4($,Q){if($._ownerReadableStream=Q,Q._reader=$,Q._state==="readable")S$($);else if(Q._state==="closed")G8($);else g4($,Q._storedError)}function L$($,Q){const Z=$._ownerReadableStream;return W0(Z,Q)}function I0($){const Q=$._ownerReadableStream;if(Q._state==="readable")v$($,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));else Z8($,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));Q._readableStreamController[_$](),Q._reader=void 0,$._ownerReadableStream=void 0}function c1($){return new TypeError("Cannot "+$+" a stream using a released reader")}function S$($){$._closedPromise=I((Q,Z)=>{$._closedPromise_resolve=Q,$._closedPromise_reject=Z})}function g4($,Q){S$($),v$($,Q)}function G8($){S$($),y4($)}function v$($,Q){if($._closedPromise_reject===void 0)return;_($._closedPromise),$._closedPromise_reject(Q),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0}function Z8($,Q){g4($,Q)}function y4($){if($._closedPromise_resolve===void 0)return;$._closedPromise_resolve(void 0),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0}const b4=Number.isFinite||function($){return typeof $==="number"&&isFinite($)},J8=Math.trunc||function($){return $<0?Math.ceil($):Math.floor($)};function K8($){return typeof $==="object"||typeof $==="function"}function z0($,Q){if($!==void 0&&!K8($))throw new TypeError(`${Q} is not an object.`)}function Q0($,Q){if(typeof $!=="function")throw new TypeError(`${Q} is not a function.`)}function W8($){return typeof $==="object"&&$!==null||typeof $==="function"}function m4($,Q){if(!W8($))throw new TypeError(`${Q} is not an object.`)}function D0($,Q,Z){if($===void 0)throw new TypeError(`Parameter ${Q} is required in '${Z}'.`)}function f$($,Q,Z){if($===void 0)throw new TypeError(`${Q} is required in '${Z}'.`)}function h$($){return Number($)}function u4($){return $===0?0:$}function Y8($){return u4(J8($))}function g$($,Q){const Y=Number.MAX_SAFE_INTEGER;let V=Number($);if(V=u4(V),!b4(V))throw new TypeError(`${Q} is not a finite number`);if(V=Y8(V),V<0||V>Y)throw new TypeError(`${Q} is outside the accepted range of 0 to ${Y}, inclusive`);if(!b4(V)||V===0)return 0;return V}function y$($,Q){if(!v0($))throw new TypeError(`${Q} is not a ReadableStream.`)}function Q1($){return new P0($)}function p4($,Q){$._reader._readRequests.push(Q)}function b$($,Q,Z){const V=$._reader._readRequests.shift();if(Z)V._closeSteps();else V._chunkSteps(Q)}function d1($){return $._reader._readRequests.length}function c4($){const Q=$._reader;if(Q===void 0)return!1;if(!k0(Q))return!1;return!0}class P0{constructor($){if(D0($,1,"ReadableStreamDefaultReader"),y$($,"First parameter"),f0($))throw new TypeError("This stream has already been locked for exclusive reading by another reader");h4(this,$),this._readRequests=new j}get closed(){if(!k0(this))return B(i1("closed"));return this._closedPromise}cancel($=void 0){if(!k0(this))return B(i1("cancel"));if(this._ownerReadableStream===void 0)return B(c1("cancel"));return L$(this,$)}read(){if(!k0(this))return B(i1("read"));if(this._ownerReadableStream===void 0)return B(c1("read from"));let $,Q;const Z=I((V,z)=>{$=V,Q=z});return x1(this,{_chunkSteps:(V)=>$({value:V,done:!1}),_closeSteps:()=>$({value:void 0,done:!0}),_errorSteps:(V)=>Q(V)}),Z}releaseLock(){if(!k0(this))throw i1("releaseLock");if(this._ownerReadableStream===void 0)return;w8(this)}}if(Object.defineProperties(P0.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),W(P0.prototype.cancel,"cancel"),W(P0.prototype.read,"read"),W(P0.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(P0.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});function k0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readRequests"))return!1;return $ instanceof P0}function x1($,Q){const Z=$._ownerReadableStream;if(Z._disturbed=!0,Z._state==="closed")Q._closeSteps();else if(Z._state==="errored")Q._errorSteps(Z._storedError);else Z._readableStreamController[k$](Q)}function w8($){I0($);const Q=new TypeError("Reader was released");d4($,Q)}function d4($,Q){const Z=$._readRequests;$._readRequests=new j,Z.forEach((Y)=>{Y._errorSteps(Q)})}function i1($){return new TypeError(`ReadableStreamDefaultReader.prototype.${$} can only be used on a ReadableStreamDefaultReader`)}const V8=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);class m${constructor($,Q){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=$,this._preventCancel=Q}next(){const $=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?S(this._ongoingPromise,$,$):$(),this._ongoingPromise}return($){const Q=()=>this._returnSteps($);return this._ongoingPromise?S(this._ongoingPromise,Q,Q):Q()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const $=this._reader;let Q,Z;const Y=I((z,M)=>{Q=z,Z=M});return x1($,{_chunkSteps:(z)=>{this._ongoingPromise=void 0,F(()=>Q({value:z,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,I0($),Q({value:void 0,done:!0})},_errorSteps:(z)=>{this._ongoingPromise=void 0,this._isFinished=!0,I0($),Z(z)}}),Y}_returnSteps($){if(this._isFinished)return Promise.resolve({value:$,done:!0});this._isFinished=!0;const Q=this._reader;if(!this._preventCancel){const Z=L$(Q,$);return I0(Q),S(Z,()=>({value:$,done:!0}))}return I0(Q),U({value:$,done:!0})}}const i4={next(){if(!l4(this))return B(n4("next"));return this._asyncIteratorImpl.next()},return($){if(!l4(this))return B(n4("return"));return this._asyncIteratorImpl.return($)}};Object.setPrototypeOf(i4,V8);function z8($,Q){const Z=Q1($),Y=new m$(Z,Q),V=Object.create(i4);return V._asyncIteratorImpl=Y,V}function l4($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_asyncIteratorImpl"))return!1;try{return $._asyncIteratorImpl instanceof m$}catch(Q){return!1}}function n4($){return new TypeError(`ReadableStreamAsyncIterator.${$} can only be used on a ReadableSteamAsyncIterator`)}const s4=Number.isNaN||function($){return $!==$};var u$,p$,c$;function E1($){return $.slice()}function a4($,Q,Z,Y,V){new Uint8Array($).set(new Uint8Array(Z,Y,V),Q)}let C0=($)=>{if(typeof $.transfer==="function")C0=(Q)=>Q.transfer();else if(typeof structuredClone==="function")C0=(Q)=>structuredClone(Q,{transfer:[Q]});else C0=(Q)=>Q;return C0($)},_0=($)=>{if(typeof $.detached==="boolean")_0=(Q)=>Q.detached;else _0=(Q)=>Q.byteLength===0;return _0($)};function o4($,Q,Z){if($.slice)return $.slice(Q,Z);const Y=Z-Q,V=new ArrayBuffer(Y);return a4(V,0,$,Q,Y),V}function l1($,Q){const Z=$[Q];if(Z===void 0||Z===null)return;if(typeof Z!=="function")throw new TypeError(`${String(Q)} is not a function`);return Z}function O8($){const Q={[Symbol.iterator]:()=>$.iterator},Z=async function*(){return yield*Q}(),Y=Z.next;return{iterator:Z,nextMethod:Y,done:!1}}const d$=(c$=(u$=Symbol.asyncIterator)!==null&&u$!==void 0?u$:(p$=Symbol.for)===null||p$===void 0?void 0:p$.call(Symbol,"Symbol.asyncIterator"))!==null&&c$!==void 0?c$:"@@asyncIterator";function t4($,Q="sync",Z){if(Z===void 0)if(Q==="async"){if(Z=l1($,d$),Z===void 0){const z=l1($,Symbol.iterator),M=t4($,"sync",z);return O8(M)}}else Z=l1($,Symbol.iterator);if(Z===void 0)throw new TypeError("The object is not iterable");const Y=D(Z,$,[]);if(!J(Y))throw new TypeError("The iterator method must return an object");const V=Y.next;return{iterator:Y,nextMethod:V,done:!1}}function H8($){const Q=D($.nextMethod,$.iterator,[]);if(!J(Q))throw new TypeError("The iterator.next() method must return an object");return Q}function M8($){return Boolean($.done)}function U8($){return $.value}function B8($){if(typeof $!=="number")return!1;if(s4($))return!1;if($<0)return!1;return!0}function r4($){const Q=o4($.buffer,$.byteOffset,$.byteOffset+$.byteLength);return new Uint8Array(Q)}function i$($){const Q=$._queue.shift();if($._queueTotalSize-=Q.size,$._queueTotalSize<0)$._queueTotalSize=0;return Q.value}function l$($,Q,Z){if(!B8(Z)||Z===Infinity)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");$._queue.push({value:Q,size:Z}),$._queueTotalSize+=Z}function I8($){return $._queue.peek().value}function L0($){$._queue=new j,$._queueTotalSize=0}function e4($){return $===DataView}function D8($){return e4($.constructor)}function P8($){if(e4($))return 1;return $.BYTES_PER_ELEMENT}class S0{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!n$(this))throw r$("view");return this._view}respond($){if(!n$(this))throw r$("respond");if(D0($,1,"respond"),$=g$($,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_0(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");o1(this._associatedReadableByteStreamController,$)}respondWithNewView($){if(!n$(this))throw r$("respondWithNewView");if(D0($,1,"respondWithNewView"),!ArrayBuffer.isView($))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_0($.buffer))throw new TypeError("The given view\'s buffer has been detached and so cannot be used as a response");t1(this._associatedReadableByteStreamController,$)}}if(Object.defineProperties(S0.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),W(S0.prototype.respond,"respond"),W(S0.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(S0.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class O0{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!p0(this))throw N1("byobRequest");return t$(this)}get desiredSize(){if(!p0(this))throw N1("desiredSize");return w6(this)}close(){if(!p0(this))throw N1("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const $=this._controlledReadableByteStream._state;if($!=="readable")throw new TypeError(`The stream (in ${$} state) is not in the readable state and cannot be closed`);F1(this)}enqueue($){if(!p0(this))throw N1("enqueue");if(D0($,1,"enqueue"),!ArrayBuffer.isView($))throw new TypeError("chunk must be an array buffer view");if($.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if($.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const Q=this._controlledReadableByteStream._state;if(Q!=="readable")throw new TypeError(`The stream (in ${Q} state) is not in the readable state and cannot be enqueued to`);a1(this,$)}error($=void 0){if(!p0(this))throw N1("error");X0(this,$)}[A1]($){$6(this),L0(this);const Q=this._cancelAlgorithm($);return s1(this),Q}[k$]($){const Q=this._controlledReadableByteStream;if(this._queueTotalSize>0){Y6(this,$);return}const Z=this._autoAllocateChunkSize;if(Z!==void 0){let Y;try{Y=new ArrayBuffer(Z)}catch(z){$._errorSteps(z);return}const V={buffer:Y,bufferByteLength:Z,byteOffset:0,byteLength:Z,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(V)}p4(Q,$),c0(this)}[_$](){if(this._pendingPullIntos.length>0){const $=this._pendingPullIntos.peek();$.readerType="none",this._pendingPullIntos=new j,this._pendingPullIntos.push($)}}}if(Object.defineProperties(O0.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),W(O0.prototype.close,"close"),W(O0.prototype.enqueue,"enqueue"),W(O0.prototype.error,"error"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(O0.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});function p0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledReadableByteStream"))return!1;return $ instanceof O0}function n$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_associatedReadableByteStreamController"))return!1;return $ instanceof S0}function c0($){if(!F8($))return;if($._pulling){$._pullAgain=!0;return}$._pulling=!0;const Z=$._pullAlgorithm();T(Z,()=>{if($._pulling=!1,$._pullAgain)$._pullAgain=!1,c0($);return null},(Y)=>{return X0($,Y),null})}function $6($){a$($),$._pendingPullIntos=new j}function s$($,Q){let Z=!1;if($._state==="closed")Z=!0;const Y=Q6(Q);if(Q.readerType==="default")b$($,Y,Z);else k8($,Y,Z)}function Q6($){const{bytesFilled:Q,elementSize:Z}=$;return new $.viewConstructor($.buffer,$.byteOffset,Q/Z)}function n1($,Q,Z,Y){$._queue.push({buffer:Q,byteOffset:Z,byteLength:Y}),$._queueTotalSize+=Y}function X6($,Q,Z,Y){let V;try{V=o4(Q,Z,Z+Y)}catch(z){throw X0($,z),z}n1($,V,0,Y)}function G6($,Q){if(Q.bytesFilled>0)X6($,Q.buffer,Q.byteOffset,Q.bytesFilled);X1($)}function Z6($,Q){const Z=Math.min($._queueTotalSize,Q.byteLength-Q.bytesFilled),Y=Q.bytesFilled+Z;let V=Z,z=!1;const M=Y%Q.elementSize,P=Y-M;if(P>=Q.minimumFill)V=P-Q.bytesFilled,z=!0;const A=$._queue;while(V>0){const N=A.peek(),q=Math.min(V,N.byteLength),R=Q.byteOffset+Q.bytesFilled;if(a4(Q.buffer,R,N.buffer,N.byteOffset,q),N.byteLength===q)A.shift();else N.byteOffset+=q,N.byteLength-=q;$._queueTotalSize-=q,J6($,q,Q),V-=q}return z}function J6($,Q,Z){Z.bytesFilled+=Q}function K6($){if($._queueTotalSize===0&&$._closeRequested)s1($),_1($._controlledReadableByteStream);else c0($)}function a$($){if($._byobRequest===null)return;$._byobRequest._associatedReadableByteStreamController=void 0,$._byobRequest._view=null,$._byobRequest=null}function o$($){while($._pendingPullIntos.length>0){if($._queueTotalSize===0)return;const Q=$._pendingPullIntos.peek();if(Z6($,Q))X1($),s$($._controlledReadableByteStream,Q)}}function C8($){const Q=$._controlledReadableByteStream._reader;while(Q._readRequests.length>0){if($._queueTotalSize===0)return;const Z=Q._readRequests.shift();Y6($,Z)}}function A8($,Q,Z,Y){const V=$._controlledReadableByteStream,z=Q.constructor,M=P8(z),{byteOffset:P,byteLength:A}=Q,N=Z*M;let q;try{q=C0(Q.buffer)}catch(v){Y._errorSteps(v);return}const R={buffer:q,bufferByteLength:q.byteLength,byteOffset:P,byteLength:A,bytesFilled:0,minimumFill:N,elementSize:M,viewConstructor:z,readerType:"byob"};if($._pendingPullIntos.length>0){$._pendingPullIntos.push(R),O6(V,Y);return}if(V._state==="closed"){const v=new z(R.buffer,R.byteOffset,0);Y._closeSteps(v);return}if($._queueTotalSize>0){if(Z6($,R)){const v=Q6(R);K6($),Y._chunkSteps(v);return}if($._closeRequested){const v=new TypeError("Insufficient bytes to fill elements in the given buffer");X0($,v),Y._errorSteps(v);return}}$._pendingPullIntos.push(R),O6(V,Y),c0($)}function x8($,Q){if(Q.readerType==="none")X1($);const Z=$._controlledReadableByteStream;if(e$(Z))while(H6(Z)>0){const Y=X1($);s$(Z,Y)}}function E8($,Q,Z){if(J6($,Q,Z),Z.readerType==="none"){G6($,Z),o$($);return}if(Z.bytesFilled<Z.minimumFill)return;X1($);const Y=Z.bytesFilled%Z.elementSize;if(Y>0){const V=Z.byteOffset+Z.bytesFilled;X6($,Z.buffer,V-Y,Y)}Z.bytesFilled-=Y,s$($._controlledReadableByteStream,Z),o$($)}function W6($,Q){const Z=$._pendingPullIntos.peek();if(a$($),$._controlledReadableByteStream._state==="closed")x8($,Z);else E8($,Q,Z);c0($)}function X1($){return $._pendingPullIntos.shift()}function F8($){const Q=$._controlledReadableByteStream;if(Q._state!=="readable")return!1;if($._closeRequested)return!1;if(!$._started)return!1;if(c4(Q)&&d1(Q)>0)return!0;if(e$(Q)&&H6(Q)>0)return!0;if(w6($)>0)return!0;return!1}function s1($){$._pullAlgorithm=void 0,$._cancelAlgorithm=void 0}function F1($){const Q=$._controlledReadableByteStream;if($._closeRequested||Q._state!=="readable")return;if($._queueTotalSize>0){$._closeRequested=!0;return}if($._pendingPullIntos.length>0){const Z=$._pendingPullIntos.peek();if(Z.bytesFilled%Z.elementSize!==0){const Y=new TypeError("Insufficient bytes to fill elements in the given buffer");throw X0($,Y),Y}}s1($),_1(Q)}function a1($,Q){const Z=$._controlledReadableByteStream;if($._closeRequested||Z._state!=="readable")return;const{buffer:Y,byteOffset:V,byteLength:z}=Q;if(_0(Y))throw new TypeError("chunk\'s buffer is detached and so cannot be enqueued");const M=C0(Y);if($._pendingPullIntos.length>0){const P=$._pendingPullIntos.peek();if(_0(P.buffer))throw new TypeError("The BYOB request\'s buffer has been detached and so cannot be filled with an enqueued chunk");if(a$($),P.buffer=C0(P.buffer),P.readerType==="none")G6($,P)}if(c4(Z))if(C8($),d1(Z)===0)n1($,M,V,z);else{if($._pendingPullIntos.length>0)X1($);const P=new Uint8Array(M,V,z);b$(Z,P,!1)}else if(e$(Z))n1($,M,V,z),o$($);else n1($,M,V,z);c0($)}function X0($,Q){const Z=$._controlledReadableByteStream;if(Z._state!=="readable")return;$6($),L0($),s1($),g6(Z,Q)}function Y6($,Q){const Z=$._queue.shift();$._queueTotalSize-=Z.byteLength,K6($);const Y=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength);Q._chunkSteps(Y)}function t$($){if($._byobRequest===null&&$._pendingPullIntos.length>0){const Q=$._pendingPullIntos.peek(),Z=new Uint8Array(Q.buffer,Q.byteOffset+Q.bytesFilled,Q.byteLength-Q.bytesFilled),Y=Object.create(S0.prototype);q8(Y,$,Z),$._byobRequest=Y}return $._byobRequest}function w6($){const Q=$._controlledReadableByteStream._state;if(Q==="errored")return null;if(Q==="closed")return 0;return $._strategyHWM-$._queueTotalSize}function o1($,Q){const Z=$._pendingPullIntos.peek();if($._controlledReadableByteStream._state==="closed"){if(Q!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(Q===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(Z.bytesFilled+Q>Z.byteLength)throw new RangeError("bytesWritten out of range")}Z.buffer=C0(Z.buffer),W6($,Q)}function t1($,Q){const Z=$._pendingPullIntos.peek();if($._controlledReadableByteStream._state==="closed"){if(Q.byteLength!==0)throw new TypeError("The view\'s length must be 0 when calling respondWithNewView() on a closed stream")}else if(Q.byteLength===0)throw new TypeError("The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream");if(Z.byteOffset+Z.bytesFilled!==Q.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(Z.bufferByteLength!==Q.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(Z.bytesFilled+Q.byteLength>Z.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const V=Q.byteLength;Z.buffer=C0(Q.buffer),W6($,V)}function V6($,Q,Z,Y,V,z,M){Q._controlledReadableByteStream=$,Q._pullAgain=!1,Q._pulling=!1,Q._byobRequest=null,Q._queue=Q._queueTotalSize=void 0,L0(Q),Q._closeRequested=!1,Q._started=!1,Q._strategyHWM=z,Q._pullAlgorithm=Y,Q._cancelAlgorithm=V,Q._autoAllocateChunkSize=M,Q._pendingPullIntos=new j,$._readableStreamController=Q;const P=Z();T(U(P),()=>{return Q._started=!0,c0(Q),null},(A)=>{return X0(Q,A),null})}function N8($,Q,Z){const Y=Object.create(O0.prototype);let V,z,M;if(Q.start!==void 0)V=()=>Q.start(Y);else V=()=>{return};if(Q.pull!==void 0)z=()=>Q.pull(Y);else z=()=>U(void 0);if(Q.cancel!==void 0)M=(A)=>Q.cancel(A);else M=()=>U(void 0);const P=Q.autoAllocateChunkSize;if(P===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");V6($,Y,V,z,M,Z,P)}function q8($,Q,Z){$._associatedReadableByteStreamController=Q,$._view=Z}function r$($){return new TypeError(`ReadableStreamBYOBRequest.prototype.${$} can only be used on a ReadableStreamBYOBRequest`)}function N1($){return new TypeError(`ReadableByteStreamController.prototype.${$} can only be used on a ReadableByteStreamController`)}function j8($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.mode;return{mode:Z===void 0?void 0:T8(Z,`${Q} has member 'mode' that`)}}function T8($,Q){if($=`${$}`,$!=="byob")throw new TypeError(`${Q} '${$}' is not a valid enumeration value for ReadableStreamReaderMode`);return $}function R8($,Q){var Z;z0($,Q);const Y=(Z=$===null||$===void 0?void 0:$.min)!==null&&Z!==void 0?Z:1;return{min:g$(Y,`${Q} has member 'min' that`)}}function z6($){return new A0($)}function O6($,Q){$._reader._readIntoRequests.push(Q)}function k8($,Q,Z){const V=$._reader._readIntoRequests.shift();if(Z)V._closeSteps(Q);else V._chunkSteps(Q)}function H6($){return $._reader._readIntoRequests.length}function e$($){const Q=$._reader;if(Q===void 0)return!1;if(!d0(Q))return!1;return!0}class A0{constructor($){if(D0($,1,"ReadableStreamBYOBReader"),y$($,"First parameter"),f0($))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!p0($._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");h4(this,$),this._readIntoRequests=new j}get closed(){if(!d0(this))return B(r1("closed"));return this._closedPromise}cancel($=void 0){if(!d0(this))return B(r1("cancel"));if(this._ownerReadableStream===void 0)return B(c1("cancel"));return L$(this,$)}read($,Q={}){if(!d0(this))return B(r1("read"));if(!ArrayBuffer.isView($))return B(new TypeError("view must be an array buffer view"));if($.byteLength===0)return B(new TypeError("view must have non-zero byteLength"));if($.buffer.byteLength===0)return B(new TypeError("view's buffer must have non-zero byteLength"));if(_0($.buffer))return B(new TypeError("view\'s buffer has been detached"));let Z;try{Z=R8(Q,"options")}catch(A){return B(A)}const Y=Z.min;if(Y===0)return B(new TypeError("options.min must be greater than 0"));if(!D8($)){if(Y>$.length)return B(new RangeError("options.min must be less than or equal to view\'s length"))}else if(Y>$.byteLength)return B(new RangeError("options.min must be less than or equal to view\'s byteLength"));if(this._ownerReadableStream===void 0)return B(c1("read from"));let V,z;const M=I((A,N)=>{V=A,z=N});return M6(this,$,Y,{_chunkSteps:(A)=>V({value:A,done:!1}),_closeSteps:(A)=>V({value:A,done:!0}),_errorSteps:(A)=>z(A)}),M}releaseLock(){if(!d0(this))throw r1("releaseLock");if(this._ownerReadableStream===void 0)return;_8(this)}}if(Object.defineProperties(A0.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),W(A0.prototype.cancel,"cancel"),W(A0.prototype.read,"read"),W(A0.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(A0.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});function d0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readIntoRequests"))return!1;return $ instanceof A0}function M6($,Q,Z,Y){const V=$._ownerReadableStream;if(V._disturbed=!0,V._state==="errored")Y._errorSteps(V._storedError);else A8(V._readableStreamController,Q,Z,Y)}function _8($){I0($);const Q=new TypeError("Reader was released");U6($,Q)}function U6($,Q){const Z=$._readIntoRequests;$._readIntoRequests=new j,Z.forEach((Y)=>{Y._errorSteps(Q)})}function r1($){return new TypeError(`ReadableStreamBYOBReader.prototype.${$} can only be used on a ReadableStreamBYOBReader`)}function q1($,Q){const{highWaterMark:Z}=$;if(Z===void 0)return Q;if(s4(Z)||Z<0)throw new RangeError("Invalid highWaterMark");return Z}function e1($){const{size:Q}=$;if(!Q)return()=>1;return Q}function $$($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.highWaterMark,Y=$===null||$===void 0?void 0:$.size;return{highWaterMark:Z===void 0?void 0:h$(Z),size:Y===void 0?void 0:L8(Y,`${Q} has member 'size' that`)}}function L8($,Q){return Q0($,Q),(Z)=>h$($(Z))}function S8($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.abort,Y=$===null||$===void 0?void 0:$.close,V=$===null||$===void 0?void 0:$.start,z=$===null||$===void 0?void 0:$.type,M=$===null||$===void 0?void 0:$.write;return{abort:Z===void 0?void 0:v8(Z,$,`${Q} has member 'abort' that`),close:Y===void 0?void 0:f8(Y,$,`${Q} has member 'close' that`),start:V===void 0?void 0:h8(V,$,`${Q} has member 'start' that`),write:M===void 0?void 0:g8(M,$,`${Q} has member 'write' that`),type:z}}function v8($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function f8($,Q,Z){return Q0($,Z),()=>y($,Q,[])}function h8($,Q,Z){return Q0($,Z),(Y)=>D($,Q,[Y])}function g8($,Q,Z){return Q0($,Z),(Y,V)=>y($,Q,[Y,V])}function B6($,Q){if(!G1($))throw new TypeError(`${Q} is not a WritableStream.`)}function y8($){if(typeof $!=="object"||$===null)return!1;try{return typeof $.aborted==="boolean"}catch(Q){return!1}}const b8=typeof AbortController==="function";function m8(){if(b8)return new AbortController;return}class x0{constructor($={},Q={}){if($===void 0)$=null;else m4($,"First parameter");const Z=$$(Q,"Second parameter"),Y=S8($,"First parameter");if(D6(this),Y.type!==void 0)throw new RangeError("Invalid type is specified");const z=e1(Z),M=q1(Z,1);$Q(this,Y,M,z)}get locked(){if(!G1(this))throw J$("locked");return Z1(this)}abort($=void 0){if(!G1(this))return B(J$("abort"));if(Z1(this))return B(new TypeError("Cannot abort a stream that already has a writer"));return Q$(this,$)}close(){if(!G1(this))return B(J$("close"));if(Z1(this))return B(new TypeError("Cannot close a stream that already has a writer"));if(H0(this))return B(new TypeError("Cannot close an already-closing stream"));return P6(this)}getWriter(){if(!G1(this))throw J$("getWriter");return I6(this)}}if(Object.defineProperties(x0.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),W(x0.prototype.abort,"abort"),W(x0.prototype.close,"close"),W(x0.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(x0.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});function I6($){return new M0($)}function u8($,Q,Z,Y,V=1,z=()=>1){const M=Object.create(x0.prototype);D6(M);const P=Object.create(l0.prototype);return N6(M,P,$,Q,Z,Y,V,z),M}function D6($){$._state="writable",$._storedError=void 0,$._writer=void 0,$._writableStreamController=void 0,$._writeRequests=new j,$._inFlightWriteRequest=void 0,$._closeRequest=void 0,$._inFlightCloseRequest=void 0,$._pendingAbortRequest=void 0,$._backpressure=!1}function G1($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_writableStreamController"))return!1;return $ instanceof x0}function Z1($){if($._writer===void 0)return!1;return!0}function Q$($,Q){var Z;if($._state==="closed"||$._state==="errored")return U(void 0);$._writableStreamController._abortReason=Q,(Z=$._writableStreamController._abortController)===null||Z===void 0||Z.abort(Q);const Y=$._state;if(Y==="closed"||Y==="errored")return U(void 0);if($._pendingAbortRequest!==void 0)return $._pendingAbortRequest._promise;let V=!1;if(Y==="erroring")V=!0,Q=void 0;const z=I((M,P)=>{$._pendingAbortRequest={_promise:void 0,_resolve:M,_reject:P,_reason:Q,_wasAlreadyErroring:V}});if($._pendingAbortRequest._promise=z,!V)Q4($,Q);return z}function P6($){const Q=$._state;if(Q==="closed"||Q==="errored")return B(new TypeError(`The stream (in ${Q} state) is not in the writable state and cannot be closed`));const Z=I((V,z)=>{const M={_resolve:V,_reject:z};$._closeRequest=M}),Y=$._writer;if(Y!==void 0&&$._backpressure&&Q==="writable")w4(Y);return QQ($._writableStreamController),Z}function p8($){return I((Z,Y)=>{const V={_resolve:Z,_reject:Y};$._writeRequests.push(V)})}function $4($,Q){if($._state==="writable"){Q4($,Q);return}X4($)}function Q4($,Q){const Z=$._writableStreamController;$._state="erroring",$._storedError=Q;const Y=$._writer;if(Y!==void 0)A6(Y,Q);if(!n8($)&&Z._started)X4($)}function X4($){$._state="errored",$._writableStreamController[C1]();const Q=$._storedError;if($._writeRequests.forEach((V)=>{V._reject(Q)}),$._writeRequests=new j,$._pendingAbortRequest===void 0){X$($);return}const Z=$._pendingAbortRequest;if($._pendingAbortRequest=void 0,Z._wasAlreadyErroring){Z._reject(Q),X$($);return}const Y=$._writableStreamController[p](Z._reason);T(Y,()=>{return Z._resolve(),X$($),null},(V)=>{return Z._reject(V),X$($),null})}function c8($){$._inFlightWriteRequest._resolve(void 0),$._inFlightWriteRequest=void 0}function d8($,Q){$._inFlightWriteRequest._reject(Q),$._inFlightWriteRequest=void 0,$4($,Q)}function i8($){if($._inFlightCloseRequest._resolve(void 0),$._inFlightCloseRequest=void 0,$._state==="erroring"){if($._storedError=void 0,$._pendingAbortRequest!==void 0)$._pendingAbortRequest._resolve(),$._pendingAbortRequest=void 0}$._state="closed";const Z=$._writer;if(Z!==void 0)R6(Z)}function l8($,Q){if($._inFlightCloseRequest._reject(Q),$._inFlightCloseRequest=void 0,$._pendingAbortRequest!==void 0)$._pendingAbortRequest._reject(Q),$._pendingAbortRequest=void 0;$4($,Q)}function H0($){if($._closeRequest===void 0&&$._inFlightCloseRequest===void 0)return!1;return!0}function n8($){if($._inFlightWriteRequest===void 0&&$._inFlightCloseRequest===void 0)return!1;return!0}function s8($){$._inFlightCloseRequest=$._closeRequest,$._closeRequest=void 0}function a8($){$._inFlightWriteRequest=$._writeRequests.shift()}function X$($){if($._closeRequest!==void 0)$._closeRequest._reject($._storedError),$._closeRequest=void 0;const Q=$._writer;if(Q!==void 0)W4(Q,$._storedError)}function G4($,Q){const Z=$._writer;if(Z!==void 0&&Q!==$._backpressure)if(Q)YQ(Z);else w4(Z);$._backpressure=Q}class M0{constructor($){if(D0($,1,"WritableStreamDefaultWriter"),B6($,"First parameter"),Z1($))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=$,$._writer=this;const Q=$._state;if(Q==="writable"){if(!H0($)&&$._backpressure)W$(this);else k6(this);K$(this)}else if(Q==="erroring")Y4(this,$._storedError),K$(this);else if(Q==="closed")k6(this),KQ(this);else{const Z=$._storedError;Y4(this,Z),T6(this,Z)}}get closed(){if(!i0(this))return B(n0("closed"));return this._closedPromise}get desiredSize(){if(!i0(this))throw n0("desiredSize");if(this._ownerWritableStream===void 0)throw T1("desiredSize");return e8(this)}get ready(){if(!i0(this))return B(n0("ready"));return this._readyPromise}abort($=void 0){if(!i0(this))return B(n0("abort"));if(this._ownerWritableStream===void 0)return B(T1("abort"));return o8(this,$)}close(){if(!i0(this))return B(n0("close"));const $=this._ownerWritableStream;if($===void 0)return B(T1("close"));if(H0($))return B(new TypeError("Cannot close an already-closing stream"));return C6(this)}releaseLock(){if(!i0(this))throw n0("releaseLock");if(this._ownerWritableStream===void 0)return;x6(this)}write($=void 0){if(!i0(this))return B(n0("write"));if(this._ownerWritableStream===void 0)return B(T1("write to"));return E6(this,$)}}if(Object.defineProperties(M0.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),W(M0.prototype.abort,"abort"),W(M0.prototype.close,"close"),W(M0.prototype.releaseLock,"releaseLock"),W(M0.prototype.write,"write"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(M0.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});function i0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_ownerWritableStream"))return!1;return $ instanceof M0}function o8($,Q){const Z=$._ownerWritableStream;return Q$(Z,Q)}function C6($){const Q=$._ownerWritableStream;return P6(Q)}function t8($){const Q=$._ownerWritableStream,Z=Q._state;if(H0(Q)||Z==="closed")return U(void 0);if(Z==="errored")return B(Q._storedError);return C6($)}function r8($,Q){if($._closedPromiseState==="pending")W4($,Q);else WQ($,Q)}function A6($,Q){if($._readyPromiseState==="pending")_6($,Q);else wQ($,Q)}function e8($){const Q=$._ownerWritableStream,Z=Q._state;if(Z==="errored"||Z==="erroring")return null;if(Z==="closed")return 0;return q6(Q._writableStreamController)}function x6($){const Q=$._ownerWritableStream,Z=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");A6($,Z),r8($,Z),Q._writer=void 0,$._ownerWritableStream=void 0}function E6($,Q){const Z=$._ownerWritableStream,Y=Z._writableStreamController,V=XQ(Y,Q);if(Z!==$._ownerWritableStream)return B(T1("write to"));const z=Z._state;if(z==="errored")return B(Z._storedError);if(H0(Z)||z==="closed")return B(new TypeError("The stream is closing or closed and cannot be written to"));if(z==="erroring")return B(Z._storedError);const M=p8(Z);return GQ(Y,Q,V),M}const F6={};class l0{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!Z4(this))throw K4("abortReason");return this._abortReason}get signal(){if(!Z4(this))throw K4("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error($=void 0){if(!Z4(this))throw K4("error");if(this._controlledWritableStream._state!=="writable")return;j6(this,$)}[p]($){const Q=this._abortAlgorithm($);return G$(this),Q}[C1](){L0(this)}}if(Object.defineProperties(l0.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(l0.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});function Z4($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledWritableStream"))return!1;return $ instanceof l0}function N6($,Q,Z,Y,V,z,M,P){Q._controlledWritableStream=$,$._writableStreamController=Q,Q._queue=void 0,Q._queueTotalSize=void 0,L0(Q),Q._abortReason=void 0,Q._abortController=m8(),Q._started=!1,Q._strategySizeAlgorithm=P,Q._strategyHWM=M,Q._writeAlgorithm=Y,Q._closeAlgorithm=V,Q._abortAlgorithm=z;const A=J4(Q);G4($,A);const N=Z(),q=U(N);T(q,()=>{return Q._started=!0,Z$(Q),null},(R)=>{return Q._started=!0,$4($,R),null})}function $Q($,Q,Z,Y){const V=Object.create(l0.prototype);let z,M,P,A;if(Q.start!==void 0)z=()=>Q.start(V);else z=()=>{return};if(Q.write!==void 0)M=(N)=>Q.write(N,V);else M=()=>U(void 0);if(Q.close!==void 0)P=()=>Q.close();else P=()=>U(void 0);if(Q.abort!==void 0)A=(N)=>Q.abort(N);else A=()=>U(void 0);N6($,V,z,M,P,A,Z,Y)}function G$($){$._writeAlgorithm=void 0,$._closeAlgorithm=void 0,$._abortAlgorithm=void 0,$._strategySizeAlgorithm=void 0}function QQ($){l$($,F6,0),Z$($)}function XQ($,Q){try{return $._strategySizeAlgorithm(Q)}catch(Z){return j1($,Z),1}}function q6($){return $._strategyHWM-$._queueTotalSize}function GQ($,Q,Z){try{l$($,Q,Z)}catch(V){j1($,V);return}const Y=$._controlledWritableStream;if(!H0(Y)&&Y._state==="writable"){const V=J4($);G4(Y,V)}Z$($)}function Z$($){const Q=$._controlledWritableStream;if(!$._started)return;if(Q._inFlightWriteRequest!==void 0)return;if(Q._state==="erroring"){X4(Q);return}if($._queue.length===0)return;const Y=I8($);if(Y===F6)ZQ($);else JQ($,Y)}function j1($,Q){if($._controlledWritableStream._state==="writable")j6($,Q)}function ZQ($){const Q=$._controlledWritableStream;s8(Q),i$($);const Z=$._closeAlgorithm();G$($),T(Z,()=>{return i8(Q),null},(Y)=>{return l8(Q,Y),null})}function JQ($,Q){const Z=$._controlledWritableStream;a8(Z);const Y=$._writeAlgorithm(Q);T(Y,()=>{c8(Z);const V=Z._state;if(i$($),!H0(Z)&&V==="writable"){const z=J4($);G4(Z,z)}return Z$($),null},(V)=>{if(Z._state==="writable")G$($);return d8(Z,V),null})}function J4($){return q6($)<=0}function j6($,Q){const Z=$._controlledWritableStream;G$($),Q4(Z,Q)}function J$($){return new TypeError(`WritableStream.prototype.${$} can only be used on a WritableStream`)}function K4($){return new TypeError(`WritableStreamDefaultController.prototype.${$} can only be used on a WritableStreamDefaultController`)}function n0($){return new TypeError(`WritableStreamDefaultWriter.prototype.${$} can only be used on a WritableStreamDefaultWriter`)}function T1($){return new TypeError("Cannot "+$+" a stream using a released writer")}function K$($){$._closedPromise=I((Q,Z)=>{$._closedPromise_resolve=Q,$._closedPromise_reject=Z,$._closedPromiseState="pending"})}function T6($,Q){K$($),W4($,Q)}function KQ($){K$($),R6($)}function W4($,Q){if($._closedPromise_reject===void 0)return;_($._closedPromise),$._closedPromise_reject(Q),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0,$._closedPromiseState="rejected"}function WQ($,Q){T6($,Q)}function R6($){if($._closedPromise_resolve===void 0)return;$._closedPromise_resolve(void 0),$._closedPromise_resolve=void 0,$._closedPromise_reject=void 0,$._closedPromiseState="resolved"}function W$($){$._readyPromise=I((Q,Z)=>{$._readyPromise_resolve=Q,$._readyPromise_reject=Z}),$._readyPromiseState="pending"}function Y4($,Q){W$($),_6($,Q)}function k6($){W$($),w4($)}function _6($,Q){if($._readyPromise_reject===void 0)return;_($._readyPromise),$._readyPromise_reject(Q),$._readyPromise_resolve=void 0,$._readyPromise_reject=void 0,$._readyPromiseState="rejected"}function YQ($){W$($)}function wQ($,Q){Y4($,Q)}function w4($){if($._readyPromise_resolve===void 0)return;$._readyPromise_resolve(void 0),$._readyPromise_resolve=void 0,$._readyPromise_reject=void 0,$._readyPromiseState="fulfilled"}function VQ(){if(typeof globalThis!=="undefined")return globalThis;else if(typeof self!=="undefined")return self;else if(typeof global!=="undefined")return global;return}const V4=VQ();function zQ($){if(!(typeof $==="function"||typeof $==="object"))return!1;if($.name!=="DOMException")return!1;try{return new $,!0}catch(Q){return!1}}function OQ(){const $=V4===null||V4===void 0?void 0:V4.DOMException;return zQ($)?$:void 0}function HQ(){const $=function Q(Z,Y){if(this.message=Z||"",this.name=Y||"Error",Error.captureStackTrace)Error.captureStackTrace(this,this.constructor)};return W($,"DOMException"),$.prototype=Object.create(Error.prototype),Object.defineProperty($.prototype,"constructor",{value:$,writable:!0,configurable:!0}),$}const MQ=OQ()||HQ();function L6($,Q,Z,Y,V,z){const M=Q1($),P=I6(Q);$._disturbed=!0;let A=!1,N=U(void 0);return I((q,R)=>{let v;if(z!==void 0){if(v=()=>{const x=z.reason!==void 0?z.reason:new MQ("Aborted","AbortError"),k=[];if(!Y)k.push(()=>{if(Q._state==="writable")return Q$(Q,x);return U(void 0)});if(!V)k.push(()=>{if($._state==="readable")return W0($,x);return U(void 0)});n(()=>Promise.all(k.map((h)=>h())),!0,x)},z.aborted){v();return}z.addEventListener("abort",v)}function F0(){return I((x,k)=>{function h(t){if(t)x();else L(Y1(),h,k)}h(!1)})}function Y1(){if(A)return U(!0);return L(P._readyPromise,()=>{return I((x,k)=>{x1(M,{_chunkSteps:(h)=>{N=L(E6(P,h),void 0,G),x(!1)},_closeSteps:()=>x(!0),_errorSteps:k})})})}if(N0($,M._closedPromise,(x)=>{if(!Y)n(()=>Q$(Q,x),!0,x);else G0(!0,x);return null}),N0(Q,P._closedPromise,(x)=>{if(!V)n(()=>W0($,x),!0,x);else G0(!0,x);return null}),i($,M._closedPromise,()=>{if(!Z)n(()=>t8(P));else G0();return null}),H0(Q)||Q._state==="closed"){const x=new TypeError("the destination writable stream closed before all data could be piped to it");if(!V)n(()=>W0($,x),!0,x);else G0(!0,x)}_(F0());function h0(){const x=N;return L(N,()=>x!==N?h0():void 0)}function N0(x,k,h){if(x._state==="errored")h(x._storedError);else C(k,h)}function i(x,k,h){if(x._state==="closed")h();else E(k,h)}function n(x,k,h){if(A)return;if(A=!0,Q._state==="writable"&&!H0(Q))E(h0(),t);else t();function t(){return T(x(),()=>q0(k,h),(w1)=>q0(!0,w1)),null}}function G0(x,k){if(A)return;if(A=!0,Q._state==="writable"&&!H0(Q))E(h0(),()=>q0(x,k));else q0(x,k)}function q0(x,k){if(x6(P),I0(M),z!==void 0)z.removeEventListener("abort",v);if(x)R(k);else q(void 0);return null}})}class U0{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Y$(this))throw V$("desiredSize");return z4(this)}close(){if(!Y$(this))throw V$("close");if(!K1(this))throw new TypeError("The stream is not in a state that permits close");s0(this)}enqueue($=void 0){if(!Y$(this))throw V$("enqueue");if(!K1(this))throw new TypeError("The stream is not in a state that permits enqueue");return J1(this,$)}error($=void 0){if(!Y$(this))throw V$("error");K0(this,$)}[A1]($){L0(this);const Q=this._cancelAlgorithm($);return w$(this),Q}[k$]($){const Q=this._controlledReadableStream;if(this._queue.length>0){const Z=i$(this);if(this._closeRequested&&this._queue.length===0)w$(this),_1(Q);else R1(this);$._chunkSteps(Z)}else p4(Q,$),R1(this)}[_$](){}}if(Object.defineProperties(U0.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),W(U0.prototype.close,"close"),W(U0.prototype.enqueue,"enqueue"),W(U0.prototype.error,"error"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(U0.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});function Y$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledReadableStream"))return!1;return $ instanceof U0}function R1($){if(!S6($))return;if($._pulling){$._pullAgain=!0;return}$._pulling=!0;const Z=$._pullAlgorithm();T(Z,()=>{if($._pulling=!1,$._pullAgain)$._pullAgain=!1,R1($);return null},(Y)=>{return K0($,Y),null})}function S6($){const Q=$._controlledReadableStream;if(!K1($))return!1;if(!$._started)return!1;if(f0(Q)&&d1(Q)>0)return!0;if(z4($)>0)return!0;return!1}function w$($){$._pullAlgorithm=void 0,$._cancelAlgorithm=void 0,$._strategySizeAlgorithm=void 0}function s0($){if(!K1($))return;const Q=$._controlledReadableStream;if($._closeRequested=!0,$._queue.length===0)w$($),_1(Q)}function J1($,Q){if(!K1($))return;const Z=$._controlledReadableStream;if(f0(Z)&&d1(Z)>0)b$(Z,Q,!1);else{let Y;try{Y=$._strategySizeAlgorithm(Q)}catch(V){throw K0($,V),V}try{l$($,Q,Y)}catch(V){throw K0($,V),V}}R1($)}function K0($,Q){const Z=$._controlledReadableStream;if(Z._state!=="readable")return;L0($),w$($),g6(Z,Q)}function z4($){const Q=$._controlledReadableStream._state;if(Q==="errored")return null;if(Q==="closed")return 0;return $._strategyHWM-$._queueTotalSize}function UQ($){if(S6($))return!1;return!0}function K1($){const Q=$._controlledReadableStream._state;if(!$._closeRequested&&Q==="readable")return!0;return!1}function v6($,Q,Z,Y,V,z,M){Q._controlledReadableStream=$,Q._queue=void 0,Q._queueTotalSize=void 0,L0(Q),Q._started=!1,Q._closeRequested=!1,Q._pullAgain=!1,Q._pulling=!1,Q._strategySizeAlgorithm=M,Q._strategyHWM=z,Q._pullAlgorithm=Y,Q._cancelAlgorithm=V,$._readableStreamController=Q;const P=Z();T(U(P),()=>{return Q._started=!0,R1(Q),null},(A)=>{return K0(Q,A),null})}function BQ($,Q,Z,Y){const V=Object.create(U0.prototype);let z,M,P;if(Q.start!==void 0)z=()=>Q.start(V);else z=()=>{return};if(Q.pull!==void 0)M=()=>Q.pull(V);else M=()=>U(void 0);if(Q.cancel!==void 0)P=(A)=>Q.cancel(A);else P=()=>U(void 0);v6($,V,z,M,P,Z,Y)}function V$($){return new TypeError(`ReadableStreamDefaultController.prototype.${$} can only be used on a ReadableStreamDefaultController`)}function IQ($,Q){if(p0($._readableStreamController))return PQ($);return DQ($)}function DQ($,Q){const Z=Q1($);let Y=!1,V=!1,z=!1,M=!1,P,A,N,q,R;const v=I((i)=>{R=i});function F0(){if(Y)return V=!0,U(void 0);return Y=!0,x1(Z,{_chunkSteps:(n)=>{F(()=>{V=!1;const G0=n,q0=n;if(!z)J1(N._readableStreamController,G0);if(!M)J1(q._readableStreamController,q0);if(Y=!1,V)F0()})},_closeSteps:()=>{if(Y=!1,!z)s0(N._readableStreamController);if(!M)s0(q._readableStreamController);if(!z||!M)R(void 0)},_errorSteps:()=>{Y=!1}}),U(void 0)}function Y1(i){if(z=!0,P=i,M){const n=E1([P,A]),G0=W0($,n);R(G0)}return v}function h0(i){if(M=!0,A=i,z){const n=E1([P,A]),G0=W0($,n);R(G0)}return v}function N0(){}return N=k1(N0,F0,Y1),q=k1(N0,F0,h0),C(Z._closedPromise,(i)=>{if(K0(N._readableStreamController,i),K0(q._readableStreamController,i),!z||!M)R(void 0);return null}),[N,q]}function PQ($){let Q=Q1($),Z=!1,Y=!1,V=!1,z=!1,M=!1,P,A,N,q,R;const v=I((x)=>{R=x});function F0(x){C(x._closedPromise,(k)=>{if(x!==Q)return null;if(X0(N._readableStreamController,k),X0(q._readableStreamController,k),!z||!M)R(void 0);return null})}function Y1(){if(d0(Q))I0(Q),Q=Q1($),F0(Q);x1(Q,{_chunkSteps:(k)=>{F(()=>{Y=!1,V=!1;const h=k;let t=k;if(!z&&!M)try{t=r4(k)}catch(w1){X0(N._readableStreamController,w1),X0(q._readableStreamController,w1),R(W0($,w1));return}if(!z)a1(N._readableStreamController,h);if(!M)a1(q._readableStreamController,t);if(Z=!1,Y)N0();else if(V)i()})},_closeSteps:()=>{if(Z=!1,!z)F1(N._readableStreamController);if(!M)F1(q._readableStreamController);if(N._readableStreamController._pendingPullIntos.length>0)o1(N._readableStreamController,0);if(q._readableStreamController._pendingPullIntos.length>0)o1(q._readableStreamController,0);if(!z||!M)R(void 0)},_errorSteps:()=>{Z=!1}})}function h0(x,k){if(k0(Q))I0(Q),Q=z6($),F0(Q);const h=k?q:N,t=k?N:q;M6(Q,x,1,{_chunkSteps:(V1)=>{F(()=>{Y=!1,V=!1;const z1=k?M:z;if(!(k?z:M)){let o6;try{o6=r4(V1)}catch(B4){X0(h._readableStreamController,B4),X0(t._readableStreamController,B4),R(W0($,B4));return}if(!z1)t1(h._readableStreamController,V1);a1(t._readableStreamController,o6)}else if(!z1)t1(h._readableStreamController,V1);if(Z=!1,Y)N0();else if(V)i()})},_closeSteps:(V1)=>{Z=!1;const z1=k?M:z,U$=k?z:M;if(!z1)F1(h._readableStreamController);if(!U$)F1(t._readableStreamController);if(V1!==void 0){if(!z1)t1(h._readableStreamController,V1);if(!U$&&t._readableStreamController._pendingPullIntos.length>0)o1(t._readableStreamController,0)}if(!z1||!U$)R(void 0)},_errorSteps:()=>{Z=!1}})}function N0(){if(Z)return Y=!0,U(void 0);Z=!0;const x=t$(N._readableStreamController);if(x===null)Y1();else h0(x._view,!1);return U(void 0)}function i(){if(Z)return V=!0,U(void 0);Z=!0;const x=t$(q._readableStreamController);if(x===null)Y1();else h0(x._view,!0);return U(void 0)}function n(x){if(z=!0,P=x,M){const k=E1([P,A]),h=W0($,k);R(h)}return v}function G0(x){if(M=!0,A=x,z){const k=E1([P,A]),h=W0($,k);R(h)}return v}function q0(){return}return N=h6(q0,N0,n),q=h6(q0,i,G0),F0(Q),[N,q]}function CQ($){return J($)&&typeof $.getReader!=="undefined"}function AQ($){if(CQ($))return EQ($.getReader());return xQ($)}function xQ($){let Q;const Z=t4($,"async"),Y=G;function V(){let M;try{M=H8(Z)}catch(A){return B(A)}const P=U(M);return S(P,(A)=>{if(!J(A))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(M8(A))s0(Q._readableStreamController);else{const q=U8(A);J1(Q._readableStreamController,q)}})}function z(M){const P=Z.iterator;let A;try{A=l1(P,"return")}catch(R){return B(R)}if(A===void 0)return U(void 0);let N;try{N=D(A,P,[M])}catch(R){return B(R)}const q=U(N);return S(q,(R)=>{if(!J(R))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");return})}return Q=k1(Y,V,z,0),Q}function EQ($){let Q;const Z=G;function Y(){let z;try{z=$.read()}catch(M){return B(M)}return S(z,(M)=>{if(!J(M))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(M.done)s0(Q._readableStreamController);else{const P=M.value;J1(Q._readableStreamController,P)}})}function V(z){try{return U($.cancel(z))}catch(M){return B(M)}}return Q=k1(Z,Y,V,0),Q}function FQ($,Q){z0($,Q);const Z=$,Y=Z===null||Z===void 0?void 0:Z.autoAllocateChunkSize,V=Z===null||Z===void 0?void 0:Z.cancel,z=Z===null||Z===void 0?void 0:Z.pull,M=Z===null||Z===void 0?void 0:Z.start,P=Z===null||Z===void 0?void 0:Z.type;return{autoAllocateChunkSize:Y===void 0?void 0:g$(Y,`${Q} has member 'autoAllocateChunkSize' that`),cancel:V===void 0?void 0:NQ(V,Z,`${Q} has member 'cancel' that`),pull:z===void 0?void 0:qQ(z,Z,`${Q} has member 'pull' that`),start:M===void 0?void 0:jQ(M,Z,`${Q} has member 'start' that`),type:P===void 0?void 0:TQ(P,`${Q} has member 'type' that`)}}function NQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function qQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function jQ($,Q,Z){return Q0($,Z),(Y)=>D($,Q,[Y])}function TQ($,Q){if($=`${$}`,$!=="bytes")throw new TypeError(`${Q} '${$}' is not a valid enumeration value for ReadableStreamType`);return $}function RQ($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.preventCancel;return{preventCancel:Boolean(Z)}}function f6($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.preventAbort,Y=$===null||$===void 0?void 0:$.preventCancel,V=$===null||$===void 0?void 0:$.preventClose,z=$===null||$===void 0?void 0:$.signal;if(z!==void 0)kQ(z,`${Q} has member 'signal' that`);return{preventAbort:Boolean(Z),preventCancel:Boolean(Y),preventClose:Boolean(V),signal:z}}function kQ($,Q){if(!y8($))throw new TypeError(`${Q} is not an AbortSignal.`)}function _Q($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.readable;f$(Z,"readable","ReadableWritablePair"),y$(Z,`${Q} has member 'readable' that`);const Y=$===null||$===void 0?void 0:$.writable;return f$(Y,"writable","ReadableWritablePair"),B6(Y,`${Q} has member 'writable' that`),{readable:Z,writable:Y}}class d{constructor($={},Q={}){if($===void 0)$=null;else m4($,"First parameter");const Z=$$(Q,"Second parameter"),Y=FQ($,"First parameter");if(O4(this),Y.type==="bytes"){if(Z.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");const V=q1(Z,0);N8(this,Y,V)}else{const V=e1(Z),z=q1(Z,1);BQ(this,Y,z,V)}}get locked(){if(!v0(this))throw a0("locked");return f0(this)}cancel($=void 0){if(!v0(this))return B(a0("cancel"));if(f0(this))return B(new TypeError("Cannot cancel a stream that already has a reader"));return W0(this,$)}getReader($=void 0){if(!v0(this))throw a0("getReader");if(j8($,"First parameter").mode===void 0)return Q1(this);return z6(this)}pipeThrough($,Q={}){if(!v0(this))throw a0("pipeThrough");D0($,1,"pipeThrough");const Z=_Q($,"First parameter"),Y=f6(Q,"Second parameter");if(f0(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Z1(Z.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");const V=L6(this,Z.writable,Y.preventClose,Y.preventAbort,Y.preventCancel,Y.signal);return _(V),Z.readable}pipeTo($,Q={}){if(!v0(this))return B(a0("pipeTo"));if($===void 0)return B("Parameter 1 is required in 'pipeTo'.");if(!G1($))return B(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let Z;try{Z=f6(Q,"Second parameter")}catch(Y){return B(Y)}if(f0(this))return B(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(Z1($))return B(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));return L6(this,$,Z.preventClose,Z.preventAbort,Z.preventCancel,Z.signal)}tee(){if(!v0(this))throw a0("tee");const $=IQ(this);return E1($)}values($=void 0){if(!v0(this))throw a0("values");const Q=RQ($,"First parameter");return z8(this,Q.preventCancel)}[d$]($){return this.values($)}static from($){return AQ($)}}if(Object.defineProperties(d,{from:{enumerable:!0}}),Object.defineProperties(d.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),W(d.from,"from"),W(d.prototype.cancel,"cancel"),W(d.prototype.getReader,"getReader"),W(d.prototype.pipeThrough,"pipeThrough"),W(d.prototype.pipeTo,"pipeTo"),W(d.prototype.tee,"tee"),W(d.prototype.values,"values"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(d.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0});Object.defineProperty(d.prototype,d$,{value:d.prototype.values,writable:!0,configurable:!0});function k1($,Q,Z,Y=1,V=()=>1){const z=Object.create(d.prototype);O4(z);const M=Object.create(U0.prototype);return v6(z,M,$,Q,Z,Y,V),z}function h6($,Q,Z){const Y=Object.create(d.prototype);O4(Y);const V=Object.create(O0.prototype);return V6(Y,V,$,Q,Z,0,void 0),Y}function O4($){$._state="readable",$._reader=void 0,$._storedError=void 0,$._disturbed=!1}function v0($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_readableStreamController"))return!1;return $ instanceof d}function f0($){if($._reader===void 0)return!1;return!0}function W0($,Q){if($._disturbed=!0,$._state==="closed")return U(void 0);if($._state==="errored")return B($._storedError);_1($);const Z=$._reader;if(Z!==void 0&&d0(Z)){const V=Z._readIntoRequests;Z._readIntoRequests=new j,V.forEach((z)=>{z._closeSteps(void 0)})}const Y=$._readableStreamController[A1](Q);return S(Y,G)}function _1($){$._state="closed";const Q=$._reader;if(Q===void 0)return;if(y4(Q),k0(Q)){const Z=Q._readRequests;Q._readRequests=new j,Z.forEach((Y)=>{Y._closeSteps()})}}function g6($,Q){$._state="errored",$._storedError=Q;const Z=$._reader;if(Z===void 0)return;if(v$(Z,Q),k0(Z))d4(Z,Q);else U6(Z,Q)}function a0($){return new TypeError(`ReadableStream.prototype.${$} can only be used on a ReadableStream`)}function y6($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.highWaterMark;return f$(Z,"highWaterMark","QueuingStrategyInit"),{highWaterMark:h$(Z)}}const b6=($)=>{return $.byteLength};W(b6,"size");class L1{constructor($){D0($,1,"ByteLengthQueuingStrategy"),$=y6($,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=$.highWaterMark}get highWaterMark(){if(!u6(this))throw m6("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!u6(this))throw m6("size");return b6}}if(Object.defineProperties(L1.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(L1.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});function m6($){return new TypeError(`ByteLengthQueuingStrategy.prototype.${$} can only be used on a ByteLengthQueuingStrategy`)}function u6($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_byteLengthQueuingStrategyHighWaterMark"))return!1;return $ instanceof L1}const p6=()=>{return 1};W(p6,"size");class S1{constructor($){D0($,1,"CountQueuingStrategy"),$=y6($,"First parameter"),this._countQueuingStrategyHighWaterMark=$.highWaterMark}get highWaterMark(){if(!d6(this))throw c6("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!d6(this))throw c6("size");return p6}}if(Object.defineProperties(S1.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(S1.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:!0});function c6($){return new TypeError(`CountQueuingStrategy.prototype.${$} can only be used on a CountQueuingStrategy`)}function d6($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_countQueuingStrategyHighWaterMark"))return!1;return $ instanceof S1}function LQ($,Q){z0($,Q);const Z=$===null||$===void 0?void 0:$.cancel,Y=$===null||$===void 0?void 0:$.flush,V=$===null||$===void 0?void 0:$.readableType,z=$===null||$===void 0?void 0:$.start,M=$===null||$===void 0?void 0:$.transform,P=$===null||$===void 0?void 0:$.writableType;return{cancel:Z===void 0?void 0:hQ(Z,$,`${Q} has member 'cancel' that`),flush:Y===void 0?void 0:SQ(Y,$,`${Q} has member 'flush' that`),readableType:V,start:z===void 0?void 0:vQ(z,$,`${Q} has member 'start' that`),transform:M===void 0?void 0:fQ(M,$,`${Q} has member 'transform' that`),writableType:P}}function SQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}function vQ($,Q,Z){return Q0($,Z),(Y)=>D($,Q,[Y])}function fQ($,Q,Z){return Q0($,Z),(Y,V)=>y($,Q,[Y,V])}function hQ($,Q,Z){return Q0($,Z),(Y)=>y($,Q,[Y])}class v1{constructor($={},Q={},Z={}){if($===void 0)$=null;const Y=$$(Q,"Second parameter"),V=$$(Z,"Third parameter"),z=LQ($,"First parameter");if(z.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(z.writableType!==void 0)throw new RangeError("Invalid writableType specified");const M=q1(V,0),P=e1(V),A=q1(Y,1),N=e1(Y);let q;const R=I((v)=>{q=v});if(gQ(this,R,A,N,M,P),bQ(this,z),z.start!==void 0)q(z.start(this._transformStreamController));else q(void 0)}get readable(){if(!i6(this))throw a6("readable");return this._readable}get writable(){if(!i6(this))throw a6("writable");return this._writable}}if(Object.defineProperties(v1.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),typeof Symbol.toStringTag==="symbol")Object.defineProperty(v1.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:!0});function gQ($,Q,Z,Y,V,z){function M(){return Q}function P(v){return pQ($,v)}function A(v){return cQ($,v)}function N(){return dQ($)}$._writable=u8(M,P,N,A,Z,Y);function q(){return iQ($)}function R(v){return lQ($,v)}$._readable=k1(M,q,R,V,z),$._backpressure=void 0,$._backpressureChangePromise=void 0,$._backpressureChangePromise_resolve=void 0,z$($,!0),$._transformStreamController=void 0}function i6($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_transformStreamController"))return!1;return $ instanceof v1}function l6($,Q){K0($._readable._readableStreamController,Q),H4($,Q)}function H4($,Q){H$($._transformStreamController),j1($._writable._writableStreamController,Q),M4($)}function M4($){if($._backpressure)z$($,!1)}function z$($,Q){if($._backpressureChangePromise!==void 0)$._backpressureChangePromise_resolve();$._backpressureChangePromise=I((Z)=>{$._backpressureChangePromise_resolve=Z}),$._backpressure=Q}class E0{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!O$(this))throw M$("desiredSize");const $=this._controlledTransformStream._readable._readableStreamController;return z4($)}enqueue($=void 0){if(!O$(this))throw M$("enqueue");n6(this,$)}error($=void 0){if(!O$(this))throw M$("error");mQ(this,$)}terminate(){if(!O$(this))throw M$("terminate");uQ(this)}}if(Object.defineProperties(E0.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),W(E0.prototype.enqueue,"enqueue"),W(E0.prototype.error,"error"),W(E0.prototype.terminate,"terminate"),typeof Symbol.toStringTag==="symbol")Object.defineProperty(E0.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});function O$($){if(!J($))return!1;if(!Object.prototype.hasOwnProperty.call($,"_controlledTransformStream"))return!1;return $ instanceof E0}function yQ($,Q,Z,Y,V){Q._controlledTransformStream=$,$._transformStreamController=Q,Q._transformAlgorithm=Z,Q._flushAlgorithm=Y,Q._cancelAlgorithm=V,Q._finishPromise=void 0,Q._finishPromise_resolve=void 0,Q._finishPromise_reject=void 0}function bQ($,Q){const Z=Object.create(E0.prototype);let Y,V,z;if(Q.transform!==void 0)Y=(M)=>Q.transform(M,Z);else Y=(M)=>{try{return n6(Z,M),U(void 0)}catch(P){return B(P)}};if(Q.flush!==void 0)V=()=>Q.flush(Z);else V=()=>U(void 0);if(Q.cancel!==void 0)z=(M)=>Q.cancel(M);else z=()=>U(void 0);yQ($,Z,Y,V,z)}function H$($){$._transformAlgorithm=void 0,$._flushAlgorithm=void 0,$._cancelAlgorithm=void 0}function n6($,Q){const Z=$._controlledTransformStream,Y=Z._readable._readableStreamController;if(!K1(Y))throw new TypeError("Readable side is not in a state that permits enqueue");try{J1(Y,Q)}catch(z){throw H4(Z,z),Z._readable._storedError}if(UQ(Y)!==Z._backpressure)z$(Z,!0)}function mQ($,Q){l6($._controlledTransformStream,Q)}function s6($,Q){const Z=$._transformAlgorithm(Q);return S(Z,void 0,(Y)=>{throw l6($._controlledTransformStream,Y),Y})}function uQ($){const Q=$._controlledTransformStream,Z=Q._readable._readableStreamController;s0(Z);const Y=new TypeError("TransformStream terminated");H4(Q,Y)}function pQ($,Q){const Z=$._transformStreamController;if($._backpressure){const Y=$._backpressureChangePromise;return S(Y,()=>{const V=$._writable;if(V._state==="erroring")throw V._storedError;return s6(Z,Q)})}return s6(Z,Q)}function cQ($,Q){const Z=$._transformStreamController;if(Z._finishPromise!==void 0)return Z._finishPromise;const Y=$._readable;Z._finishPromise=I((z,M)=>{Z._finishPromise_resolve=z,Z._finishPromise_reject=M});const V=Z._cancelAlgorithm(Q);return H$(Z),T(V,()=>{if(Y._state==="errored")W1(Z,Y._storedError);else K0(Y._readableStreamController,Q),U4(Z);return null},(z)=>{return K0(Y._readableStreamController,z),W1(Z,z),null}),Z._finishPromise}function dQ($){const Q=$._transformStreamController;if(Q._finishPromise!==void 0)return Q._finishPromise;const Z=$._readable;Q._finishPromise=I((V,z)=>{Q._finishPromise_resolve=V,Q._finishPromise_reject=z});const Y=Q._flushAlgorithm();return H$(Q),T(Y,()=>{if(Z._state==="errored")W1(Q,Z._storedError);else s0(Z._readableStreamController),U4(Q);return null},(V)=>{return K0(Z._readableStreamController,V),W1(Q,V),null}),Q._finishPromise}function iQ($){return z$($,!1),$._backpressureChangePromise}function lQ($,Q){const Z=$._transformStreamController;if(Z._finishPromise!==void 0)return Z._finishPromise;const Y=$._writable;Z._finishPromise=I((z,M)=>{Z._finishPromise_resolve=z,Z._finishPromise_reject=M});const V=Z._cancelAlgorithm(Q);return H$(Z),T(V,()=>{if(Y._state==="errored")W1(Z,Y._storedError);else j1(Y._writableStreamController,Q),M4($),U4(Z);return null},(z)=>{return j1(Y._writableStreamController,z),M4($),W1(Z,z),null}),Z._finishPromise}function M$($){return new TypeError(`TransformStreamDefaultController.prototype.${$} can only be used on a TransformStreamDefaultController`)}function U4($){if($._finishPromise_resolve===void 0)return;$._finishPromise_resolve(),$._finishPromise_resolve=void 0,$._finishPromise_reject=void 0}function W1($,Q){if($._finishPromise_reject===void 0)return;_($._finishPromise),$._finishPromise_reject(Q),$._finishPromise_resolve=void 0,$._finishPromise_reject=void 0}function a6($){return new TypeError(`TransformStream.prototype.${$} can only be used on a TransformStream`)}X.ByteLengthQueuingStrategy=L1,X.CountQueuingStrategy=S1,X.ReadableByteStreamController=O0,X.ReadableStream=d,X.ReadableStreamBYOBReader=A0,X.ReadableStreamBYOBRequest=S0,X.ReadableStreamDefaultController=U0,X.ReadableStreamDefaultReader=P0,X.TransformStream=v1,X.TransformStreamDefaultController=E0,X.WritableStream=x0,X.WritableStreamDefaultController=l0,X.WritableStreamDefaultWriter=M0})});var H5=g0(()=>{if(!globalThis.ReadableStream)try{const X=y0("node:process"),{emitWarning:G}=X;try{X.emitWarning=()=>{},Object.assign(globalThis,y0("node:stream/web")),X.emitWarning=G}catch(J){throw X.emitWarning=G,J}}catch(X){Object.assign(globalThis,O5())}try{const{Blob:X}=y0("buffer");if(X&&!X.prototype.stream)X.prototype.stream=function G(J){let K=0;const W=this;return new ReadableStream({type:"bytes",async pull(w){const H=await W.slice(K,Math.min(W.size,K+65536)).arrayBuffer();if(K+=H.byteLength,w.enqueue(new Uint8Array(H)),K===W.size)w.close()}})}}catch(X){}});async function*E4(X,G=!0){for(let J of X)if("stream"in J)yield*J.stream();else if(ArrayBuffer.isView(J))if(G){let K=J.byteOffset;const W=J.byteOffset+J.byteLength;while(K!==W){const w=Math.min(W-K,M5),O=J.buffer.slice(K,K+w);K+=O.byteLength,yield new Uint8Array(O)}}else yield J;else{let K=0,W=J;while(K!==W.size){const O=await W.slice(K,Math.min(W.size,K+M5)).arrayBuffer();K+=O.byteLength,yield new Uint8Array(O)}}}var yG,M5,U5,AX,j0;var y1=f1(()=>{yG=D4(H5(),1);/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */M5=65536,U5=class X{#$=[];#Q="";#X=0;#G="transparent";constructor(G=[],J={}){if(typeof G!=="object"||G===null)throw new TypeError("Failed to construct \'Blob\': The provided value cannot be converted to a sequence.");if(typeof G[Symbol.iterator]!=="function")throw new TypeError("Failed to construct \'Blob\': The object must have a callable @@iterator property.");if(typeof J!=="object"&&typeof J!=="function")throw new TypeError("Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.");if(J===null)J={};const K=new TextEncoder;for(let w of G){let O;if(ArrayBuffer.isView(w))O=new Uint8Array(w.buffer.slice(w.byteOffset,w.byteOffset+w.byteLength));else if(w instanceof ArrayBuffer)O=new Uint8Array(w.slice(0));else if(w instanceof X)O=w;else O=K.encode(`${w}`);this.#X+=ArrayBuffer.isView(O)?O.byteLength:O.size,this.#$.push(O)}this.#G=`${J.endings===void 0?"transparent":J.endings}`;const W=J.type===void 0?"":String(J.type);this.#Q=/^[\x20-\x7E]*$/.test(W)?W:""}get size(){return this.#X}get type(){return this.#Q}async text(){const G=new TextDecoder;let J="";for await(let K of E4(this.#$,!1))J+=G.decode(K,{stream:!0});return J+=G.decode(),J}async arrayBuffer(){const G=new Uint8Array(this.size);let J=0;for await(let K of E4(this.#$,!1))G.set(K,J),J+=K.length;return G.buffer}stream(){const G=E4(this.#$,!0);return new globalThis.ReadableStream({type:"bytes",async pull(J){const K=await G.next();K.done?J.close():J.enqueue(K.value)},async cancel(){await G.return()}})}slice(G=0,J=this.size,K=""){const{size:W}=this;let w=G<0?Math.max(W+G,0):Math.min(G,W),O=J<0?Math.max(W+J,0):Math.min(J,W);const H=Math.max(O-w,0),I=this.#$,U=[];let B=0;for(let T of I){if(B>=H)break;const E=ArrayBuffer.isView(T)?T.byteLength:T.size;if(w&&E<=w)w-=E,O-=E;else{let C;if(ArrayBuffer.isView(T))C=T.subarray(w,Math.min(E,O)),B+=C.byteLength;else C=T.slice(w,Math.min(E,O)),B+=C.size;O-=E,U.push(C),w=0}}const L=new X([],{type:String(K).toLowerCase()});return L.#X=H,L.#$=U,L}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](G){return G&&typeof G==="object"&&typeof G.constructor==="function"&&(typeof G.stream==="function"||typeof G.arrayBuffer==="function")&&/^(Blob|File)$/.test(G[Symbol.toStringTag])}};Object.defineProperties(U5.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}});AX=U5,j0=AX});var xX,EX,M1;var F4=f1(()=>{y1();xX=class X extends j0{#$=0;#Q="";constructor(G,J,K={}){if(arguments.length<2)throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);super(G,K);if(K===null)K={};const W=K.lastModified===void 0?Date.now():Number(K.lastModified);if(!Number.isNaN(W))this.#$=W;this.#Q=String(J)}get name(){return this.#Q}get lastModified(){return this.#$}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](G){return!!G&&G instanceof j0&&/^(File)$/.test(G[Symbol.toStringTag])}},EX=xX,M1=EX});function D5(X,G=j0){var J=`${B5()}${B5()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),K=[],W=`--${J}\r\nContent-Disposition: form-data; name="`;return X.forEach((w,O)=>typeof w=="string"?K.push(W+N4(O)+`"\r\n\r\n${w.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r\n`):K.push(W+N4(O)+`"; filename="${N4(w.name,1)}"\r\nContent-Type: ${w.type||"application/octet-stream"}\r\n\r\n`,w,"\r\n")),K.push(`--${J}--`),new G(K,{type:"multipart/form-data; boundary="+J})}var b1,FX,NX,B5,qX,I5,N4,t0,r0;var P$=f1(()=>{y1();F4();/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */({toStringTag:b1,iterator:FX,hasInstance:NX}=Symbol),B5=Math.random,qX="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),I5=(X,G,J)=>(X+="",/^(Blob|File)$/.test(G&&G[b1])?[(J=J!==void 0?J+"":G[b1]=="File"?G.name:"blob",X),G.name!==J||G[b1]=="blob"?new M1([G],J,G):G]:[X,G+""]),N4=(X,G)=>(G?X:X.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),t0=(X,G,J)=>{if(G.length<J)throw new TypeError(`Failed to execute '${X}' on 'FormData': ${J} arguments required, but only ${G.length} present.`)},r0=class X{#$=[];constructor(...G){if(G.length)throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.")}get[b1](){return"FormData"}[FX](){return this.entries()}static[NX](G){return G&&typeof G==="object"&&G[b1]==="FormData"&&!qX.some((J)=>typeof G[J]!="function")}append(...G){t0("append",arguments,2),this.#$.push(I5(...G))}delete(G){t0("delete",arguments,1),G+="",this.#$=this.#$.filter(([J])=>J!==G)}get(G){t0("get",arguments,1),G+="";for(var J=this.#$,K=J.length,W=0;W<K;W++)if(J[W][0]===G)return J[W][1];return null}getAll(G,J){return t0("getAll",arguments,1),J=[],G+="",this.#$.forEach((K)=>K[0]===G&&J.push(K[1])),J}has(G){return t0("has",arguments,1),G+="",this.#$.some((J)=>J[0]===G)}forEach(G,J){t0("forEach",arguments,1);for(var[K,W]of this)G.call(J,W,K,this)}set(...G){t0("set",arguments,2);var J=[],K=!0;G=I5(...G),this.#$.forEach((W)=>{W[0]===G[0]?K&&(K=!J.push(G)):J.push(W)}),K&&J.push(G),this.#$=J}*entries(){yield*this.#$}*keys(){for(var[G]of this)yield G}*values(){for(var[,G]of this)yield G}}});var E5=g0((aG,x5)=>{/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */if(!globalThis.DOMException)try{const{MessageChannel:X}=y0("worker_threads"),G=new X().port1,J=new ArrayBuffer;G.postMessage(J,[J,J])}catch(X){X.constructor.name==="DOMException"&&(globalThis.DOMException=X.constructor)}x5.exports=globalThis.DOMException});import{statSync as tG,createReadStream as jX,promises as TX} from"node:fs";class N5{#$;#Q;constructor(X){this.#$=X.path,this.#Q=X.start,this.size=X.size,this.lastModified=X.lastModified}slice(X,G){return new N5({path:this.#$,lastModified:this.lastModified,size:G-X,start:this.#Q+X})}async*stream(){const{mtimeMs:X}=await RX(this.#$);if(X>this.lastModified)throw new F5.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError");yield*jX(this.#$,{start:this.#Q,end:this.#Q+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}var F5,RX;var j4=f1(()=>{F5=D4(E5(),1);F4();y1();({stat:RX}=TX)});var T5={};tQ(T5,{toFormData:()=>{{return hX}}});async function hX(X,G){if(!/multipart/i.test(G))throw new TypeError("Failed to fetch");const J=G.match(/boundary=(?:"([^"]+)"|([^;]+))/i);if(!J)throw new TypeError("no or bad content-type header, no multipart boundary");const K=new j5(J[1]||J[2]);let W,w,O,H,I,U;const B=[],L=new r0,T=(F)=>{O+=_.decode(F,{stream:!0})},E=(F)=>{B.push(F)},C=()=>{const F=new M1(B,U,{type:I});L.append(H,F)},S=()=>{L.append(H,O)},_=new TextDecoder("utf-8");_.decode(),K.onPartBegin=function(){K.onPartData=T,K.onPartEnd=S,W="",w="",O="",H="",I="",U=null,B.length=0},K.onHeaderField=function(F){W+=_.decode(F,{stream:!0})},K.onHeaderValue=function(F){w+=_.decode(F,{stream:!0})},K.onHeaderEnd=function(){if(w+=_.decode(),W=W.toLowerCase(),W==="content-disposition"){const F=w.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);if(F)H=F[2]||F[3]||"";if(U=fX(w),U)K.onPartData=E,K.onPartEnd=C}else if(W==="content-type")I=w;w="",W=""};for await(let F of X)K.write(F);return K.end(),L}class j5{constructor(X){this.index=0,this.flags=0,this.onHeaderEnd=e0,this.onHeaderField=e0,this.onHeadersEnd=e0,this.onHeaderValue=e0,this.onPartBegin=e0,this.onPartData=e0,this.onPartEnd=e0,this.boundaryChars={},X="\r\n--"+X;const G=new Uint8Array(X.length);for(let J=0;J<X.length;J++)G[J]=X.charCodeAt(J),this.boundaryChars[G[J]]=!0;this.boundary=G,this.lookbehind=new Uint8Array(this.boundary.length+8),this.state=g.START_BOUNDARY}write(X){let G=0;const J=X.length;let K=this.index,{lookbehind:W,boundary:w,boundaryChars:O,index:H,state:I,flags:U}=this;const B=this.boundary.length,L=B-1,T=X.length;let E,C;const S=(y)=>{this[y+"Mark"]=G},_=(y)=>{delete this[y+"Mark"]},F=(y,f,j,p)=>{if(f===void 0||f!==j)this[y](p&&p.subarray(f,j))},D=(y,f)=>{const j=y+"Mark";if(!(j in this))return;if(f)F(y,this[j],G,X),delete this[j];else F(y,this[j],X.length,X),this[j]=0};for(G=0;G<J;G++)switch(E=X[G],I){case g.START_BOUNDARY:if(H===w.length-2){if(E===u1)U|=m0.LAST_BOUNDARY;else if(E!==x$)return;H++;break}else if(H-1===w.length-2){if(U&m0.LAST_BOUNDARY&&E===u1)I=g.END,U=0;else if(!(U&m0.LAST_BOUNDARY)&&E===A$)H=0,F("onPartBegin"),I=g.HEADER_FIELD_START;else return;break}if(E!==w[H+2])H=-2;if(E===w[H+2])H++;break;case g.HEADER_FIELD_START:I=g.HEADER_FIELD,S("onHeaderField"),H=0;case g.HEADER_FIELD:if(E===x$){_("onHeaderField"),I=g.HEADERS_ALMOST_DONE;break}if(H++,E===u1)break;if(E===_X){if(H===1)return;D("onHeaderField",!0),I=g.HEADER_VALUE_START;break}if(C=vX(E),C<LX||C>SX)return;break;case g.HEADER_VALUE_START:if(E===kX)break;S("onHeaderValue"),I=g.HEADER_VALUE;case g.HEADER_VALUE:if(E===x$)D("onHeaderValue",!0),F("onHeaderEnd"),I=g.HEADER_VALUE_ALMOST_DONE;break;case g.HEADER_VALUE_ALMOST_DONE:if(E!==A$)return;I=g.HEADER_FIELD_START;break;case g.HEADERS_ALMOST_DONE:if(E!==A$)return;F("onHeadersEnd"),I=g.PART_DATA_START;break;case g.PART_DATA_START:I=g.PART_DATA,S("onPartData");case g.PART_DATA:if(K=H,H===0){G+=L;while(G<T&&!(X[G]in O))G+=B;G-=L,E=X[G]}if(H<w.length)if(w[H]===E){if(H===0)D("onPartData",!0);H++}else H=0;else if(H===w.length)if(H++,E===x$)U|=m0.PART_BOUNDARY;else if(E===u1)U|=m0.LAST_BOUNDARY;else H=0;else if(H-1===w.length)if(U&m0.PART_BOUNDARY){if(H=0,E===A$){U&=~m0.PART_BOUNDARY,F("onPartEnd"),F("onPartBegin"),I=g.HEADER_FIELD_START;break}}else if(U&m0.LAST_BOUNDARY)if(E===u1)F("onPartEnd"),I=g.END,U=0;else H=0;else H=0;if(H>0)W[H-1]=E;else if(K>0){const y=new Uint8Array(W.buffer,W.byteOffset,W.byteLength);F("onPartData",0,K,y),K=0,S("onPartData"),G--}break;case g.END:break;default:throw new Error(`Unexpected state entered: ${I}`)}D("onHeaderField"),D("onHeaderValue"),D("onPartData"),this.index=H,this.state=I,this.flags=U}end(){if(this.state===g.HEADER_FIELD_START&&this.index===0||this.state===g.PART_DATA&&this.index===this.boundary.length)this.onPartEnd();else if(this.state!==g.END)throw new Error("MultipartParser.end(): stream ended unexpectedly")}}var fX,B0,g,q5,m0,A$,x$,kX,u1,_X,LX,SX,vX,e0;var R5=f1(()=>{j4();P$();fX=function(X){const G=X.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);if(!G)return;const J=G[2]||G[3]||"";let K=J.slice(J.lastIndexOf("\\")+1);return K=K.replace(/%22/g,'"'),K=K.replace(/&#(\d{4});/g,(W,w)=>{return String.fromCharCode(w)}),K};B0=0,g={START_BOUNDARY:B0++,HEADER_FIELD_START:B0++,HEADER_FIELD:B0++,HEADER_VALUE_START:B0++,HEADER_VALUE:B0++,HEADER_VALUE_ALMOST_DONE:B0++,HEADERS_ALMOST_DONE:B0++,PART_DATA_START:B0++,PART_DATA:B0++,END:B0++},q5=1,m0={PART_BOUNDARY:q5,LAST_BOUNDARY:q5*=2},A$=10,x$=13,kX=32,u1=45,_X=58,LX=97,SX=122,vX=(X)=>X|32,e0=()=>{}});var l5=g0((QZ,oX)=>{oX.exports={name:"dotenv",version:"16.4.5",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard","lint-readme":"standard-markdown",pretest:"npm run lint && npm run dts-check",test:"tap tests/*.js --100 -Rspec","test:coverage":"tap --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@definitelytyped/dtslint":"^0.0.133","@types/node":"^18.11.3",decache:"^4.6.1",sinon:"^14.0.1",standard:"^17.0.0","standard-markdown":"^7.1.0","standard-version":"^9.5.0",tap:"^16.3.0",tar:"^6.1.11",typescript:"^4.8.4"},engines:{node:">=12"},browser:{fs:!1}}});var o5=g0((XZ,R0)=>{var QG=function(X){const G={};let J=X.toString();J=J.replace(/\r\n?/mg,"\n");let K;while((K=$G.exec(J))!=null){const W=K[1];let w=K[2]||"";w=w.trim();const O=w[0];if(w=w.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),O==='"')w=w.replace(/\\n/g,"\n"),w=w.replace(/\\r/g,"\r");G[W]=w}return G},XG=function(X){const G=a5(X),J=u.configDotenv({path:G});if(!J.parsed){const O=new Error(`MISSING_DATA: Cannot parse ${G} for an unknown reason`);throw O.code="MISSING_DATA",O}const K=s5(X).split(","),W=K.length;let w;for(let O=0;O<W;O++)try{const H=K[O].trim(),I=JG(J,H);w=u.decrypt(I.ciphertext,I.key);break}catch(H){if(O+1>=W)throw H}return u.parse(w)},GG=function(X){console.log(`[dotenv@${v4}][INFO] ${X}`)},ZG=function(X){console.log(`[dotenv@${v4}][WARN] ${X}`)},R$=function(X){console.log(`[dotenv@${v4}][DEBUG] ${X}`)},s5=function(X){if(X&&X.DOTENV_KEY&&X.DOTENV_KEY.length>0)return X.DOTENV_KEY;if(process.env.DOTENV_KEY&&process.env.DOTENV_KEY.length>0)return process.env.DOTENV_KEY;return""},JG=function(X,G){let J;try{J=new URL(G)}catch(H){if(H.code==="ERR_INVALID_URL"){const I=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw I.code="INVALID_DOTENV_KEY",I}throw H}const K=J.password;if(!K){const H=new Error("INVALID_DOTENV_KEY: Missing key part");throw H.code="INVALID_DOTENV_KEY",H}const W=J.searchParams.get("environment");if(!W){const H=new Error("INVALID_DOTENV_KEY: Missing environment part");throw H.code="INVALID_DOTENV_KEY",H}const w=`DOTENV_VAULT_${W.toUpperCase()}`,O=X.parsed[w];if(!O){const H=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${w} in your .env.vault file.`);throw H.code="NOT_FOUND_DOTENV_ENVIRONMENT",H}return{ciphertext:O,key:K}},a5=function(X){let G=null;if(X&&X.path&&X.path.length>0)if(Array.isArray(X.path)){for(let J of X.path)if(L4.existsSync(J))G=J.endsWith(".vault")?J:`${J}.vault`}else G=X.path.endsWith(".vault")?X.path:`${X.path}.vault`;else G=S4.resolve(process.cwd(),".env.vault");if(L4.existsSync(G))return G;return null},n5=function(X){return X[0]==="~"?S4.join(tX.homedir(),X.slice(1)):X},KG=function(X){GG("Loading env from encrypted .env.vault");const G=u._parseVault(X);let J=process.env;if(X&&X.processEnv!=null)J=X.processEnv;return u.populate(J,G,X),{parsed:G}},WG=function(X){const G=S4.resolve(process.cwd(),".env");let J="utf8";const K=Boolean(X&&X.debug);if(X&&X.encoding)J=X.encoding;else if(K)R$("No encoding is specified. UTF-8 is used by default");let W=[G];if(X&&X.path)if(!Array.isArray(X.path))W=[n5(X.path)];else{W=[];for(let I of X.path)W.push(n5(I))}let w;const O={};for(let I of W)try{const U=u.parse(L4.readFileSync(I,{encoding:J}));u.populate(O,U,X)}catch(U){if(K)R$(`Failed to load ${I} ${U.message}`);w=U}let H=process.env;if(X&&X.processEnv!=null)H=X.processEnv;if(u.populate(H,O,X),w)return{parsed:O,error:w};else return{parsed:O}},YG=function(X){if(s5(X).length===0)return u.configDotenv(X);const G=a5(X);if(!G)return ZG(`You set DOTENV_KEY but you are missing a .env.vault file at ${G}. Did you forget to build it?`),u.configDotenv(X);return u._configVault(X)},wG=function(X,G){const J=Buffer.from(G.slice(-64),"hex");let K=Buffer.from(X,"base64");const W=K.subarray(0,12),w=K.subarray(-16);K=K.subarray(12,-16);try{const O=rX.createDecipheriv("aes-256-gcm",J,W);return O.setAuthTag(w),`${O.update(K)}${O.final()}`}catch(O){const H=O instanceof RangeError,I=O.message==="Invalid key length",U=O.message==="Unsupported state or unable to authenticate data";if(H||I){const B=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw B.code="INVALID_DOTENV_KEY",B}else if(U){const B=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw B.code="DECRYPTION_FAILED",B}else throw O}},VG=function(X,G,J={}){const K=Boolean(J&&J.debug),W=Boolean(J&&J.override);if(typeof G!=="object"){const w=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw w.code="OBJECT_REQUIRED",w}for(let w of Object.keys(G))if(Object.prototype.hasOwnProperty.call(X,w)){if(W===!0)X[w]=G[w];if(K)if(W===!0)R$(`"${w}" is already defined and WAS overwritten`);else R$(`"${w}" is already defined and was NOT overwritten`)}else X[w]=G[w]},L4=y0("fs"),S4=y0("path"),tX=y0("os"),rX=y0("crypto"),eX=l5(),v4=eX.version,$G=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg,u={configDotenv:WG,_configVault:KG,_parseVault:XG,config:YG,decrypt:wG,parse:QG,populate:VG};XZ.configDotenv=u.configDotenv;XZ._configVault=u._configVault;XZ._parseVault=u._parseVault;XZ.config=u.config;XZ.decrypt=u.decrypt;XZ.parse=u.parse;XZ.populate=u.populate;R0.exports=u});var r5=g0((GZ,t5)=>{var P1={};if(process.env.DOTENV_CONFIG_ENCODING!=null)P1.encoding=process.env.DOTENV_CONFIG_ENCODING;if(process.env.DOTENV_CONFIG_PATH!=null)P1.path=process.env.DOTENV_CONFIG_PATH;if(process.env.DOTENV_CONFIG_DEBUG!=null)P1.debug=process.env.DOTENV_CONFIG_DEBUG;if(process.env.DOTENV_CONFIG_OVERRIDE!=null)P1.override=process.env.DOTENV_CONFIG_OVERRIDE;if(process.env.DOTENV_CONFIG_DOTENV_KEY!=null)P1.DOTENV_KEY=process.env.DOTENV_CONFIG_DOTENV_KEY;t5.exports=P1});var $8=g0((ZZ,e5)=>{var DG=/^dotenv_config_(encoding|path|debug|override|DOTENV_KEY)=(.+)$/;e5.exports=function X(G){return G.reduce(function(J,K){const W=K.match(DG);if(W)J[W[1]]=W[2];return J},{})}});var Q8=g0(()=>{(function(){o5().config(Object.assign({},r5(),$8()(process.argv)))})()});var QX=function(){const X=new Map;for(let[G,J]of Object.entries(b)){for(let[K,W]of Object.entries(J))b[K]={open:`\x1B[${W[0]}m`,close:`\x1B[${W[1]}m`},J[K]=b[K],X.set(W[0],W[1]);Object.defineProperty(b,G,{value:J,enumerable:!1})}return Object.defineProperty(b,"codes",{value:X,enumerable:!1}),b.color.close="\x1B[39m",b.bgColor.close="\x1B[49m",b.color.ansi=t6(),b.color.ansi256=r6(),b.color.ansi16m=e6(),b.bgColor.ansi=t6(10),b.bgColor.ansi256=r6(10),b.bgColor.ansi16m=e6(10),Object.defineProperties(b,{rgbToAnsi256:{value(G,J,K){if(G===J&&J===K){if(G<8)return 16;if(G>248)return 231;return Math.round((G-8)/247*24)+232}return 16+36*Math.round(G/255*5)+6*Math.round(J/255*5)+Math.round(K/255*5)},enumerable:!1},hexToRgb:{value(G){const J=/[a-f\d]{6}|[a-f\d]{3}/i.exec(G.toString(16));if(!J)return[0,0,0];let[K]=J;if(K.length===3)K=[...K].map((w)=>w+w).join("");const W=Number.parseInt(K,16);return[W>>16&255,W>>8&255,W&255]},enumerable:!1},hexToAnsi256:{value:(G)=>b.rgbToAnsi256(...b.hexToRgb(G)),enumerable:!1},ansi256ToAnsi:{value(G){if(G<8)return 30+G;if(G<16)return 90+(G-8);let J,K,W;if(G>=232)J=((G-232)*10+8)/255,K=J,W=J;else{G-=16;const H=G%36;J=Math.floor(G/36)/5,K=Math.floor(H/6)/5,W=H%6/5}const w=Math.max(J,K,W)*2;if(w===0)return 30;let O=30+(Math.round(W)<<2|Math.round(K)<<1|Math.round(J));if(w===2)O+=60;return O},enumerable:!1},rgbToAnsi:{value:(G,J,K)=>b.ansi256ToAnsi(b.rgbToAnsi256(G,J,K)),enumerable:!1},hexToAnsi:{value:(G)=>b.ansi256ToAnsi(b.hexToAnsi256(G)),enumerable:!1}}),b};var t6=(X=0)=>(G)=>`\x1B[${G+X}m`,r6=(X=0)=>(G)=>`\x1B[${38+X};5;${G}m`,e6=(X=0)=>(G,J,K)=>`\x1B[${38+X};2;${G};${J};${K}m`,b={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}},AG=Object.keys(b.modifier),eQ=Object.keys(b.color),$X=Object.keys(b.bgColor),xG=[...eQ,...$X],XX=QX(),Y0=XX;import P4 from"node:process";import GX from"node:os";import $5 from"node:tty";var Z0=function(X,G=globalThis.Deno?globalThis.Deno.args:P4.argv){const J=X.startsWith("-")?"":X.length===1?"-":"--",K=G.indexOf(J+X),W=G.indexOf("--");return K!==-1&&(W===-1||K<W)},ZX=function(){if("FORCE_COLOR"in m){if(m.FORCE_COLOR==="true")return 1;if(m.FORCE_COLOR==="false")return 0;return m.FORCE_COLOR.length===0?1:Math.min(Number.parseInt(m.FORCE_COLOR,10),3)}},JX=function(X){if(X===0)return!1;return{level:X,hasBasic:!0,has256:X>=2,has16m:X>=3}},KX=function(X,{streamIsTTY:G,sniffFlags:J=!0}={}){const K=ZX();if(K!==void 0)B$=K;const W=J?B$:K;if(W===0)return 0;if(J){if(Z0("color=16m")||Z0("color=full")||Z0("color=truecolor"))return 3;if(Z0("color=256"))return 2}if("TF_BUILD"in m&&"AGENT_NAME"in m)return 1;if(X&&!G&&W===void 0)return 0;const w=W||0;if(m.TERM==="dumb")return w;if(P4.platform==="win32"){const O=GX.release().split(".");if(Number(O[0])>=10&&Number(O[2])>=10586)return Number(O[2])>=14931?3:2;return 1}if("CI"in m){if("GITHUB_ACTIONS"in m||"GITEA_ACTIONS"in m)return 3;if(["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","BUILDKITE","DRONE"].some((O)=>(O in m))||m.CI_NAME==="codeship")return 1;return w}if("TEAMCITY_VERSION"in m)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(m.TEAMCITY_VERSION)?1:0;if(m.COLORTERM==="truecolor")return 3;if(m.TERM==="xterm-kitty")return 3;if("TERM_PROGRAM"in m){const O=Number.parseInt((m.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(m.TERM_PROGRAM){case"iTerm.app":return O>=3?3:2;case"Apple_Terminal":return 2}}if(/-256(color)?$/i.test(m.TERM))return 2;if(/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(m.TERM))return 1;if("COLORTERM"in m)return 1;return w};function Q5(X,G={}){const J=KX(X,{streamIsTTY:X&&X.isTTY,...G});return JX(J)}var{env:m}=P4,B$;if(Z0("no-color")||Z0("no-colors")||Z0("color=false")||Z0("color=never"))B$=0;else if(Z0("color")||Z0("colors")||Z0("color=true")||Z0("color=always"))B$=1;var WX={stdout:Q5({isTTY:$5.isatty(1)}),stderr:Q5({isTTY:$5.isatty(2)})},X5=WX;function G5(X,G,J){let K=X.indexOf(G);if(K===-1)return X;const W=G.length;let w=0,O="";do O+=X.slice(w,K)+G+J,w=K+W,K=X.indexOf(G,w);while(K!==-1);return O+=X.slice(w),O}function Z5(X,G,J,K){let W=0,w="";do{const O=X[K-1]==="\r";w+=X.slice(W,O?K-1:K)+G+(O?"\r\n":"\n")+J,W=K+1,K=X.indexOf("\n",W)}while(K!==-1);return w+=X.slice(W),w}var g1=function(X){return wX(X)};var{stdout:J5,stderr:K5}=X5,C4=Symbol("GENERATOR"),O1=Symbol("STYLER"),h1=Symbol("IS_EMPTY"),W5=["ansi","ansi","ansi256","ansi16m"],H1=Object.create(null),YX=(X,G={})=>{if(G.level&&!(Number.isInteger(G.level)&&G.level>=0&&G.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const J=J5?J5.level:0;X.level=G.level===void 0?J:G.level};var wX=(X)=>{const G=(...J)=>J.join(" ");return YX(G,X),Object.setPrototypeOf(G,g1.prototype),G};Object.setPrototypeOf(g1.prototype,Function.prototype);for(let[X,G]of Object.entries(Y0))H1[X]={get(){const J=I$(this,x4(G.open,G.close,this[O1]),this[h1]);return Object.defineProperty(this,X,{value:J}),J}};H1.visible={get(){const X=I$(this,this[O1],!0);return Object.defineProperty(this,"visible",{value:X}),X}};var A4=(X,G,J,...K)=>{if(X==="rgb"){if(G==="ansi16m")return Y0[J].ansi16m(...K);if(G==="ansi256")return Y0[J].ansi256(Y0.rgbToAnsi256(...K));return Y0[J].ansi(Y0.rgbToAnsi(...K))}if(X==="hex")return A4("rgb",G,J,...Y0.hexToRgb(...K));return Y0[J][X](...K)},VX=["rgb","hex","ansi256"];for(let X of VX){H1[X]={get(){const{level:J}=this;return function(...K){const W=x4(A4(X,W5[J],"color",...K),Y0.color.close,this[O1]);return I$(this,W,this[h1])}}};const G="bg"+X[0].toUpperCase()+X.slice(1);H1[G]={get(){const{level:J}=this;return function(...K){const W=x4(A4(X,W5[J],"bgColor",...K),Y0.bgColor.close,this[O1]);return I$(this,W,this[h1])}}}}var zX=Object.defineProperties(()=>{},{...H1,level:{enumerable:!0,get(){return this[C4].level},set(X){this[C4].level=X}}}),x4=(X,G,J)=>{let K,W;if(J===void 0)K=X,W=G;else K=J.openAll+X,W=G+J.closeAll;return{open:X,close:G,openAll:K,closeAll:W,parent:J}},I$=(X,G,J)=>{const K=(...W)=>OX(K,W.length===1?""+W[0]:W.join(" "));return Object.setPrototypeOf(K,zX),K[C4]=X,K[O1]=G,K[h1]=J,K},OX=(X,G)=>{if(X.level<=0||!G)return X[h1]?"":G;let J=X[O1];if(J===void 0)return G;const{openAll:K,closeAll:W}=J;if(G.includes("\x1B"))while(J!==void 0)G=G5(G,J.close,J.open),J=J.parent;const w=G.indexOf("\n");if(w!==-1)G=Z5(G,W,K,w);return K+G+W};Object.defineProperties(g1.prototype,H1);var HX=g1(),LG=g1({level:K5?K5.level:0});var o0=HX;var MX=/d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g,UX=/\b(?:[A-Z]{1,3}[A-Z][TC])(?:[-+]\d{4})?|((?:Australian )?(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time)\b/g,BX=/[^-+\dA-Z]/g;function a(X,G,J,K){if(arguments.length===1&&typeof X==="string"&&!/\d/.test(X))G=X,X=void 0;if(X=X||X===0?X:new Date,!(X instanceof Date))X=new Date(X);if(isNaN(X))throw TypeError("Invalid date");G=String(Y5[G]||G||Y5.default);var W=G.slice(0,4);if(W==="UTC:"||W==="GMT:"){if(G=G.slice(4),J=!0,W==="GMT:")K=!0}var w=function D(){return J?"getUTC":"get"},O=function D(){return X[w()+"Date"]()},H=function D(){return X[w()+"Day"]()},I=function D(){return X[w()+"Month"]()},U=function D(){return X[w()+"FullYear"]()},B=function D(){return X[w()+"Hours"]()},L=function D(){return X[w()+"Minutes"]()},T=function D(){return X[w()+"Seconds"]()},E=function D(){return X[w()+"Milliseconds"]()},C=function D(){return J?0:X.getTimezoneOffset()},S=function D(){return IX(X)},_=function D(){return DX(X)},F={d:function D(){return O()},dd:function D(){return r(O())},ddd:function D(){return s.dayNames[H()]},DDD:function D(){return w5({y:U(),m:I(),d:O(),_:w(),dayName:s.dayNames[H()],short:!0})},dddd:function D(){return s.dayNames[H()+7]},DDDD:function D(){return w5({y:U(),m:I(),d:O(),_:w(),dayName:s.dayNames[H()+7]})},m:function D(){return I()+1},mm:function D(){return r(I()+1)},mmm:function D(){return s.monthNames[I()]},mmmm:function D(){return s.monthNames[I()+12]},yy:function D(){return String(U()).slice(2)},yyyy:function D(){return r(U(),4)},h:function D(){return B()%12||12},hh:function D(){return r(B()%12||12)},H:function D(){return B()},HH:function D(){return r(B())},M:function D(){return L()},MM:function D(){return r(L())},s:function D(){return T()},ss:function D(){return r(T())},l:function D(){return r(E(),3)},L:function D(){return r(Math.floor(E()/10))},t:function D(){return B()<12?s.timeNames[0]:s.timeNames[1]},tt:function D(){return B()<12?s.timeNames[2]:s.timeNames[3]},T:function D(){return B()<12?s.timeNames[4]:s.timeNames[5]},TT:function D(){return B()<12?s.timeNames[6]:s.timeNames[7]},Z:function D(){return K?"GMT":J?"UTC":PX(X)},o:function D(){return(C()>0?"-":"+")+r(Math.floor(Math.abs(C())/60)*100+Math.abs(C())%60,4)},p:function D(){return(C()>0?"-":"+")+r(Math.floor(Math.abs(C())/60),2)+":"+r(Math.floor(Math.abs(C())%60),2)},S:function D(){return["th","st","nd","rd"][O()%10>3?0:(O()%100-O()%10!=10)*O()%10]},W:function D(){return S()},WW:function D(){return r(S())},N:function D(){return _()}};return G.replace(MX,function(D){if(D in F)return F[D]();return D.slice(1,D.length-1)})}var Y5={default:"ddd mmm dd yyyy HH:MM:ss",shortDate:"m/d/yy",paddedShortDate:"mm/dd/yyyy",mediumDate:"mmm d, yyyy",longDate:"mmmm d, yyyy",fullDate:"dddd, mmmm d, yyyy",shortTime:"h:MM TT",mediumTime:"h:MM:ss TT",longTime:"h:MM:ss TT Z",isoDate:"yyyy-mm-dd",isoTime:"HH:MM:ss",isoDateTime:"yyyy-mm-dd'T'HH:MM:sso",isoUtcDateTime:"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",expiresHeaderFormat:"ddd, dd mmm yyyy HH:MM:ss Z"},s={dayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","January","February","March","April","May","June","July","August","September","October","November","December"],timeNames:["a","p","am","pm","A","P","AM","PM"]},r=function X(G){var J=arguments.length>1&&arguments[1]!==void 0?arguments[1]:2;return String(G).padStart(J,"0")},w5=function X(G){var{y:J,m:K,d:W,_:w,dayName:O,short:H}=G,I=H===void 0?!1:H,U=new Date,B=new Date;B.setDate(B[w+"Date"]()-1);var L=new Date;L.setDate(L[w+"Date"]()+1);var T=function j(){return U[w+"Date"]()},E=function j(){return U[w+"Month"]()},C=function j(){return U[w+"FullYear"]()},S=function j(){return B[w+"Date"]()},_=function j(){return B[w+"Month"]()},F=function j(){return B[w+"FullYear"]()},D=function j(){return L[w+"Date"]()},y=function j(){return L[w+"Month"]()},f=function j(){return L[w+"FullYear"]()};if(C()===J&&E()===K&&T()===W)return I?"Tdy":"Today";else if(F()===J&&_()===K&&S()===W)return I?"Ysd":"Yesterday";else if(f()===J&&y()===K&&D()===W)return I?"Tmw":"Tomorrow";return O},IX=function X(G){var J=new Date(G.getFullYear(),G.getMonth(),G.getDate());J.setDate(J.getDate()-(J.getDay()+6)%7+3);var K=new Date(J.getFullYear(),0,4);K.setDate(K.getDate()-(K.getDay()+6)%7+3);var W=J.getTimezoneOffset()-K.getTimezoneOffset();J.setHours(J.getHours()-W);var w=(J-K)/604800000;return 1+Math.floor(w)},DX=function X(G){var J=G.getDay();if(J===0)J=7;return J},PX=function X(G){return(String(G).match(UX)||[""]).pop().replace(BX,"").replace(/GMT\+0000/g,"UTC")};import*as V0 from"node:fs";import lX from"node:http";import nX from"node:https";import I1 from"node:zlib";import d5,{PassThrough as i5,pipeline as D1} from"node:stream";import{Buffer as j$} from"node:buffer";function CX(X){if(!/^data:/i.test(X))throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');X=X.replace(/\r?\n/g,"");const G=X.indexOf(",");if(G===-1||G<=4)throw new TypeError("malformed data: URI");const J=X.substring(5,G).split(";");let K="",W=!1;const w=J[0]||"text/plain";let O=w;for(let B=1;B<J.length;B++)if(J[B]==="base64")W=!0;else if(J[B]){if(O+=`;${J[B]}`,J[B].indexOf("charset=")===0)K=J[B].substring(8)}if(!J[0]&&!K.length)O+=";charset=US-ASCII",K="US-ASCII";const H=W?"base64":"ascii",I=unescape(X.substring(G+1)),U=Buffer.from(I,H);return U.type=w,U.typeFull=O,U.charset=K,U}var V5=CX;y1();P$();import u0,{PassThrough as k5} from"node:stream";import{types as _5,deprecate as R4,promisify as gX} from"node:util";import{Buffer as J0} from"node:buffer";class b0 extends Error{constructor(X,G){super(X);Error.captureStackTrace(this,this.constructor),this.type=G}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class e extends b0{constructor(X,G,J){super(X,G);if(J)this.code=this.errno=J.code,this.erroredSysCall=J.syscall}}var C$=Symbol.toStringTag,q4=(X)=>{return typeof X==="object"&&typeof X.append==="function"&&typeof X.delete==="function"&&typeof X.get==="function"&&typeof X.getAll==="function"&&typeof X.has==="function"&&typeof X.set==="function"&&typeof X.sort==="function"&&X[C$]==="URLSearchParams"},m1=(X)=>{return X&&typeof X==="object"&&typeof X.arrayBuffer==="function"&&typeof X.type==="string"&&typeof X.stream==="function"&&typeof X.constructor==="function"&&/^(Blob|File)$/.test(X[C$])},P5=(X)=>{return typeof X==="object"&&(X[C$]==="AbortSignal"||X[C$]==="EventTarget")},C5=(X,G)=>{const J=new URL(G).hostname,K=new URL(X).hostname;return J===K||J.endsWith(`.${K}`)},A5=(X,G)=>{const J=new URL(G).protocol,K=new URL(X).protocol;return J===K};async function T4(X){if(X[o].disturbed)throw new TypeError(`body used already for: ${X.url}`);if(X[o].disturbed=!0,X[o].error)throw X[o].error;const{body:G}=X;if(G===null)return J0.alloc(0);if(!(G instanceof u0))return J0.alloc(0);const J=[];let K=0;try{for await(let W of G){if(X.size>0&&K+W.length>X.size){const w=new e(`content size at ${X.url} over limit: ${X.size}`,"max-size");throw G.destroy(w),w}K+=W.length,J.push(W)}}catch(W){throw W instanceof b0?W:new e(`Invalid response body while trying to fetch ${X.url}: ${W.message}`,"system",W)}if(G.readableEnded===!0||G._readableState.ended===!0)try{if(J.every((W)=>typeof W==="string"))return J0.from(J.join(""));return J0.concat(J,K)}catch(W){throw new e(`Could not create Buffer from response body for ${X.url}: ${W.message}`,"system",W)}else throw new e(`Premature close of server response while trying to fetch ${X.url}`)}var yX=gX(u0.pipeline),o=Symbol("Body internals");class T0{constructor(X,{size:G=0}={}){let J=null;if(X===null)X=null;else if(q4(X))X=J0.from(X.toString());else if(m1(X));else if(J0.isBuffer(X));else if(_5.isAnyArrayBuffer(X))X=J0.from(X);else if(ArrayBuffer.isView(X))X=J0.from(X.buffer,X.byteOffset,X.byteLength);else if(X instanceof u0);else if(X instanceof r0)X=D5(X),J=X.type.split("=")[1];else X=J0.from(String(X));let K=X;if(J0.isBuffer(X))K=u0.Readable.from(X);else if(m1(X))K=u0.Readable.from(X.stream());if(this[o]={body:X,stream:K,boundary:J,disturbed:!1,error:null},this.size=G,X instanceof u0)X.on("error",(W)=>{const w=W instanceof b0?W:new e(`Invalid response body while trying to fetch ${this.url}: ${W.message}`,"system",W);this[o].error=w})}get body(){return this[o].stream}get bodyUsed(){return this[o].disturbed}async arrayBuffer(){const{buffer:X,byteOffset:G,byteLength:J}=await T4(this);return X.slice(G,G+J)}async formData(){const X=this.headers.get("content-type");if(X.startsWith("application/x-www-form-urlencoded")){const J=new r0,K=new URLSearchParams(await this.text());for(let[W,w]of K)J.append(W,w);return J}const{toFormData:G}=await Promise.resolve().then(() => (R5(),T5));return G(this.body,X)}async blob(){const X=this.headers&&this.headers.get("content-type")||this[o].body&&this[o].body.type||"",G=await this.arrayBuffer();return new j0([G],{type:X})}async json(){const X=await this.text();return JSON.parse(X)}async text(){const X=await T4(this);return(new TextDecoder()).decode(X)}buffer(){return T4(this)}}T0.prototype.buffer=R4(T0.prototype.buffer,"Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'","node-fetch#buffer");Object.defineProperties(T0.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0},data:{get:R4(()=>{},"data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});var U1=(X,G)=>{let J,K,{body:W}=X[o];if(X.bodyUsed)throw new Error("cannot clone body after it is used");if(W instanceof u0&&typeof W.getBoundary!=="function")J=new k5({highWaterMark:G}),K=new k5({highWaterMark:G}),W.pipe(J),W.pipe(K),X[o].stream=J,W=K;return W},bX=R4((X)=>X.getBoundary(),"form-data doesn\'t follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167"),E$=(X,G)=>{if(X===null)return null;if(typeof X==="string")return"text/plain;charset=UTF-8";if(q4(X))return"application/x-www-form-urlencoded;charset=UTF-8";if(m1(X))return X.type||null;if(J0.isBuffer(X)||_5.isAnyArrayBuffer(X)||ArrayBuffer.isView(X))return null;if(X instanceof r0)return`multipart/form-data; boundary=${G[o].boundary}`;if(X&&typeof X.getBoundary==="function")return`multipart/form-data;boundary=${bX(X)}`;if(X instanceof u0)return null;return"text/plain;charset=UTF-8"},L5=(X)=>{const{body:G}=X[o];if(G===null)return 0;if(m1(G))return G.size;if(J0.isBuffer(G))return G.length;if(G&&typeof G.getLengthSync==="function")return G.hasKnownLength&&G.hasKnownLength()?G.getLengthSync():null;return null},S5=async(X,{body:G})=>{if(G===null)X.end();else await yX(G,X)};import{types as v5} from"node:util";import N$ from"node:http";function f5(X=[]){return new $0(X.reduce((G,J,K,W)=>{if(K%2===0)G.push(W.slice(K,K+2));return G},[]).filter(([G,J])=>{try{return F$(G),k4(G,String(J)),!0}catch{return!1}}))}var F$=typeof N$.validateHeaderName==="function"?N$.validateHeaderName:(X)=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(X)){const G=new TypeError(`Header name must be a valid HTTP token [${X}]`);throw Object.defineProperty(G,"code",{value:"ERR_INVALID_HTTP_TOKEN"}),G}},k4=typeof N$.validateHeaderValue==="function"?N$.validateHeaderValue:(X,G)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(G)){const J=new TypeError(`Invalid character in header content ["${X}"]`);throw Object.defineProperty(J,"code",{value:"ERR_INVALID_CHAR"}),J}};class $0 extends URLSearchParams{constructor(X){let G=[];if(X instanceof $0){const J=X.raw();for(let[K,W]of Object.entries(J))G.push(...W.map((w)=>[K,w]))}else if(X==null);else if(typeof X==="object"&&!v5.isBoxedPrimitive(X)){const J=X[Symbol.iterator];if(J==null)G.push(...Object.entries(X));else{if(typeof J!=="function")throw new TypeError("Header pairs must be iterable");G=[...X].map((K)=>{if(typeof K!=="object"||v5.isBoxedPrimitive(K))throw new TypeError("Each header pair must be an iterable object");return[...K]}).map((K)=>{if(K.length!==2)throw new TypeError("Each header pair must be a name/value tuple");return[...K]})}}else throw new TypeError("Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");G=G.length>0?G.map(([J,K])=>{return F$(J),k4(J,String(K)),[String(J).toLowerCase(),String(K)]}):void 0;super(G);return new Proxy(this,{get(J,K,W){switch(K){case"append":case"set":return(w,O)=>{return F$(w),k4(w,String(O)),URLSearchParams.prototype[K].call(J,String(w).toLowerCase(),String(O))};case"delete":case"has":case"getAll":return(w)=>{return F$(w),URLSearchParams.prototype[K].call(J,String(w).toLowerCase())};case"keys":return()=>{return J.sort(),new Set(URLSearchParams.prototype.keys.call(J)).keys()};default:return Reflect.get(J,K,W)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(X){const G=this.getAll(X);if(G.length===0)return null;let J=G.join(", ");if(/^content-encoding$/i.test(X))J=J.toLowerCase();return J}forEach(X,G=void 0){for(let J of this.keys())Reflect.apply(X,G,[this.get(J),J,this])}*values(){for(let X of this.keys())yield this.get(X)}*entries(){for(let X of this.keys())yield[X,this.get(X)]}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce((X,G)=>{return X[G]=this.getAll(G),X},{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce((X,G)=>{const J=this.getAll(G);if(G==="host")X[G]=J[0];else X[G]=J.length>1?J:J[0];return X},{})}}Object.defineProperties($0.prototype,["get","entries","forEach","values"].reduce((X,G)=>{return X[G]={enumerable:!0},X},{}));var mX=new Set([301,302,303,307,308]),q$=(X)=>{return mX.has(X)};var w0=Symbol("Response internals");class l extends T0{constructor(X=null,G={}){super(X,G);const J=G.status!=null?G.status:200,K=new $0(G.headers);if(X!==null&&!K.has("Content-Type")){const W=E$(X,this);if(W)K.append("Content-Type",W)}this[w0]={type:"default",url:G.url,status:J,statusText:G.statusText||"",headers:K,counter:G.counter,highWaterMark:G.highWaterMark}}get type(){return this[w0].type}get url(){return this[w0].url||""}get status(){return this[w0].status}get ok(){return this[w0].status>=200&&this[w0].status<300}get redirected(){return this[w0].counter>0}get statusText(){return this[w0].statusText}get headers(){return this[w0].headers}get highWaterMark(){return this[w0].highWaterMark}clone(){return new l(U1(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(X,G=302){if(!q$(G))throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');return new l(null,{headers:{location:new URL(X).toString()},status:G})}static error(){const X=new l(null,{status:0,statusText:""});return X[w0].type="error",X}static json(X=void 0,G={}){const J=JSON.stringify(X);if(J===void 0)throw new TypeError("data is not JSON serializable");const K=new $0(G&&G.headers);if(!K.has("content-type"))K.set("content-type","application/json");return new l(J,{...G,headers:K})}get[Symbol.toStringTag](){return"Response"}}Object.defineProperties(l.prototype,{type:{enumerable:!0},url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}});import{format as cX} from"node:url";import{deprecate as dX} from"node:util";var h5=(X)=>{if(X.search)return X.search;const G=X.href.length-1,J=X.hash||(X.href[G]==="#"?"#":"");return X.href[G-J.length]==="?"?"?":""};import{isIP as uX} from"node:net";function g5(X,G=!1){if(X==null)return"no-referrer";if(X=new URL(X),/^(about|blob|data):$/.test(X.protocol))return"no-referrer";if(X.username="",X.password="",X.hash="",G)X.pathname="",X.search="";return X}function m5(X){if(!y5.has(X))throw new TypeError(`Invalid referrerPolicy: ${X}`);return X}function pX(X){if(/^(http|ws)s:$/.test(X.protocol))return!0;const G=X.host.replace(/(^\[)|(]$)/g,""),J=uX(G);if(J===4&&/^127\./.test(G))return!0;if(J===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(G))return!0;if(X.host==="localhost"||X.host.endsWith(".localhost"))return!1;if(X.protocol==="file:")return!0;return!1}function B1(X){if(/^about:(blank|srcdoc)$/.test(X))return!0;if(X.protocol==="data:")return!0;if(/^(blob|filesystem):$/.test(X.protocol))return!0;return pX(X)}function u5(X,{referrerURLCallback:G,referrerOriginCallback:J}={}){if(X.referrer==="no-referrer"||X.referrerPolicy==="")return null;const K=X.referrerPolicy;if(X.referrer==="about:client")return"no-referrer";const W=X.referrer;let w=g5(W),O=g5(W,!0);if(w.toString().length>4096)w=O;if(G)w=G(w);if(J)O=J(O);const H=new URL(X.url);switch(K){case"no-referrer":return"no-referrer";case"origin":return O;case"unsafe-url":return w;case"strict-origin":if(B1(w)&&!B1(H))return"no-referrer";return O.toString();case"strict-origin-when-cross-origin":if(w.origin===H.origin)return w;if(B1(w)&&!B1(H))return"no-referrer";return O;case"same-origin":if(w.origin===H.origin)return w;return"no-referrer";case"origin-when-cross-origin":if(w.origin===H.origin)return w;return O;case"no-referrer-when-downgrade":if(B1(w)&&!B1(H))return"no-referrer";return w;default:throw new TypeError(`Invalid referrerPolicy: ${K}`)}}function p5(X){const G=(X.get("referrer-policy")||"").split(/[,\s]+/);let J="";for(let K of G)if(K&&y5.has(K))J=K;return J}var y5=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]),b5="strict-origin-when-cross-origin";var c=Symbol("Request internals"),p1=(X)=>{return typeof X==="object"&&typeof X[c]==="object"},iX=dX(()=>{},".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");class $1 extends T0{constructor(X,G={}){let J;if(p1(X))J=new URL(X.url);else J=new URL(X),X={};if(J.username!==""||J.password!=="")throw new TypeError(`${J} is an url with embedded credentials.`);let K=G.method||X.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(K))K=K.toUpperCase();if(!p1(G)&&"data"in G)iX();if((G.body!=null||p1(X)&&X.body!==null)&&(K==="GET"||K==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");const W=G.body?G.body:p1(X)&&X.body!==null?U1(X):null;super(W,{size:G.size||X.size||0});const w=new $0(G.headers||X.headers||{});if(W!==null&&!w.has("Content-Type")){const I=E$(W,this);if(I)w.set("Content-Type",I)}let O=p1(X)?X.signal:null;if("signal"in G)O=G.signal;if(O!=null&&!P5(O))throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");let H=G.referrer==null?X.referrer:G.referrer;if(H==="")H="no-referrer";else if(H){const I=new URL(H);H=/^about:(\/\/)?client$/.test(I)?"client":I}else H=void 0;this[c]={method:K,redirect:G.redirect||X.redirect||"follow",headers:w,parsedURL:J,signal:O,referrer:H},this.follow=G.follow===void 0?X.follow===void 0?20:X.follow:G.follow,this.compress=G.compress===void 0?X.compress===void 0?!0:X.compress:G.compress,this.counter=G.counter||X.counter||0,this.agent=G.agent||X.agent,this.highWaterMark=G.highWaterMark||X.highWaterMark||16384,this.insecureHTTPParser=G.insecureHTTPParser||X.insecureHTTPParser||!1,this.referrerPolicy=G.referrerPolicy||X.referrerPolicy||""}get method(){return this[c].method}get url(){return cX(this[c].parsedURL)}get headers(){return this[c].headers}get redirect(){return this[c].redirect}get signal(){return this[c].signal}get referrer(){if(this[c].referrer==="no-referrer")return"";if(this[c].referrer==="client")return"about:client";if(this[c].referrer)return this[c].referrer.toString();return}get referrerPolicy(){return this[c].referrerPolicy}set referrerPolicy(X){this[c].referrerPolicy=m5(X)}clone(){return new $1(this)}get[Symbol.toStringTag](){return"Request"}}Object.defineProperties($1.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0},referrer:{enumerable:!0},referrerPolicy:{enumerable:!0}});var c5=(X)=>{const{parsedURL:G}=X[c],J=new $0(X[c].headers);if(!J.has("Accept"))J.set("Accept","*/*");let K=null;if(X.body===null&&/^(post|put)$/i.test(X.method))K="0";if(X.body!==null){const H=L5(X);if(typeof H==="number"&&!Number.isNaN(H))K=String(H)}if(K)J.set("Content-Length",K);if(X.referrerPolicy==="")X.referrerPolicy=b5;if(X.referrer&&X.referrer!=="no-referrer")X[c].referrer=u5(X);else X[c].referrer="no-referrer";if(X[c].referrer instanceof URL)J.set("Referer",X.referrer);if(!J.has("User-Agent"))J.set("User-Agent","node-fetch");if(X.compress&&!J.has("Accept-Encoding"))J.set("Accept-Encoding","gzip, deflate, br");let{agent:W}=X;if(typeof W==="function")W=W(G);const w=h5(G),O={path:G.pathname+w,method:X.method,headers:J[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:X.insecureHTTPParser,agent:W};return{parsedURL:G,options:O}};class _4 extends b0{constructor(X,G="aborted"){super(X,G)}}P$();j4();var aX=function(X,G){const J=j$.from("0\r\n\r\n");let K=!1,W=!1,w;X.on("response",(O)=>{const{headers:H}=O;K=H["transfer-encoding"]==="chunked"&&!H["content-length"]}),X.on("socket",(O)=>{const H=()=>{if(K&&!W){const U=new Error("Premature close");U.code="ERR_STREAM_PREMATURE_CLOSE",G(U)}},I=(U)=>{if(W=j$.compare(U.slice(-5),J)===0,!W&&w)W=j$.compare(w.slice(-3),J.slice(0,3))===0&&j$.compare(U.slice(-2),J.slice(3))===0;w=U};O.prependListener("close",H),O.on("data",I),X.on("close",()=>{O.removeListener("close",H),O.removeListener("data",I)})})};var sX=new Set(["data:","http:","https:"]);async function T$(X,G){return new Promise((J,K)=>{const W=new $1(X,G),{parsedURL:w,options:O}=c5(W);if(!sX.has(w.protocol))throw new TypeError(`node-fetch cannot load ${X}. URL scheme "${w.protocol.replace(/:$/,"")}" is not supported.`);if(w.protocol==="data:"){const C=V5(W.url),S=new l(C,{headers:{"Content-Type":C.typeFull}});J(S);return}const H=(w.protocol==="https:"?nX:lX).request,{signal:I}=W;let U=null;const B=()=>{const C=new _4("The operation was aborted.");if(K(C),W.body&&W.body instanceof d5.Readable)W.body.destroy(C);if(!U||!U.body)return;U.body.emit("error",C)};if(I&&I.aborted){B();return}const L=()=>{B(),E()},T=H(w.toString(),O);if(I)I.addEventListener("abort",L);const E=()=>{if(T.abort(),I)I.removeEventListener("abort",L)};if(T.on("error",(C)=>{K(new e(`request to ${W.url} failed, reason: ${C.message}`,"system",C)),E()}),aX(T,(C)=>{if(U&&U.body)U.body.destroy(C)}),process.version<"v14")T.on("socket",(C)=>{let S;C.prependListener("end",()=>{S=C._eventsCount}),C.prependListener("close",(_)=>{if(U&&S<C._eventsCount&&!_){const F=new Error("Premature close");F.code="ERR_STREAM_PREMATURE_CLOSE",U.body.emit("error",F)}})});T.on("response",(C)=>{T.setTimeout(0);const S=f5(C.rawHeaders);if(q$(C.statusCode)){const f=S.get("Location");let j=null;try{j=f===null?null:new URL(f,W.url)}catch{if(W.redirect!=="manual"){K(new e(`uri requested responds with an invalid redirect URL: ${f}`,"invalid-redirect")),E();return}}switch(W.redirect){case"error":K(new e(`uri requested responds with a redirect, redirect mode is set to error: ${W.url}`,"no-redirect")),E();return;case"manual":break;case"follow":{if(j===null)break;if(W.counter>=W.follow){K(new e(`maximum redirect reached at: ${W.url}`,"max-redirect")),E();return}const p={headers:new $0(W.headers),follow:W.follow,counter:W.counter+1,agent:W.agent,compress:W.compress,method:W.method,body:U1(W),signal:W.signal,size:W.size,referrer:W.referrer,referrerPolicy:W.referrerPolicy};if(!C5(W.url,j)||!A5(W.url,j))for(let A1 of["authorization","www-authenticate","cookie","cookie2"])p.headers.delete(A1);if(C.statusCode!==303&&W.body&&G.body instanceof d5.Readable){K(new e("Cannot follow redirect with body being a readable stream","unsupported-redirect")),E();return}if(C.statusCode===303||(C.statusCode===301||C.statusCode===302)&&W.method==="POST")p.method="GET",p.body=void 0,p.headers.delete("content-length");const C1=p5(S);if(C1)p.referrerPolicy=C1;J(T$(new $1(j,p))),E();return}default:return K(new TypeError(`Redirect option '${W.redirect}' is not a valid value of RequestRedirect`))}}if(I)C.once("end",()=>{I.removeEventListener("abort",L)});let _=D1(C,new i5,(f)=>{if(f)K(f)});if(process.version<"v12.10")C.on("aborted",L);const F={url:W.url,status:C.statusCode,statusText:C.statusMessage,headers:S,size:W.size,counter:W.counter,highWaterMark:W.highWaterMark},D=S.get("Content-Encoding");if(!W.compress||W.method==="HEAD"||D===null||C.statusCode===204||C.statusCode===304){U=new l(_,F),J(U);return}const y={flush:I1.Z_SYNC_FLUSH,finishFlush:I1.Z_SYNC_FLUSH};if(D==="gzip"||D==="x-gzip"){_=D1(_,I1.createGunzip(y),(f)=>{if(f)K(f)}),U=new l(_,F),J(U);return}if(D==="deflate"||D==="x-deflate"){const f=D1(C,new i5,(j)=>{if(j)K(j)});f.once("data",(j)=>{if((j[0]&15)===8)_=D1(_,I1.createInflate(),(p)=>{if(p)K(p)});else _=D1(_,I1.createInflateRaw(),(p)=>{if(p)K(p)});U=new l(_,F),J(U)}),f.once("end",()=>{if(!U)U=new l(_,F),J(U)});return}if(D==="br"){_=D1(_,I1.createBrotliDecompress(),(f)=>{if(f)K(f)}),U=new l(_,F),J(U);return}U=new l(_,F),J(U)}),S5(T,W).catch(K)})}var VZ=D4(Q8(),1),f4={show:{stdoutEnable:!0,mainProgram:!0,subProgram:!0,date:!0,dateformat:"yyyy-mm-dd HH:MM:ss:l Z",level:!0,ignoreLevels:process.env.ENVIRONMENT!="DEV"?["DEBUG"]:[]},logStorage:{path:"./logs",json:!0,txt:!0,splitBy:"day",stratagy:"batch",batch:6,ignoreLevels:process.env.ENVIRONMENT!="DEV"?["DEBUG"]:[]},logWebook:{enable:!1,url:void 0,form:""}};class X8{formatSettings;storageSettings;webhookSettings;mainProcess;subProcess;colours={FATAL:o0.bgRedBright,ERROR:o0.red,WARN:o0.yellow,SUCCESS:o0.green,INFO:o0.blue,DEBUG:o0.magenta};logBuffer=[];constructor(X,G,J={}){try{this.mainProcess=X,this.subProcess=G}catch(K){console.error("There was an issue with initialising process names"),process.exit(1)}try{this.formatSettings={...f4.show,...J.show}}catch(K){console.error("There was an issue with initialising settings: format Settings",J.show),process.exit(1)}try{this.storageSettings={...f4.logStorage,...J.logStorage}}catch(K){console.error("There was an issue with initialising settings: storage Settings",J.logStorage),process.exit(1)}try{this.webhookSettings={...f4.logWebook,...J.logWebook}}catch(K){console.error("There was an issue with initialising settings: webhook Settings",J.logWebook),process.exit(1)}try{this.success("Initialised Logger"),this.debug("Settings:\n"+JSON.stringify(this.formatSettings,null,4)),this.debug("\n"+JSON.stringify(this.storageSettings,null,4)),this.debug("\n"+JSON.stringify(this.webhookSettings,null,4)+"\n")}catch(K){console.error("There was an issue with logging settings"),process.exit(1)}}sendLog(X,G,J){try{const K=new Date,W=a(K,this.formatSettings.dateformat),w=this.handleLogDatatype(G),O=this.handleLogDatatype(J),H=this.formTxtLog(W,w,X,O);if(this.formatSettings.stdoutEnable&&!this.formatSettings.ignoreLevels.includes(X))console.log(this.colours[X](H));if((this.storageSettings.json||this.storageSettings.txt)&&!this.storageSettings.ignoreLevels.includes(X))this.logToFile(K,W,w,X,O,H);if(this.webhookSettings.enable)this.sendWebhook(K,W,w,X,O,H)}catch(K){console.error("There was an issue logging data",K)}}sendWebhook(X,G,J,K,W,w){if(K=="FATAL-RATE")return;if(this.webhookSettings.url==null)return;if(this.webhookSettings.form!="discord"){this.error("Currently only discord webhooks have been implemented");return}T$(this.webhookSettings.url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:`${this.mainProcess}.${this.subProcess}`,content:null,embeds:[{title:`[${K}] ${J}`,description:`${W}`,color:null,timestamp:X}],attachments:[]})}).then((O)=>{if(O.status!=204)this.fatalRate("Unexpected response from webhook",{status:O.status,message:O.statusText})}).catch((O)=>{this.fatalRate("Webhook failed to send",{error:O})})}formTxtLog(X,G,J,K){let W="";return W+=this.formatSettings.date?`[${X}] `:"",W+=this.formatSettings.mainProgram||this.formatSettings.subProgram?"<":"",W+=this.formatSettings.mainProgram?this.mainProcess:"",W+=this.formatSettings.mainProgram&&this.formatSettings.subProgram?".":"",W+=this.formatSettings.subProgram?this.subProcess:"",W+=this.formatSettings.mainProgram||this.formatSettings.subProgram?"> ":"",W+=this.formatSettings.level?`[${J}] `:"",W+=G,W+=K!=""?"\nLog Data:\n"+K:"",W}logToFile(X,G,J,K,W,w){const O={date:X,formattedDate:G,mainProcess:this.mainProcess,subProcess:this.subProcess,logLevel:K,logMessage:J,logData:W};let H="";try{H=JSON.stringify(O)}catch(I){this.error("Error converting logJSON to string",{error:I,data:O})}if(this.storageSettings.stratagy=="batch"&&this.storageSettings.batch>1){if(this.logBuffer.push({logTXT:w,logJSONString:H})>=this.storageSettings.batch)this.extractBuffer(X)}else{let{dirLocation:I,logLocation:U}=this.generatePaths(X);if(!V0.existsSync(I))V0.mkdirSync(I,{recursive:!0});if(this.storageSettings.txt){const B=V0.createWriteStream(U+"txt.log",{flags:"a"});B.write(w+"\n"),B.end()}if(this.storageSettings.json){const B=V0.createWriteStream(U+"json.log",{flags:"a"});B.write(H+"\n"),B.end()}}}generatePaths(X){let G="",J=this.storageSettings.path;switch(this.storageSettings.splitBy){case"don't split":J+="/",G+=J+"logs.";break;case"year":J+="/",G+=`${a(X,"yyyy")}.`;break;case"month":J+=`/${a(X,"yyyy")}/`,G+=J+`${a(X,"mm")}.`;break;case"day":J+=`/${a(X,"yyyy/mm")}/`,G+=J+`${a(X,"dd")}.`;break;case"hour":J+=`/${a(X,"yyyy/mm/dd")}/`,G+=J+`${a(X,"HH")}.`;break;case"minute":J+=`/${a(X,"yyyy/mm/dd/HH")}/`,G+=J+`${a(X,"MM")}.`;break;case"second":J+=`/${a(X,"yyyy/mm/dd/HH/MM")}/`,G+=J+`${a(X,"ss")}.`;break;default:this.error("Logger split by value is invalid",this.storageSettings.splitBy);break}return{dirLocation:J,logLocation:G}}extractBuffer(X){let{dirLocation:G,logLocation:J}=this.generatePaths(X);if(!V0.existsSync(G))V0.mkdirSync(G,{recursive:!0});let K="",W="",w=this.logBuffer.length;for(let O=0;O<w;O++){let H=this.logBuffer.shift();if(H==null)this.error("Log buffer item is empty whilst trying to read from it");else K+=H.logTXT+"\n",W+=H.logJSONString+"\n"}if(this.storageSettings.txt){const O=V0.createWriteStream(J+"txt.log",{flags:"a"});O.write(K),O.end()}if(this.storageSettings.json){const O=V0.createWriteStream(J+"json.log",{flags:"a"});O.write(W),O.end()}}handleLogDatatype(X){if(X==null)return"";const G=typeof X;if(G=="string")return X;if(["bigint","boolean","number","symbol","function"].includes(G))return X.toString();if(G=="object")try{return JSON.stringify(X,null,4)}catch(J){return this.error("Datatype of object is not json",{dataType:G,data:X}),""}return this.error("Datatype Error",{dataType:G,data:X}),"Datatype error"}fatal(X,G){this.sendLog("FATAL",X,G)}fatalRate(X,G){this.sendLog("FATAL-RATE",X,G)}error(X,G){this.sendLog("ERROR",X,G)}err=this.error;warn(X,G){this.sendLog("WARN",X,G)}success(X,G){this.sendLog("SUCCESS",X,G)}info(X,G){this.sendLog("INFO",X,G)}log=this.info;debug(X,G){this.sendLog("DEBUG",X,G)}exit(){if(this.storageSettings.stratagy=="batch")try{const X=new Date;this.extractBuffer(X),console.log("ready to shutdown")}catch(X){console.error("There was an issue clearing the buffer",X)}}}export{X8 as default};
