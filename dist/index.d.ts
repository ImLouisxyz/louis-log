// Generated by dts-bundle-generator v8.1.1

export type LogStorageSettings = {
	path: string;
	json: boolean;
	txt: boolean;
	splitBy: "don't split" | "year" | "month" | "day" | "hour" | "minute" | "second";
	stratagy: "single" | "batch";
	batch: number;
	ignoreLevels: LogLevel[];
};
export type LogWebhookSettings = {
	enable: boolean;
	url: URL | undefined;
	form?: "" | "discord";
};
export type LogFormatSettings = {
	stdoutEnable: boolean;
	mainProgram: boolean;
	subProgram: boolean;
	date: boolean;
	dateformat: string;
	level: boolean;
	ignoreLevels: LogLevel[];
};
export type CustomLoggerSettings = {
	logStorage: Partial<LogStorageSettings>;
	logWebook: Partial<LogWebhookSettings>;
	show: Partial<LogFormatSettings>;
};
export type LogLevel = "FATAL" | "FATALRATE" | "ERROR" | "WARN" | "SUCCESS" | "INFO" | "DEBUG";
export default class Logger {
	private formatSettings;
	private storageSettings;
	private webhookSettings;
	mainProcess: string;
	subProcess: string;
	processID: string;
	private colours;
	private logBuffer;
	private webhookBuffer;
	/**
	 * Creates a new Logger
	 * @param {string} mainProcess - The name of the main process
	 * @param {string} subProcess  - The name of the subprocess sending the message (eg. Database Handler, Web Server)
	 * @param {Partial<Types.CustomLoggerSettings>} userSettings - *optional* custom settings
	 * @example
		const logger = new louisLog.Logger("Example API", "/users")

		logger.fatal("This is a fatal error");
		logger.error("This is a normal error");
		logger.err("This is a shorthand for error");
		logger.warn("This is a warning");
		logger.success("This is a success message");
		logger.info("This is a normal log message");
		logger.log("This is also a normal log message");
		logger.debug("This is a debug message");
	*/
	constructor(mainProcess: string, subProcess: string, userSettings?: Partial<Types.CustomLoggerSettings>);
	private sendLog;
	private sendWebhook;
	private formTxtLog;
	private logToFile;
	private generatePaths;
	private extractBuffer;
	private handleLogDatatype;
	fatal(message: any, data?: any): void;
	private fatalRate;
	error(message: any, data?: any): void;
	err: (message: any, data?: any) => void;
	warn(message: any, data?: any): void;
	success(message: any, data?: any): void;
	info(message: any, data?: any): void;
	log: (message: any, data?: any) => void;
	debug(message: any, data?: any): void;
	/**
	 * Forces a cleanup and exit, use wisely.
	 * Automatically called on exit or uncaught exception.
	 *
	 * Ensures that all logs in memory are dealt with before closing.
	 */
	exit(reason?: string): Promise<void>;
}

export {};
